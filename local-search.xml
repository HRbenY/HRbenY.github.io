<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Adamw</title>
    <link href="/2026/01/23/obsidian/transformer/Adamw/"/>
    <url>/2026/01/23/obsidian/transformer/Adamw/</url>
    
    <content type="html"><![CDATA[<p>从SGD到Adamw，所有优化器的形式都类似<br>$$<br>w ;\leftarrow; w - \text{lr} \cdot \text{transformed_grad}<br>$$<br>区别只在于<code>transformed_grad</code> 是如何由原始梯度 <code>grad</code> 得到的。</p><h2 id="1-SGD"><a href="#1-SGD" class="headerlink" title="1. SGD"></a>1. SGD</h2><p>$$w \leftarrow w - \text{lr} \cdot \nabla_w L$$</p><h2 id="2-SGD-Momentum"><a href="#2-SGD-Momentum" class="headerlink" title="2. SGD+Momentum"></a>2. SGD+Momentum</h2><p>在SGD的基础上，进行时间维度平滑。<br>$$v_t &#x3D; \mu v_{t-1} + \nabla L$$<br>$$w \leftarrow w - \text{lr} \cdot v_t$$</p><ul><li>transformed_grad<br>$$transformed_grad &#x3D; EMA(grad)$$</li></ul><h2 id="3-AdaGrad"><a href="#3-AdaGrad" class="headerlink" title="3. AdaGrad"></a>3. AdaGrad</h2><p>Adagrad认为不同的参数应该使用不同的学习率。<br>$$r_t &#x3D; \beta r_{t-1} + (1-\beta)\nabla L^2$$<br>$$<br>w \leftarrow w - \text{lr} \cdot \frac{\nabla L}{\sqrt{r_t} + \epsilon}<br>$$</p><ul><li>transformed_grad<br>$$transformed_grad &#x3D; \frac{grad}{\sqrt{(EMA(grad^2))}}$$</li></ul><h2 id="4-Adam"><a href="#4-Adam" class="headerlink" title="4. Adam"></a>4. Adam</h2><p>Adam是Momentum和AdaGrad的结合。内部需要保存一阶矩和二阶矩。</p><ul><li>一阶矩：Momentum，代表梯度更新方向</li><li>二阶矩：梯度尺度。</li></ul><p>$$m_t &#x3D; \beta_1 m_{t-1} + (1-\beta_1)\nabla L$$<br>$$v_t &#x3D; \beta_2 v_{t-1} + (1-\beta_2)\nabla L^2$$<br>除此之外，因为 EMA 初期偏向 0，所以要对m和v进行偏置修正。（t是t次幂）<br>$$\hat m_t &#x3D; \frac{m_t}{1-\beta_1^t},<br>\quad<br>\hat v_t &#x3D; \frac{v_t}{1-\beta_2^t}$$</p><p>最终公式是<br>$$w \leftarrow w - \text{lr} \cdot \frac{\hat m_t}{\sqrt{\hat v_t} + \epsilon}<br>$$</p><ul><li>transformed_grad<br>$$transformed_grad &#x3D; EMA(grad) &#x2F; sqrt(EMA(grad^2))$$</li></ul><h2 id="5-Adamw"><a href="#5-Adamw" class="headerlink" title="5. Adamw"></a>5. Adamw</h2><p>值得注意的是，有一段时间人们误以为在 Adam 中简单地添加 L2 正则化（即把 $\lambda w$ 加到梯度中）就能达到权重衰减的效果，就像在 SGD 中那样。但这被证明在 Adam 这类自适应算法中是错误的。</p><p>我们上面提到Adam的更新是$$\Delta{\omega_i} &#x3D; -\text{lr} \cdot \frac{\hat m_t}{\sqrt{\hat v_t} + \epsilon}$$<br>注意，这里分子和分母中的$\hat{m}_t$和$\hat{v}_t$都是$\nabla L$的函数。我们在[[L2 Regularization]]提到，L2正则化会给总Loss加上一项，使得最终的梯度$\nabla L’ &#x3D; \nabla L + \lambda \omega$。因此，$\lambda \omega$会混入到分子和分母中，并因为Adam的自适应机制（$m_t$的平滑和 $v_t$的缩放）而扭曲，导致不同参数的正则化程度不同。</p><h2 id="正确方式"><a href="#正确方式" class="headerlink" title="正确方式"></a>正确方式</h2><p>解决方式很简单，我们调整一下加入$\lambda \omega$的时机，不在求出$\nabla L$后立刻引入，而是在最终的公式中加上一项$\lambda \omega$。即</p><p>$$<br>\Delta{\omega_i} &#x3D; -\text{lr} \cdot (\frac{\hat m_t}{\sqrt{\hat v_t} + \epsilon} + \lambda\omega)<br>$$</p><p>最终公式是$$w \leftarrow w - \text{lr} \cdot (\frac{\hat m_t}{\sqrt{\hat v_t} + \epsilon} + \lambda\omega)<br>$$</p>]]></content>
    
    
    
    <tags>
      
      <tag>transformer</tag>
      
      <tag>adamw</tag>
      
      <tag>optimization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LayerNorm</title>
    <link href="/2026/01/23/obsidian/transformer/LayerNorm/"/>
    <url>/2026/01/23/obsidian/transformer/LayerNorm/</url>
    
    <content type="html"><![CDATA[<blockquote><p>并不是BatchNorm简单的交换N和D。</p></blockquote><h2 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h2><p>在前向传播中，LayerNorm的公式就是BatchNorm交换N和D维度。LayerNorm在每个批次内部进行Normalization，而BatchNorm是跨Batch的Norm。导致mean和std_dev稍有不同。</p><h3 id="1-均值"><a href="#1-均值" class="headerlink" title="(1) 均值"></a>(1) 均值</h3><p>$$\mu &#x3D; \frac{1}{D} \sum_{i&#x3D;1}^{D} x_i$$</p><h3 id="2-方差"><a href="#2-方差" class="headerlink" title="(2) 方差"></a>(2) 方差</h3><p>$$\sigma^2 &#x3D; \frac{1}{D} \sum_{i&#x3D;1}^{D} (x_i - \mu)^2$$</p><h3 id="3-标准差-eps"><a href="#3-标准差-eps" class="headerlink" title="(3) 标准差 + eps"></a>(3) 标准差 + eps</h3><p>$$\sigma &#x3D; \sqrt{\sigma^2 + \varepsilon}$$</p><h3 id="4-归一化"><a href="#4-归一化" class="headerlink" title="(4) 归一化"></a>(4) 归一化</h3><p>$$\hat{x}_i &#x3D; \frac{x_i - \mu}{\sigma}$$</p><h3 id="5-仿射变换（gamma-beta）"><a href="#5-仿射变换（gamma-beta）" class="headerlink" title="(5) 仿射变换（gamma &#x2F; beta）"></a>(5) 仿射变换（gamma &#x2F; beta）</h3><p>$$y_i &#x3D; \gamma_i \hat{x}_i + \beta_i$$</p><h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><ul><li>已知 $$\frac{\partial L}{\partial y_i} &#x3D; d y_i$$</li><li>求 $$\frac{\partial L}{\partial x_i},\frac{\partial L}{\partial \gamma_i},\frac{\partial L}{\partial \beta_i}$$</li></ul><h3 id="beta"><a href="#beta" class="headerlink" title="$\beta$"></a>$\beta$</h3><p>$\beta$ 在y上进行了广播，所以累计y的梯度就行。<br>$$y_i &#x3D; \gamma_i \hat{x}_i + \beta_i<br>\Rightarrow<br>\frac{\partial L}{\partial \beta_i} &#x3D; \sum dy_i$$</p><h3 id="gamma"><a href="#gamma" class="headerlink" title="$\gamma$"></a>$\gamma$</h3><p>简单的乘法<br>$$\frac{\partial L}{\partial \gamma_i}<br>&#x3D; \sum dy_i \cdot \hat{x}_i$$</p><h3 id="dx"><a href="#dx" class="headerlink" title="dx"></a>dx</h3><p>传导路径</p><blockquote><p>x → μ → σ → x̂ → y → L</p></blockquote><p>而$$\hat{x}&#x3D;\frac{x_i - \mu}{\sigma}$$<br>其中$\mu$和$\sigma$都依赖于$x_i$，所以$x_i$一共有三条路径。</p><ol><li>直接贡献<br>$$\frac{\partial \hat{x}_i}{\partial x_i}<br>&#x3D; \frac{1}{\sigma}$$</li><li>$\mu$的贡献<br>$$\mu &#x3D; \frac{1}{D} \sum_k x_k<br>\Rightarrow<br>\frac{\partial \mu}{\partial x_j} &#x3D; \frac{1}{D}$$</li><li>$\sigma$的贡献<br>$$\sigma^2 &#x3D; \frac{1}{D} \sum_k (x_k - \mu)^2$$<br>$$\frac{\partial \sigma^2}{\partial x_j}<br>&#x3D; \frac{2}{D}(x_j - \mu)$$<br>$$\sigma &#x3D; \sqrt{\sigma^2 + \varepsilon}<br>\Rightarrow<br>\frac{\partial \sigma}{\partial x_j}<br>&#x3D; \frac{x_j - \mu}{D \sigma}$$</li></ol><ul><li>最终结果<br>$$\frac{\partial L}{\partial x_i}&#x3D;\frac{1}{D \sigma}<br>\left(<br>D \cdot d\hat{x}_i-\sum_j d\hat{x}_j-\hat{x}_i \sum_j d\hat{x}_j \hat{x}_j<br>\right)$$</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>transformer</tag>
      
      <tag>normalization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2 Regularization</title>
    <link href="/2026/01/23/obsidian/transformer/L2%20Regularization/"/>
    <url>/2026/01/23/obsidian/transformer/L2%20Regularization/</url>
    
    <content type="html"><![CDATA[<p>L2正则化的目的是权重衰减，让Loss和权重的L2范数正相关。在SGD和Momentum中不需多余处理就能达到这样的效果。但是Adagrad和Adam由于对梯度做了预处理，不能直接应用公式。（见[[Adamw]]）</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>防止模型<strong>过拟合 (Overfitting)</strong>。通过限制参数（权重 $w$）的大小，使模型变得更简单、更平滑，避免对训练数据中的噪声死记硬背。</p><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>总损失可以表示如下</p><p>$$<br>\mathcal{L}<em>{total}(w)&#x3D;\mathcal{L}</em>{data}(w)+\frac{\lambda}{2} | w | ^2<br>$$</p><p>对总损失求梯度</p><p>$$<br>\nabla_w \mathcal{L}<em>{total}&#x3D;\nabla_w \mathcal{L}</em>{data}+\nabla_w \left(\frac{\lambda}{2}| w |^2\right)<br>$$</p><p>可得</p><p>$$<br>\nabla_w \mathcal{L}_{total}&#x3D;\nabla_w \mathcal{L}+\lambda w<br>$$<br>梯度更新的过程随着采用的优化器不同而有区别。</p>]]></content>
    
    
    
    <tags>
      
      <tag>transformer</tag>
      
      <tag>regularization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Self-Attention机制(Q,K,V)</title>
    <link href="/2026/01/23/obsidian/transformer/Self-Attention%E6%9C%BA%E5%88%B6(Q,K,V)/"/>
    <url>/2026/01/23/obsidian/transformer/Self-Attention%E6%9C%BA%E5%88%B6(Q,K,V)/</url>
    
    <content type="html"><![CDATA[<p>$$\text{Attention}(Q, K, V) &#x3D; \text{softmax}\left( \frac{QK^T}{\sqrt{d_k}} \right) V$$</p><h3 id="1-核心思想转变"><a href="#1-核心思想转变" class="headerlink" title="1. 核心思想转变"></a>1. 核心思想转变</h3><ul><li><p><strong>之前 (Weighted Sum)</strong>: 我们用全 <code>1</code> 的矩阵做平均，所有 token 对过去的关注度是一样的（平权的），这与内容无关。</p></li><li><p><strong>现在 (Self-Attention)</strong>: 我们希望 token 能够<strong>有选择性地</strong>关注过去。</p><ul><li><p><em>例子</em>：如果当前 token 是名词，它可能更想关注前面的形容词，而不是介词。</p></li><li><p><strong>数据驱动</strong>：权重矩阵 <code>wei</code> 不再是固定的，而是由数据（Token 自身的信息）动态计算出来的。</p></li></ul></li></ul><h3 id="2-Query-Key-Value"><a href="#2-Query-Key-Value" class="headerlink" title="2. Query, Key, Value"></a>2. Query, Key, Value</h3><p>这是注意力机制的灵魂，每个 Token 都会发出三个向量：</p><ul><li><p><strong>Query (Q) - 询问</strong>: “我在寻找什么样的信息？”</p></li><li><p><strong>Key (K) - 标签</strong>: “我包含什么样的信息？”</p></li><li><p><strong>Value (V) - 内容</strong>: “如果你决定关注我，这就是我要传给你的具体数值&#x2F;特征。”</p></li></ul><blockquote><p><strong>比喻</strong>：在图书馆找书。</p><ul><li><p><strong>Query</strong>: 你手里的便签写着“我要找关于 Python 的书”。</p></li><li><p><strong>Key</strong>: 书脊上贴的分类标签（“编程”、“烹饪”、“历史”）。</p></li><li><p><strong>Match</strong>: 你的 Query 和书的 Key 匹配度高（点积大），你就会把注意力放在这本书上。</p></li><li><p><strong>Value</strong>: 书里的具体内容。</p></li></ul></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h3><h4 id="A-线性投影"><a href="#A-线性投影" class="headerlink" title="A. 线性投影"></a>A. 线性投影</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义三个独立的线性层</span><br>key = nn.Linear(C, head_size, bias=<span class="hljs-literal">False</span>)<br>query = nn.Linear(C, head_size, bias=<span class="hljs-literal">False</span>)<br>value = nn.Linear(C, head_size, bias=<span class="hljs-literal">False</span>)<br><br><span class="hljs-comment"># 将输入 x 映射到不同的子空间</span><br>k = key(x)   <span class="hljs-comment"># (B, T, 16)</span><br>q = query(x) <span class="hljs-comment"># (B, T, 16)</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>目的</strong>：虽然输入都是 <code>x</code>，但为了扮演不同角色（Q, K, V），我们需要通过 <code>nn.Linear</code> 进行不同的线性变换（仿射变换）。</p></li><li><p><strong>head_size</strong>: 这里设为 16，意味着我们把原来的维度 $C$ 压缩或映射到了 16 维的特征空间里。</p></li></ul><h4 id="B-注意力分数和注意力归一化"><a href="#B-注意力分数和注意力归一化" class="headerlink" title="B. 注意力分数和注意力归一化"></a>B. 注意力分数和注意力归一化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 矩阵乘法计算 Q 和 K 的相似度</span><br>wei = q @ k.transpose(-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>) * head_size ** <span class="hljs-number">0.5</span><br><span class="hljs-comment"># (B, T, 16) @ (B, 16, T) ---&gt; (B, T, T)</span><br></code></pre></td></tr></table></figure><ul><li><p><strong><code>transpose(-2, -1)</code></strong>: 为了能做矩阵乘法，我们需要把 $K$ 的最后两个维度交换。</p></li><li><p><strong>物理意义</strong>:</p><ul><li><p>我们在计算序列中<strong>每一对 Token</strong> 之间的点积。</p></li><li><p>点积越大 $\rightarrow$ 向量越相似 $\rightarrow$ 关注度越高。</p></li><li><p>得到的 <code>wei</code> 矩阵形状是 $(T, T)$，其中 <code>wei[i, j]</code> 代表第 <code>i</code> 个 token 对第 <code>j</code> 个 token 的感兴趣程度（原始分数）。</p></li></ul></li><li><p><strong>注意力归一化(scaled attention)</strong></p><p>  假设 $Q$ 和 $K$ 中的元素是均值为 0、方差为 1 的独立随机变量。当我们计算点积 $Q \cdot K &#x3D; \sum_{i&#x3D;1}^{d_k} q_i k_i$ 时：</p><ul><li><p>求和会累加方差。</p></li><li><p>如果有 $d_k$ 个元素相加，结果的方差会变成 $d_k$。</p></li><li><p>这意味着，$d_k$ (head_size) 越大，点积结果 <code>wei</code> 里的数值就越大（比如可能出现 100, -200 这种大数）。<br>  为了把方差拉回1，需要除以标准差head_size**0.5。</p></li></ul></li></ul><h4 id="C-Masking-不能看未来"><a href="#C-Masking-不能看未来" class="headerlink" title="C. Masking (不能看未来)"></a>C. Masking (不能看未来)</h4><p>[[位置掩码]]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">tril = torch.tril(torch.ones(T, T))<br>wei = wei.masked_fill(tril == <span class="hljs-number">0</span>, <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>))<br></code></pre></td></tr></table></figure><ul><li><p>这步和之前一样。对于 Decoder (GPT) 架构，我们必须切断未来的联系。</p></li><li><p>将上三角区域填为负无穷，确保 Softmax 之后这些位置的概率为 0。</p></li></ul><h4 id="D-Softmax-归一化"><a href="#D-Softmax-归一化" class="headerlink" title="D. Softmax 归一化"></a>D. Softmax 归一化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python">wei = F.softmax(wei, dim=-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><ul><li><p>将原始的“相似度分数”转化为“概率分布”。</p></li><li><p>每一行的和变成了 1。现在的 <code>wei</code> 矩阵告诉我们在当前时刻，应该从历史的每个位置“提取”多少比例的信息。</p></li></ul><h4 id="E-聚合"><a href="#E-聚合" class="headerlink" title="E. 聚合"></a>E. 聚合</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">v = value(x)     <span class="hljs-comment"># (B, T, 16)</span><br>out = wei @ v * head_size**<span class="hljs-number">0.5</span>    <span class="hljs-comment"># (B, T, T) @ (B, T, 16) -&gt; (B, T, 16)</span><br></code></pre></td></tr></table></figure><ul><li>使用<code>wei @ v</code>而不是<code>wei @ x</code></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>transformer</tag>
      
      <tag>attention</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位置掩码</title>
    <link href="/2026/01/23/obsidian/transformer/%E4%BD%8D%E7%BD%AE%E6%8E%A9%E7%A0%81/"/>
    <url>/2026/01/23/obsidian/transformer/%E4%BD%8D%E7%BD%AE%E6%8E%A9%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>对于语言模型，我们需要在训练时赋予因果遮蔽，避免模型使用未来的token训练。所以对时间序列维度要进行位置掩码。</p><h2 id="串行做法"><a href="#串行做法" class="headerlink" title="串行做法"></a>串行做法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">xbow = torch.zeros((B, T, C))<br><br><span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(B):<br><br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(T):<br><br>        x_prev = x[b, :t + <span class="hljs-number">1</span>]<br><br>        xbow[b, t] = torch.mean(x_prev, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>这里是一个很简单的token交互，取平均值。可以看到在每个batch维度独立地对时间序列进行遮蔽。对于第t组数据（B, 1, C），我们只让他看到过去的0~t时刻的token内容，即<code>x[b, :t + 1]</code> 。</p><p>串行实现逻辑很简单，但是对于GPU不友好。我们可以引入一个数学技巧来处理时间遮蔽。</p><h2 id="矩阵做法"><a href="#矩阵做法" class="headerlink" title="矩阵做法"></a>矩阵做法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.manual_seed(<span class="hljs-number">1337</span>)<br><br>B, T, C = <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">32</span><br><br>x = torch.randn(B, T, C)<br><br>tril = torch.tril(torch.ones(T, T))<br><br>wei = wei.masked_fill(tril == <span class="hljs-number">0</span>, <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>))<br><br>wei = F.softmax(wei, dim=<span class="hljs-number">2</span>)<br><br>out = wei @ x<br></code></pre></td></tr></table></figure><p>使用下三角矩阵左乘x，广播机制会自动在batch维度上广播，所以先忽略batch维度。<br>wei的维度为(T, T)， x的维度为(T, C)。wei @ x会得到一个(T, C)的矩阵。如果wei是下三角的情况下，假设 $T&#x3D;3$，输入序列 $X$ 包含三个时刻的向量 $x_0, x_1, x_2$（每个向量维度为 $C$）：</p><h1 id="W-left-begin-array-ccc-1-0-0-0-5-0-5-0-0-33-0-33-0-33-end-array-right-W-X-left-begin-array-ccc-1-0-0-0-5-0-5-0-0-33-0-33-0-33-end-array-right-left-begin-array-c-x-0-x-1-x-2-end-array-right"><a href="#W-left-begin-array-ccc-1-0-0-0-5-0-5-0-0-33-0-33-0-33-end-array-right-W-X-left-begin-array-ccc-1-0-0-0-5-0-5-0-0-33-0-33-0-33-end-array-right-left-begin-array-c-x-0-x-1-x-2-end-array-right" class="headerlink" title="$$W &#x3D;\left[\begin{array}{ccc}1    &amp; 0    &amp; 0 \0.5  &amp; 0.5  &amp; 0 \0.33 &amp; 0.33 &amp; 0.33\end{array}\right]$$$$W X &#x3D;\left[\begin{array}{ccc}1    &amp; 0    &amp; 0 \0.5  &amp; 0.5  &amp; 0 \0.33 &amp; 0.33 &amp; 0.33\end{array}\right]\left[\begin{array}{c}x_0 \x_1 \x_2\end{array}\right]"></a>$$W &#x3D;<br>\left[<br>\begin{array}{ccc}<br>1    &amp; 0    &amp; 0 \<br>0.5  &amp; 0.5  &amp; 0 \<br>0.33 &amp; 0.33 &amp; 0.33<br>\end{array}<br>\right]$$<br>$$<br>W X &#x3D;<br>\left[<br>\begin{array}{ccc}<br>1    &amp; 0    &amp; 0 \<br>0.5  &amp; 0.5  &amp; 0 \<br>0.33 &amp; 0.33 &amp; 0.33<br>\end{array}<br>\right]<br>\left[<br>\begin{array}{c}<br>x_0 \<br>x_1 \<br>x_2<br>\end{array}<br>\right]</h1><p>\left[<br>\begin{array}{c}<br>1 \cdot x_0 \<br>0.5 \cdot x_0 + 0.5 \cdot x_1 \<br>0.33 \cdot x_0 + 0.33 \cdot x_1 + 0.33 \cdot x_2<br>\end{array}<br>\right]<br>$$<br>通过这种矩阵乘法，结果矩阵的第 $t$ 行，正是输入 $X$ 从第 0 行到第 $t$ 行的<strong>平均值</strong>。</p><p>值得注意的是，在某些场景下可能不需要进行因果遮蔽。比如语句的情感推断。在这种情况下需要全部上下文的信息进行推理。</p>]]></content>
    
    
    
    <tags>
      
      <tag>transformer</tag>
      
      <tag>masking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tokenizer</title>
    <link href="/2026/01/23/obsidian/transformer/Tokenizer/"/>
    <url>/2026/01/23/obsidian/transformer/Tokenizer/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是分词器-Tokenizer-？"><a href="#1-什么是分词器-Tokenizer-？" class="headerlink" title="1. 什么是分词器 (Tokenizer)？"></a>1. 什么是分词器 (Tokenizer)？</h2><p>模型无法直接理解人类的文本（字符串），它只能处理数字。分词器的作用就是将文本转换成模型可以理解的数字序列。</p><ul><li><p><strong>流程</strong>：输入文本 $\rightarrow$ 切分成 Token (词元) $\rightarrow$ 映射为 ID (索引数字) $\rightarrow$ 输入模型。</p></li><li><p><strong>Token 是什么</strong>：Token 可以是一个完整的单词（如 <code>is</code>），一个单词的一部分（如 <code>ization</code>），甚至是一个字符或空格。</p></li><li><p><strong>主流算法</strong>：GPT 系列主要使用的是 <strong>BPE (Byte Pair Encoding)</strong> 算法，旨在通过合并高频出现的字符组合来压缩文本，提高效率。</p></li></ul><hr><h2 id="2-截图场景解析与局限性-Limitations"><a href="#2-截图场景解析与局限性-Limitations" class="headerlink" title="2. 截图场景解析与局限性 (Limitations)"></a>2. 截图场景解析与局限性 (Limitations)</h2><p>截图中的不同色块代表了分词器将文本切分后的不同 Token。我们可以从图中展示的四个特定场景，分析 LLM 在分词层面遇到的“怪异现象”和限制：<br><img src="https://cdn.jsdelivr.net/gh/HRbenY/blog-assets@master//img/20260117145252696.png" alt="Pasted image 20251228171806">  </p><h3 id="场景一：算术与数字处理-Arithmetic"><a href="#场景一：算术与数字处理-Arithmetic" class="headerlink" title="场景一：算术与数字处理 (Arithmetic)"></a>场景一：算术与数字处理 (Arithmetic)</h3><blockquote><p>截图内容：127 + 677 &#x3D; 804</p><p>现象：数字通常不会被识别为一个整体，而是被切碎。</p></blockquote><ul><li><p><strong>局限性</strong>：<strong>破坏了数值的位值概念。</strong></p><ul><li><p>在 GPT-2（以及许多早期模型）的分词器中，数字往往被切分成不符合直觉的片段。例如，<code>1275</code> 可能被切分为 <code>12</code> 和 <code>75</code>，或者 <code>1</code>、<code>2</code>、<code>7</code>、<code>5</code>。</p></li><li><p><strong>后果</strong>：模型很难学会“进位”等数学逻辑，因为对它来说，这更像是文本拼接预测，而不是数值计算。这就是为什么 LLM 做加减法经常一本正经胡说八道的原因之一。</p></li><li><p><strong>改进</strong>：较新的模型（如 LLaMA 或 GPT-4）尝试将数字按每一位单独分词，以提高数学能力。</p></li></ul></li></ul><h3 id="场景二：大小写敏感-Case-Sensitivity"><a href="#场景二：大小写敏感-Case-Sensitivity" class="headerlink" title="场景二：大小写敏感 (Case Sensitivity)"></a>场景二：大小写敏感 (Case Sensitivity)</h3><blockquote><p>截图内容：Egg, I have an Egg, egg, EGG</p><p>现象：Egg (首字母大写)、egg (全小写)、EGG (全大写) 被赋予了不同的颜色，意味着它们是完全不同的 Token。</p></blockquote><ul><li><p><strong>局限性</strong>：<strong>词表浪费与语义分散。</strong></p><ul><li><p>虽然这三个词语义相同，但在模型眼里它们是三个完全不同的 ID。模型必须分别学习这三个 Token 的含义。</p></li><li><p><strong>后果</strong>：这浪费了宝贵的词表空间（Vocabulary Size），并且如果某个变体（如全大写 <code>EGG</code>）在训练数据中出现很少，模型对它的理解就会比 <code>egg</code> 差。</p></li></ul></li></ul><h3 id="场景三：非英语-多语言支持-Non-English-Multilingual"><a href="#场景三：非英语-多语言支持-Non-English-Multilingual" class="headerlink" title="场景三：非英语&#x2F;多语言支持 (Non-English &#x2F; Multilingual)"></a>场景三：非英语&#x2F;多语言支持 (Non-English &#x2F; Multilingual)</h3><blockquote><p>截图内容：韩语段落 만나서 반갑습니다…</p><p>现象：韩语文本的色块非常细碎，几乎每个字甚至每个字的部件都被切成了不同的 Token。</p></blockquote><ul><li><p><strong>局限性</strong>：<strong>信息密度低，上下文窗口利用率差。</strong></p><ul><li><p>GPT-2 的词表主要是针对英语优化的。对于韩语、中文等非拉丁语系，分词器往往找不到对应的“整词”，只能回退到按字节或字符切分。</p></li><li><p><strong>后果</strong>：</p><ol><li><p><strong>更贵</strong>：同样的句子，中文或韩语消耗的 Token 数量远多于英语（在 GPT-2&#x2F;3 时代尤其明显），调用 API 时成本更高。</p></li><li><p><strong>更“短”</strong>：因为 Token 数量多，同样的上下文窗口（Context Window）能容纳的非英语内容就变少了。</p></li></ol></li></ul></li></ul><h3 id="场景四：代码与格式-Code-Formatting"><a href="#场景四：代码与格式-Code-Formatting" class="headerlink" title="场景四：代码与格式 (Code &amp; Formatting)"></a>场景四：代码与格式 (Code &amp; Formatting)</h3><blockquote><p>截图内容：Python 代码 for i in range(1, 101):</p><p>现象：缩进（空格）、关键词（for, in）、标点符号都被切分。</p></blockquote><ul><li><p><strong>局限性</strong>：<strong>对格式极其敏感。</strong></p><ul><li><p>Python 强依赖缩进。如果分词器将 (4个空格) 识别为一个 Token，而将 (2个空格) 识别为另一个，模型就需要精确预测使用哪个 Token 来保证代码运行。</p></li><li><p>像 <code>FizzBuzz</code> 这样的变量名，因为不是通用单词，会被拆解为 <code>Fizz</code> + <code>Buzz</code>。如果代码中有很多生僻变量名，会显著增加 Token 消耗。</p></li></ul></li></ul><h3 id="对比分析：GPT-2-gpt2-vs-GPT-4-cl100k-base"><a href="#对比分析：GPT-2-gpt2-vs-GPT-4-cl100k-base" class="headerlink" title="对比分析：GPT-2 (gpt2) vs GPT-4 (cl100k_base)"></a>对比分析：GPT-2 (<code>gpt2</code>) vs GPT-4 (<code>cl100k_base</code>)</h3><p>OpenAI 的模型经历了从 <code>gpt2</code> (用于 GPT-2 和 GPT-3) 到 <code>cl100k_base</code> (用于 GPT-3.5-Turbo 和 GPT-4) 的升级。这次分词器的升级对性能和成本有直接影响。<br><img src="https://cdn.jsdelivr.net/gh/HRbenY/blog-assets@master//img/20260117145252697.png" alt="Pasted image 20251228172350"></p><table><thead><tr><th><strong>特性</strong></th><th><strong>GPT-2 Tokenizer (gpt2 &#x2F; r50k_base)</strong></th><th><strong>GPT-4 Tokenizer (cl100k_base)</strong></th></tr></thead><tbody><tr><td><strong>词表大小</strong></td><td><strong>约 50,000 个</strong></td><td><strong>约 100,000 个</strong></td></tr><tr><td><strong>中文支持</strong></td><td><strong>较差</strong>。一个汉字通常被切分为 2-3 个 Token（甚至更多字节级碎片）。</td><td><strong>优秀</strong>。词表更大，包含了更多常用汉字。许多常见汉字现在是一个单独的 Token。</td></tr><tr><td><strong>代码处理</strong></td><td><strong>一般</strong>。对空格、缩进和常见代码关键字的优化不足。</td><td><strong>大幅优化</strong>。针对代码中的常见模式（如连续空格、特定函数名）进行了专门优化，压缩率更高。</td></tr><tr><td><strong>压缩效率</strong></td><td>较低。同样的文本需要更多的 Token 来表示。</td><td><strong>较高</strong>。同样的文本，Token 数量平均减少 <strong>15% - 20%</strong>（英文），中文减少幅度更大。</td></tr><tr><td><strong>数字处理</strong></td><td>经常将数字切碎且不规律（如 <code>1275</code> -&gt; <code>12</code>, <code>75</code>）。</td><td>稍微一致一些，但依然不是完美的按位切分（这主要还是 BPE 的通病）。</td></tr></tbody></table><h3 id="核心差异总结："><a href="#核心差异总结：" class="headerlink" title="核心差异总结："></a>核心差异总结：</h3><ol><li><p><strong>省钱 &amp; 扩容</strong>：<code>cl100k_base</code> 最直接的好处是<strong>更省 Token</strong>。因为它的词表更大（100k），它能“一口吃下”更复杂的词，而不需要切得那么碎。这意味着对于同样的 prompt，使用 GPT-4 往往比 GPT-3 花费的 Token 更少，且能塞进上下文窗口的内容更多。</p></li><li><p><strong>多语言与代码能力增强</strong>：由于在训练分词器时加入了更多代码和多语言语料，<code>cl100k_base</code> 不再像 GPT-2 那样“歧视”非英语内容，这对中文开发者和程序员非常友好。</p></li></ol><h2 id="3-主流的分词器类型-Tokenizer-Types"><a href="#3-主流的分词器类型-Tokenizer-Types" class="headerlink" title="3. 主流的分词器类型 (Tokenizer Types)"></a>3. 主流的分词器类型 (Tokenizer Types)</h2><p>虽然目前 GPT 系列主要使用 BPE，但在 NLP 领域主要有三种主流的分词算法，它们的核心目标都是<strong>平衡词表大小（Vocabulary Size）与文本覆盖率</strong>，尽量避免出现“未知词（[UNK]）”。</p><h3 id="3-1-BPE-Byte-Pair-Encoding"><a href="#3-1-BPE-Byte-Pair-Encoding" class="headerlink" title="3.1 BPE (Byte Pair Encoding)"></a>3.1 BPE (Byte Pair Encoding)</h3><ul><li><p><strong>代表模型</strong>：<strong>GPT 系列 (GPT-2, GPT-3, GPT-4)</strong>, RoBERTa, LLaMA。</p></li><li><p><strong>原理</strong>：统计语料中字符组合出现的频率。从单个字符开始，不断<strong>合并出现频率最高</strong>的相邻字符对，直到词表达到预设大小。</p></li><li><p><strong>特点</strong>：</p><ul><li><p>能很好地处理生僻词（通过拆解为子词）。</p></li><li><p>GPT 使用的是 <strong>Byte-level BPE</strong>（基于字节而非字符），这意味着它可以处理任何 Unicode 字符串（包括 emoji 和各种奇怪符号），不会出现 [UNK]。</p></li></ul></li></ul><h3 id="3-2-WordPiece"><a href="#3-2-WordPiece" class="headerlink" title="3.2 WordPiece"></a>3.2 WordPiece</h3><ul><li><p><strong>代表模型</strong>：<strong>BERT</strong>, DistilBERT。</p></li><li><p><strong>原理</strong>：与 BPE 类似，也是合并子词。但它在选择合并哪两个子词时，不是看频率最高，而是看<strong>合并后能最大程度增加训练数据语言模型的似然概率 (Likelihood)</strong>。</p></li><li><p><strong>特点</strong>：通常比 BPE 稍微紧凑一些，但计算量稍大。</p></li></ul><h3 id="3-3-Unigram-Language-Model"><a href="#3-3-Unigram-Language-Model" class="headerlink" title="3.3 Unigram Language Model"></a>3.3 Unigram Language Model</h3><ul><li><p><strong>代表模型</strong>：<strong>T5</strong>, ALBERT, XLNet (使用 SentencePiece 库)。</p></li><li><p><strong>原理</strong>：思路与 BPE 相反。BPE 是“从下往上”合并，Unigram 是“从上往下”剪枝。它先初始化一个巨大的词表，然后计算丢弃某些词对整体损失函数的影响，<strong>保留概率最高</strong>的子词，剔除贡献小的，直到达到预设词表大小。</p></li><li><p><strong>特点</strong>：它是基于概率的模型，对于同一个句子可以产生多种分词可能（Subword Regularization），这在训练时有时能增加模型的鲁棒性。</p></li></ul><hr><h2 id="4-相关资料"><a href="#4-相关资料" class="headerlink" title="4 相关资料"></a>4 相关资料</h2><p><a href="https://www.reedbeta.com/blog/programmers-intro-to-unicode/">Programmer’s intro to unicode</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>transformer</tag>
      
      <tag>tokenizer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线段树</title>
    <link href="/2026/01/23/obsidian/cpp/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2026/01/23/obsidian/cpp/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h2><p>线段树是一种基于<strong>分治思想</strong>的二叉树结构，主要用于解决数组的<strong>区间查询</strong>和<strong>单点&#x2F;区间修改</strong>问题。</p><ul><li><p><strong>本质</strong>：将数组不断二分，每一个节点代表一个区间 <code>[start, end]</code>。</p></li><li><p><strong>时间复杂度</strong>：</p><ul><li><p>建树 (Build): $O(N)$</p></li><li><p>单点修改 (Update): $O(\log N)$</p></li><li><p>区间查询 (Query): $O(\log N)$</p></li></ul></li><li><p><strong>空间复杂度</strong>：$O(4N)$ (需要开 4 倍数组空间以防越界)。</p></li></ul><h2 id="2-存储方式-数组模拟"><a href="#2-存储方式-数组模拟" class="headerlink" title="2. 存储方式 (数组模拟)"></a>2. 存储方式 (数组模拟)</h2><p>通常不使用指针建树，而是使用数组模拟堆结构。</p><p>假设根节点下标为 1 (根节点不能是0，否则乘法计算子节点会出错)：</p><ul><li><p><strong>父节点</strong>：<code>node</code></p></li><li><p><strong>左孩子</strong>：<code>2 * node</code> (或 <code>node &lt;&lt; 1</code>)</p></li><li><p><strong>右孩子</strong>：<code>2 * node + 1</code> (或 <code>node &lt;&lt; 1 | 1</code>)</p></li><li><p><strong>中点</strong>：<code>mid = start + (end - start) / 2</code></p></li></ul><h2 id="3-核心操作模板"><a href="#3-核心操作模板" class="headerlink" title="3. 核心操作模板"></a>3. 核心操作模板</h2><h3 id="3-1-节点定义-Node-Struct"><a href="#3-1-节点定义-Node-Struct" class="headerlink" title="3.1 节点定义 (Node Struct)"></a>3.1 节点定义 (Node Struct)</h3><p>对于简单求和，只存 <code>val</code> 即可。对于复杂题 (如 LC 3165)，需要维护状态机。</p><p>C++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> val; <br>    <span class="hljs-comment">// LC 3165 特例：维护 l00, l01, l10, l11 四个状态</span><br>&#125;;<br>vector&lt;Node&gt; tree;<br></code></pre></td></tr></table></figure><h3 id="3-2-向上合并-PushUp-最重要的函数"><a href="#3-2-向上合并-PushUp-最重要的函数" class="headerlink" title="3.2 向上合并 (PushUp) - 最重要的函数"></a>3.2 向上合并 (PushUp) - <strong>最重要的函数</strong></h3><p>线段树的灵魂。决定了父节点如何通过两个子节点计算出自己的值。</p><ul><li><p><strong>求和</strong>：<code>tree[node] = left + right</code></p></li><li><p><strong>最大值</strong>：<code>tree[node] = max(left, right)</code></p></li><li><p><strong>复杂合并 (LC 3165)</strong>：也就是 DP 的状态转移过程。</p></li></ul><p>C++</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">Node</span> <span class="hljs-title">pushUp</span>(const <span class="hljs-keyword">Node</span><span class="hljs-title">&amp; l</span>, const <span class="hljs-keyword">Node</span><span class="hljs-title">&amp; r</span>) &#123;<br>    <span class="hljs-keyword">Node</span> <span class="hljs-title">res</span>;<br>    // 逻辑：父区间的状态 = max(左子区间组合 + 右子区间组合)<br>    // 关键点：注意连接处是否冲突<br>    return res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-建树-Build"><a href="#3-3-建树-Build" class="headerlink" title="3.3 建树 (Build)"></a>3.3 建树 (Build)</h3><p>自底向上构建。递归到叶子节点初始化，然后回溯 <code>pushUp</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (start == end) &#123;<br><span class="hljs-built_in">max</span>(<span class="hljs-number">0LL</span>, (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)nums[start])<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = start + (end - start) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">build</span>(node * <span class="hljs-number">2</span>, start, mid, nums);<br>    <span class="hljs-built_in">build</span>(node * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, end, nums);<br>    tree[node] = <span class="hljs-built_in">pushUp</span>(tree[node * <span class="hljs-number">2</span>], tree[node * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-单点更新-Update"><a href="#3-4-单点更新-Update" class="headerlink" title="3.4 单点更新 (Update)"></a>3.4 单点更新 (Update)</h3><p>类似二分查找，找到目标叶子并修改，<strong>回溯时刷新路径上的所有父节点</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> idx)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(start == end)&#123;<br>            tree[node].l11 = <span class="hljs-built_in">max</span>(nums[idx], <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> mid = start + (end - start) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(idx &lt;= mid)&#123;<br>            <span class="hljs-built_in">update</span>(node * <span class="hljs-number">2</span>, nums, start, mid, idx);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">update</span>(node * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, nums, mid + <span class="hljs-number">1</span>, end, idx);<br>        &#125;<br>        tree[node] = <span class="hljs-built_in">pushUp</span>(tree[node * <span class="hljs-number">2</span>], tree[node * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]);<br>    &#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-实战避坑指南-Lessons-Learned-from-LC-3165"><a href="#4-实战避坑指南-Lessons-Learned-from-LC-3165" class="headerlink" title="4. 实战避坑指南 (Lessons Learned from LC 3165)"></a>4. 实战避坑指南 (Lessons Learned from LC 3165)</h2><p>细节：</p><ol><li><p><strong>数据类型陷阱</strong>：</p><ul><li><p>❌ <strong>错误</strong>：<code>unsigned int</code>。一旦遇到负数，强转 <code>unsigned</code> 会变成巨大正数，导致结果错误。</p></li><li><p>✅ <strong>正确</strong>：统一使用 <code>long long</code>。既能处理负数，又能防止累加溢出。</p></li></ul></li><li><p><strong>返回结果</strong>：</p><ul><li><p>树根通常存储在 <code>tree[1]</code>，不要去读 <code>tree[0]</code>。</p></li><li><p>如果有取模需求，注意累加过程中每一步都要防止溢出。</p></li></ul></li><li><p><strong>数组大小</strong>：</p><ul><li>线段树数组必须开 <code>4 * N</code> 大小。</li></ul></li></ol><hr><h2 id="5-经典题目清单"><a href="#5-经典题目清单" class="headerlink" title="5. 经典题目清单"></a>5. 经典题目清单</h2><p>建议按顺序练习，巩固模板：</p><ol><li><p><strong>基础模板题</strong>：</p><ul><li><a href="https://leetcode.cn/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改</a> (单点修改 + 区间求和)</li></ul></li><li><p><strong>进阶应用 (维护最大值)</strong>：</p><ul><li><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a> (虽然是 DP 题，但可以用线段树做，维护 <code>maxSub</code>, <code>lMax</code>, <code>rMax</code>, <code>sum</code>)</li></ul></li><li><p><strong>复杂状态合并 (Hard)</strong>：</p><ul><li><p><a href="https://leetcode.cn/problems/maximum-sum-of-subsequence-with-non-adjacent-elements/">3165. 不包含相邻元素的子序列的最大和</a> (即本题)</p></li><li><p><a href="https://leetcode.cn/problems/longest-substring-of-one-repeating-character/">2213. 由单个字符重复的最长子字符串</a> (维护字符前缀、后缀、最长连续长度)</p></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>segment-tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编辑距离</title>
    <link href="/2026/01/23/obsidian/cpp/%E7%AE%97%E6%B3%95/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <url>/2026/01/23/obsidian/cpp/%E7%AE%97%E6%B3%95/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="标准编辑距离"><a href="#标准编辑距离" class="headerlink" title="标准编辑距离"></a>标准编辑距离</h2><p>标准编辑距离不限制中间态。使用动态规划，<code>dp[i][j]</code>表示字符串1的前i前缀和字符串2的前j前缀的编辑距离。那么可以跟<code>dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]</code>形成递推关系。如下：</p><ul><li>如果两个字符串的前缀的最后一个字母相同，那么退化成<code>dp[i - 1][j - 1]</code>的编辑距离。</li><li>否则，可以是字符串1删减一个<code>dp[i - 1][j]</code>；字符串2删减一个<code>dp[i][j - 1]</code>；或者进行一次修改让两字符串后缀相同，然后退化成<code>dp[i - 1][j - 1]</code>。取这三种情况的最小值，然后加上这次编辑新增的编辑距离（+1）。</li></ul><p>需要初始化i、j为0的边界情况，根据定义<code>dp[0][j]</code>表示的意思是字符串2的前j前缀和零长度字符串的编辑距离，当然是j。同理对<code>dp[i][0]</code>初始化。</p><ul><li>注意，要事先将dp数组初始化成<code>vector&lt;vector&lt;int&gt;&gt; dp(string1.size() + 1, vector&lt;int&gt;(string2).size() + 1, 0)</code>,多初始化一行列。</li></ul><p>更难的是编辑距离的变种，限制中间态的情况。如<a href="https://leetcode.cn/problems/word-ladder/description/">lc127</a>、<a href="https://leetcode.cn/problems/word-ladder-ii/description/">lc126</a>。</p><h2 id="变种"><a href="#变种" class="headerlink" title="变种"></a>变种</h2><h3 id="0-两题本质差异（决定写法差异）"><a href="#0-两题本质差异（决定写法差异）" class="headerlink" title="0. 两题本质差异（决定写法差异）"></a>0. 两题本质差异（决定写法差异）</h3><ul><li><p><strong>127（Word Ladder）</strong>：只要最短长度<br>  → BFS 访问到一个单词 <strong>第一次</strong> 就是最短，后续再到达没有意义<br>  → “访问即删除&#x2F;visited&#x3D;true” 是最优策略</p></li><li><p><strong>126（Word Ladder II）</strong>：要输出<strong>所有</strong>最短路径<br>  → 同一个单词在最短层级可能有<strong>多个父节点</strong><br>  → 不能“访问即删除”，否则会丢掉其它最短路径分支<br>  → 必须 <strong>BFS 建 parent 图 + DFS 回溯输出</strong></p></li></ul><hr><h3 id="1-我在-127-的核心困惑点复盘"><a href="#1-我在-127-的核心困惑点复盘" class="headerlink" title="1. 我在 127 的核心困惑点复盘"></a>1. 我在 127 的核心困惑点复盘</h3><h4 id="Q1：是不是层序遍历？"><a href="#Q1：是不是层序遍历？" class="headerlink" title="Q1：是不是层序遍历？"></a>Q1：是不是层序遍历？</h4><ul><li><p>✅ 是，本质就是 <strong>隐式图的层序遍历</strong></p></li><li><p>每层代表“改变了几次字符”</p></li><li><p><code>step</code> 就是 BFS 层数（包含 begin&#x2F;end）</p></li></ul><h4 id="Q2：为什么可以从-set-map-里删掉遍历过的单词？"><a href="#Q2：为什么可以从-set-map-里删掉遍历过的单词？" class="headerlink" title="Q2：为什么可以从 set&#x2F;map 里删掉遍历过的单词？"></a>Q2：为什么可以从 set&#x2F;map 里删掉遍历过的单词？</h4><ul><li>✅ 因为 127 只求最短长度：<br>  BFS 第一次到达节点 &#x3D; 最短距离确定<br>  再次到达只会更长，所以删掉等价于 <code>visited</code></li></ul><h4 id="我最终记住的-127-模板"><a href="#我最终记住的-127-模板" class="headerlink" title="我最终记住的 127 模板"></a>我最终记住的 127 模板</h4><ul><li><p><code>unordered_set dict</code> 存词典</p></li><li><p><code>queue</code> BFS</p></li><li><p>生成邻居：枚举位置 * 26 字母</p></li><li><p><strong>入队就 erase</strong>，避免重复入队&#x2F;爆队列</p></li></ul><hr><h3 id="2-我在-126-的关键疑惑点复盘"><a href="#2-我在-126-的关键疑惑点复盘" class="headerlink" title="2. 我在 126 的关键疑惑点复盘"></a>2. 我在 126 的关键疑惑点复盘</h3><h4 id="Q1：126-能不能用邻接表？为什么-127-你说“不需要”？"><a href="#Q1：126-能不能用邻接表？为什么-127-你说“不需要”？" class="headerlink" title="Q1：126 能不能用邻接表？为什么 127 你说“不需要”？"></a>Q1：126 能不能用邻接表？为什么 127 你说“不需要”？</h4><ul><li><p>✅ 126 必须保存结构（边）才能输出路径：<br>  不是“能不能”，而是“<strong>必须</strong>”</p></li><li><p>127 的邻接关系是一次性的（生成即用），存图浪费；<br>  126 的邻接关系是答案的一部分（要回溯），必须存。</p></li></ul><h4 id="Q2：为什么-126-必须存-child-parents（反向邻接表），而不是-parent-children？"><a href="#Q2：为什么-126-必须存-child-parents（反向邻接表），而不是-parent-children？" class="headerlink" title="Q2：为什么 126 必须存 child -&gt; parents（反向邻接表），而不是 parent -&gt; children？"></a>Q2：为什么 126 必须存 <code>child -&gt; parents</code>（反向邻接表），而不是 <code>parent -&gt; children</code>？</h4><ul><li><p>✅ 因为 DFS 回溯从 <code>endWord</code> 开始最自然</p></li><li><p>存 <code>child -&gt; parents</code> 可以直接从终点一路回到起点</p></li><li><p>正向也能做，但会额外复杂（要记录层级&#x2F;剪枝&#x2F;保证最短）</p></li></ul><hr><h3 id="3-126-写代码时我踩过的典型坑（按出现顺序）"><a href="#3-126-写代码时我踩过的典型坑（按出现顺序）" class="headerlink" title="3. 126 写代码时我踩过的典型坑（按出现顺序）"></a>3. 126 写代码时我踩过的典型坑（按出现顺序）</h3><h4 id="错误-1：试图像-127-一样“边-BFS-边存路径”"><a href="#错误-1：试图像-127-一样“边-BFS-边存路径”" class="headerlink" title="错误 1：试图像 127 一样“边 BFS 边存路径”"></a>错误 1：试图像 127 一样“边 BFS 边存路径”</h4><p><strong>表现：</strong></p><ul><li><p>用 <code>vector&lt;vector&lt;string&gt;&gt; path</code> &#x2F; <code>p.push_back(word)</code> 之类存“每层”或“路径”</p></li><li><p>发现 <code>p.push_back(word)</code> 会重复（同一个 word 被 push 多次）</p></li></ul><p><strong>原因本质：</strong></p><ul><li><p>126 需要的是 <strong>多父节点关系</strong>，不是“层列表”</p></li><li><p>“层”不等于“路径结构”</p></li><li><p>你那种存法无法表达：同一 child 来自多个 parent</p></li></ul><p><strong>正确做法：</strong></p><ul><li><p>BFS 只做一件事：建立 <code>parent[child].push_back(parent)</code></p></li><li><p>BFS 完成后 DFS 回溯输出路径</p></li></ul><hr><h4 id="错误-2：不立刻-erase-时，队列会不会-push-重复单词？"><a href="#错误-2：不立刻-erase-时，队列会不会-push-重复单词？" class="headerlink" title="错误 2：不立刻 erase 时，队列会不会 push 重复单词？"></a>错误 2：不立刻 erase 时，队列会不会 push 重复单词？</h4><p><strong>表现：</strong></p><ul><li>担心一层里多个父节点生成同一个 next，会重复入队</li></ul><p><strong>正确策略（两套 visited）：</strong></p><ul><li><p><code>visited_level</code>：本层去重（避免重复入队）</p></li><li><p><code>dict/uset</code>：跨层去重（层末统一 erase）</p></li></ul><p><strong>结论：</strong></p><ul><li><p><strong>同层：允许多父，但队列只入一次</strong></p></li><li><p><code>parent[next]</code> 可能加很多次（多父），<code>queue</code> 只 push 一次（去重）</p></li></ul><hr><h4 id="错误-3：visited-level-只-clear-不-erase"><a href="#错误-3：visited-level-只-clear-不-erase" class="headerlink" title="错误 3：visited_level 只 clear 不 erase"></a>错误 3：visited_level 只 clear 不 erase</h4><p><strong>表现：</strong></p><ul><li><p>层末只有 <code>visited_level.clear()</code></p></li><li><p>没有 <code>uset.erase(x)</code><br>  → 会导致下一层还能再次访问这些词，污染 parent 图，甚至爆搜索</p></li></ul><p><strong>正确做法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;w : visited_level) dict.<span class="hljs-built_in">erase</span>(w);<br>visited_level.<span class="hljs-built_in">clear</span>();<br></code></pre></td></tr></table></figure><hr><h4 id="错误-4：DFS-起点-方向错、空-path-调用-front-back"><a href="#错误-4：DFS-起点-方向错、空-path-调用-front-back" class="headerlink" title="错误 4：DFS 起点&#x2F;方向错、空 path 调用 front&#x2F;back"></a>错误 4：DFS 起点&#x2F;方向错、空 path 调用 front&#x2F;back</h4><p><strong>表现：</strong></p><ul><li><p><code>dfs(path, ...)</code> 时 <code>path</code> 为空</p></li><li><p><code>path.front()</code> &#x2F; <code>path.back()</code> 直接 UB</p></li><li><p>或从 <code>beginWord</code> 开始 DFS，但 parent 图是反向的</p></li></ul><p><strong>正确做法：</strong></p><ul><li>DFS 从 <code>endWord</code> 开始：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">path.<span class="hljs-built_in">push_back</span>(endWord);<br><span class="hljs-built_in">dfs</span>(...);<br></code></pre></td></tr></table></figure><ul><li>终止条件是到达 <code>beginWord</code></li></ul><hr><h4 id="错误-5：输出路径方向反了"><a href="#错误-5：输出路径方向反了" class="headerlink" title="错误 5：输出路径方向反了"></a>错误 5：输出路径方向反了</h4><p><strong>表现：</strong></p><ul><li><p>DFS 构造的 path 是 <code>[end ... begin]</code></p></li><li><p>直接 <code>res.push_back(path)</code> 结果方向不对</p></li></ul><p><strong>正确做法：</strong></p><ul><li>终止时反转：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;string&gt; tmp = path;<br><span class="hljs-built_in">reverse</span>(tmp.<span class="hljs-built_in">begin</span>(), tmp.<span class="hljs-built_in">end</span>());<br>res.<span class="hljs-built_in">push_back</span>(tmp);<br></code></pre></td></tr></table></figure><hr><h4 id="错误-6：BFS-中没有跳过-“替换成原字符”"><a href="#错误-6：BFS-中没有跳过-“替换成原字符”" class="headerlink" title="错误 6：BFS 中没有跳过 “替换成原字符”"></a>错误 6：BFS 中没有跳过 “替换成原字符”</h4><p><strong>表现：</strong></p><ul><li><p>生成邻居时可能得到 <code>w == word</code></p></li><li><p>这会造成把自己当邻居，影响 visited&#x2F;parent</p></li></ul><p><strong>正确做法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (c == old) <span class="hljs-keyword">continue</span>;<br></code></pre></td></tr></table></figure><hr><h3 id="4-我最终-AC-的-126-标准范式（可当模板背下来）"><a href="#4-我最终-AC-的-126-标准范式（可当模板背下来）" class="headerlink" title="4. 我最终 AC 的 126 标准范式（可当模板背下来）"></a>4. 我最终 AC 的 126 标准范式（可当模板背下来）</h3><h3 id="阶段-A：BFS（只建-parent-图）"><a href="#阶段-A：BFS（只建-parent-图）" class="headerlink" title="阶段 A：BFS（只建 parent 图）"></a>阶段 A：BFS（只建 parent 图）</h3><ul><li><p>输入：begin, end, dict</p></li><li><p>输出：<code>parent</code> + 是否 found（最短层到达 end）</p></li></ul><p>关键点：</p><ol><li><p>每轮 while 是一层</p></li><li><p><code>visited_level</code> 记录本层入队过的 next</p></li><li><p><code>parent[next].push_back(cur)</code> 不去重（允许多个父）</p></li><li><p>一旦 found，<strong>当前层仍要跑完</strong>，但不再进入下一层</p></li></ol><h3 id="阶段-B：DFS-回溯（枚举所有最短路径）"><a href="#阶段-B：DFS-回溯（枚举所有最短路径）" class="headerlink" title="阶段 B：DFS 回溯（枚举所有最短路径）"></a>阶段 B：DFS 回溯（枚举所有最短路径）</h3><ul><li><p>从 <code>endWord</code> 递归走 <code>parent[end]</code></p></li><li><p>走到 <code>beginWord</code> 时反转入答案</p></li></ul><hr><h2 id="5-一句话记忆法"><a href="#5-一句话记忆法" class="headerlink" title="5. 一句话记忆法"></a>5. 一句话记忆法</h2><ul><li><p><strong>127：BFS 最短距离，入队即 visited（erase）</strong></p></li><li><p><strong>126：BFS 建 parent（多父），层末 erase；DFS 从 end 回溯输出</strong></p></li></ul><hr><h2 id="6-我个人最容易再犯的点（自查清单）"><a href="#6-我个人最容易再犯的点（自查清单）" class="headerlink" title="6. 我个人最容易再犯的点（自查清单）"></a>6. 我个人最容易再犯的点（自查清单）</h2><ul><li><p>BFS 队列是否 push 了 beginWord？</p></li><li><p>126 是否使用 <code>visited_level</code>（同层去重）？</p></li><li><p>126 是否层末 <code>erase(visited_level)</code>？</p></li><li><p>parent 的方向是否是 <code>child -&gt; parents</code>？</p></li><li><p>DFS 是否从 endWord 开始？</p></li><li><p>到 beginWord 时是否 reverse 后加入 res？</p></li><li><p>替换字符时是否跳过原字符？</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>edit-distance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程编程</title>
    <link href="/2026/01/23/obsidian/cpp/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <url>/2026/01/23/obsidian/cpp/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="创建一个线程"><a href="#创建一个线程" class="headerlink" title="创建一个线程"></a>创建一个线程</h2><p>使用C++11引入的thread头文件创建线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_fun</span><span class="hljs-params">(<span class="hljs-type">int</span> repeat, <span class="hljs-type">int</span> threadId)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(repeat --)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;thread-&quot;</span> &lt;&lt; threadId &lt;&lt; endl;<br>    &#125;<br>&#125;<span class="hljs-comment">//注意要先声明线程执行的函数</span><br><br><span class="hljs-function">thread <span class="hljs-title">myThread0</span><span class="hljs-params">(thread_fun, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>传参方式如代码中所示，<code>myThread0(thread_fun, 5, 0)</code>而不是<code>myThread0(thread_fun(5, 0))</code></p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>假如我们声明了两个线程，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">thread <span class="hljs-title">myThread0</span><span class="hljs-params">(thread_fun, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function">thread <span class="hljs-title">myThread1</span><span class="hljs-params">(thread_fun, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;我是主线程，我也在跑！&quot;</span> &lt;&lt; endl;<br>myThread<span class="hljs-number">0.</span><span class="hljs-built_in">join</span>();<br>myThread<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br></code></pre></td></tr></table></figure><p>由于调用的<code>cout</code>是一个共享资源，主线程和两个子线程都往里塞字，多线程的输出会出现穿插现象。如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt">我是主线程，我也在跑！<br>thread-thread-0<br>thread-0<br>thread-0<br>thread-0<br>thread-0<br>1<br>thread-1<br>thread-1<br>thread-1<br>thread-1<br></code></pre></td></tr></table></figure><p>虽然 <code>cout</code> 本身是线程安全的（不会崩溃），但 <code>&lt;&lt;</code> 操作符是分步执行的。<code>cout &lt;&lt; &quot;thread-&quot; &lt;&lt; threadId &lt;&lt; endl;</code> 实际上被拆成了三次操作：输出字符串、输出ID、输出换行。线程A刚输出完 “thread-“，还没来得及输出 ID，就被线程B插队了。</p><p>要避免线程冲突（这也是多线程编程中最重要的议题），我们需要引入互斥锁Mutex。</p><p>具体的流程是定义一个全局互斥锁，再在线程函数中定义一个<code>lock_guard</code>管理互斥锁。<code>lock_guard</code>作用范围用大括号括起来，便于自动析构释放资源。</p><blockquote><p>[!note]<br><code>lock_guard</code>是为了替代手动<code>lock()</code>和<code>unlock()</code>。手动操作如果在解锁之前程序抛出异常，或者提前return，则线程占用的资源将永远无法解锁，后续的线程都会卡住，造成<strong>死锁</strong>现象</p></blockquote><p>使用互斥锁后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">mutex mtx;<span class="hljs-comment">//定义全局线程锁</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_fun</span><span class="hljs-params">(<span class="hljs-type">int</span> repeat, <span class="hljs-type">int</span> threadId)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(repeat --)&#123;<br>        <span class="hljs-function">lock_guard&lt;mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(mtx)</span></span>;<span class="hljs-comment">//定义lock_guard管理线程锁</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;thread-&quot;</span> &lt;&lt; threadId &lt;&lt; endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">thread <span class="hljs-title">myThread0</span><span class="hljs-params">(thread_fun, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-function">thread <span class="hljs-title">myThread1</span><span class="hljs-params">(thread_fun, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>)</span></span>;<br>    &#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(mtx)</span></span>;<span class="hljs-comment">//定义lock_guard管理线程</span><br>       <span class="hljs-comment">//锁，并使用大括号限定作用</span><br>       <span class="hljs-comment">//域便于自动析构</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;我是主线程，我也在跑！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    myThread<span class="hljs-number">0.</span><span class="hljs-built_in">join</span>();<br>    myThread<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="lock-guard和unique-guard"><a href="#lock-guard和unique-guard" class="headerlink" title="lock_guard和unique_guard"></a><code>lock_guard</code>和<code>unique_guard</code></h2><p>在上一节配合互斥锁我们使用了lock_guard，这是一个互斥锁管理器。但是lock_guard有一些缺点，如下：</p><table><thead><tr><th><strong>特性</strong></th><th><strong>std::lock_guard</strong></th><th><strong>std::unique_lock</strong></th></tr></thead><tbody><tr><td><strong>速度</strong></td><td>极快（零开销）</td><td>微慢（内部有个标志位）</td></tr><tr><td><strong>RAII</strong></td><td>支持（出生锁，死亡解）</td><td>支持</td></tr><tr><td><strong>手动 Lock&#x2F;Unlock</strong></td><td>❌ 不行</td><td>✅ 可以</td></tr><tr><td><strong>中途想歇会</strong></td><td>❌ 必须锁到底</td><td>✅ 可以暂时 unlock</td></tr><tr><td><strong>Try Lock (非阻塞)</strong></td><td>❌ 只能死等</td><td>✅ 可以尝试锁</td></tr><tr><td><strong>条件变量 (Wait)</strong></td><td>❌ 无法配合</td><td>✅ <strong>必须用它</strong></td></tr><tr><td><strong>作为返回值</strong></td><td>❌ 不行</td><td>✅ 可以</td></tr></tbody></table><h3 id="暂时解锁"><a href="#暂时解锁" class="headerlink" title="暂时解锁"></a>暂时解锁</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heavy_work</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br><span class="hljs-built_in">do_something</span>();<span class="hljs-comment">//处理一些数据</span><br>lock.<span class="hljs-built_in">unlock</span>(); <span class="hljs-comment">// 手动解锁 （此时其他线程可以抢锁干活了） </span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">2</span>));<br>lock.<span class="hljs-built_in">lock</span>(); <span class="hljs-comment">// 手动上锁 </span><br><span class="hljs-built_in">do_something</span>();<span class="hljs-comment">//处理一些数据</span><br>&#125;<span class="hljs-comment">//析构</span><br></code></pre></td></tr></table></figure><p>如上，<code>unique_lock</code>支持暂时解锁。</p><h3 id="Try-Lock"><a href="#Try-Lock" class="headerlink" title="Try Lock"></a>Try Lock</h3><p><code>try_lock()</code>是<code>unique_lock</code>的一个成员函数，返回<code>unique_lock</code>管理的<code>Motex</code>是否上锁，<code>bool</code>类型，是一种非阻塞的逻辑。如果没抢到锁当前线程可以执行else语句中的内容。<code>lock_guard</code>是阻塞逻辑，如果没有拿到锁就一直等待。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::mutex mtx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">try</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// std::defer_lock 的意思是：</span><br>    <span class="hljs-comment">// &quot;我就建个名叫 lock 的对象，先别急着去锁 mtx，我自己手动控制&quot;</span><br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx, std::defer_lock)</span></span>;<br>    <span class="hljs-comment">// 尝试锁一下（非阻塞）</span><br>    <span class="hljs-keyword">if</span> (lock.<span class="hljs-built_in">try_lock</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;抢到锁了！&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-comment">// 离开函数时，lock 会自动帮你 unlock，不用手动写</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;没抢到，我去干别的了。&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!caution]<br>注意如果要使用<code>try_lock()</code>，定义<code>unique_lock</code>的时候一定要传入<code>defer_lock</code></p></blockquote><h3 id="作为返回值（转移所有权）"><a href="#作为返回值（转移所有权）" class="headerlink" title="作为返回值（转移所有权）"></a>作为返回值（转移所有权）</h3><p>最典型的场景是：<strong>我想在一个函数里上锁，但是想在另一个函数里解锁。</strong> 如果使用 <code>lock_guard</code>，这是做不到的。因为它那是“死锁扣”，出了函数就自动弹开了。 只有 <code>unique_lock</code> 可以像接力棒一样传递。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">get_protected_resource</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">my_lock</span><span class="hljs-params">(mtx)</span></span>;<span class="hljs-comment">//在这里上锁</span><br><span class="hljs-keyword">return</span> my_lock;<span class="hljs-comment">//这里的 return 实际上发生了“移动语义 (Move)”，</span><br>   <span class="hljs-comment">//把所有权移交给了调用者 return my_lock; </span><br>&#125;<br></code></pre></td></tr></table></figure><p>除了返回值传递，还有一种场景是在两个变量之间传递，使用<code>std::move</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock1</span><span class="hljs-params">(mtx)</span></span>; <br>std::unique_lock&lt;std::mutex&gt; lock2 = std::<span class="hljs-built_in">move</span>(lock1);<br></code></pre></td></tr></table></figure><blockquote><p>[!caution]<br>注意<code>std::unique_lock&lt;std::mutex&gt; lock2 = lock1;</code>是错误的，锁不能分身，所以禁止复制。</p></blockquote><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>假如一个老板雇佣了一个保安专门给老板开门，这个保安非常的愚蠢，每时每刻都要死死盯着大门看老板来了没有。保安的代码可能是这样的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stupid_guard</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">while</span> (boss_is_comming == <span class="hljs-literal">false</span>)&#123;<br><span class="hljs-comment">//do nothing</span><br>&#125;<br><span class="hljs-built_in">open_gate</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>很显然这个线程一直没闲着，即使老板很久都可能不来，保安也会一直执行检查。在计算机中会导致CPU占用率居高不下，空耗算力。</p><p>一个更高明的机制是设置一个提醒机制，当老板来了之后Notify一下保安，执行开门。这就是条件变量的作用。</p><p>应用条件变量的场景底层就是这个生产者消费者场景。如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::mutex mtx;<br>std::condition_variable cv;<br><span class="hljs-type">bool</span> ready = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 具体的条件数据</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">worker</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>    <span class="hljs-keyword">while</span> (!ready) &#123;<br>        <span class="hljs-comment">// 进入等待：解锁 -&gt; 睡觉 -&gt; (被唤醒) -&gt; 抢锁</span><br>        cv.<span class="hljs-built_in">wait</span>(lock); <br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;保安：老板来了，开门！&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">boss</span><span class="hljs-params">()</span> </span>&#123;<br>    &#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        ready = <span class="hljs-literal">true</span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;老板：我到了。&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-comment">// 释放锁（最好在 notify 之前释放）</span><br><br>    cv.<span class="hljs-built_in">notify_one</span>();<span class="hljs-comment">//唤醒一个正在 wait 的线程</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!note]<br>当保安执行<code>cv.wait(lock)</code>时，底层实际上发生了这三个连贯动作：</p><ol><li>Unlock: 把锁解开，不然老板抢不到锁</li><li>Sleep: 进入休眠，不占用CPU</li><li>Lock: 被唤醒后立即尝试抢锁，只有抢到了才会从wait函数中退出</li></ol><p>由于中间需要<a href="#%E6%9A%82%E6%97%B6%E8%A7%A3%E9%94%81">暂时解锁</a>，所以这里必须用<code>unique_lock</code>，而不是<code>lock_guard</code>。这也是<code>unique_lock</code>可以配合条件变量使用的原因。</p></blockquote><blockquote><p>[!caution]<br>注意保安的代码中必须使用while，只有ready被置true才能退出循环，避免假唤醒。</p></blockquote><p>上述代码是条件变量的一个常用模板。描述了<strong>线程 A 等待某个条件成立，线程 B 改变这个条件并通知 A。</strong> 基本上所有的多线程写作归根结底就是在讲这一件事。</p>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>编程语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Floyd判圈法(寻找重复数)</title>
    <link href="/2026/01/23/obsidian/cpp/%E7%AE%97%E6%B3%95/Floyd%E5%88%A4%E5%9C%88%E6%B3%95(%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0)/"/>
    <url>/2026/01/23/obsidian/cpp/%E7%AE%97%E6%B3%95/Floyd%E5%88%A4%E5%9C%88%E6%B3%95(%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0)/</url>
    
    <content type="html"><![CDATA[<p>类似lc142环形链表。</p><h3 id="1-核心思维转换"><a href="#1-核心思维转换" class="headerlink" title="1. 核心思维转换"></a>1. 核心思维转换</h3><p>将数组抽象为<strong>链表（图）</strong>：</p><ul><li><p><strong>节点</strong>：数组下标 <code>i</code>。</p></li><li><p><strong>指针</strong>：数组的值 <code>nums[i]</code>。</p></li><li><p><strong>规则</strong>：<code>i</code> 指向 <code>nums[i]</code>。</p></li><li><p><strong>结论</strong>：因为有重复数，意味着<strong>有两个不同的下标指向同一个值</strong>，这在图中形成了一个<strong>环</strong>。且这个被多次指向的值，就是<strong>环的入口</strong>。</p></li></ul><h3 id="2-算法流程-双指针法"><a href="#2-算法流程-双指针法" class="headerlink" title="2. 算法流程 (双指针法)"></a>2. 算法流程 (双指针法)</h3><p>该算法分为两个明确的阶段：</p><h4 id="Phase-1：快慢指针找相遇点"><a href="#Phase-1：快慢指针找相遇点" class="headerlink" title="Phase 1：快慢指针找相遇点"></a><strong>Phase 1：快慢指针找相遇点</strong></h4><ul><li><p><strong>操作</strong>：<code>slow</code> 走 1 步，<code>fast</code> 走 2 步。</p></li><li><p><strong>目的</strong>：确认环的存在，并让双指针在环内相遇。</p></li><li><p><strong>终止条件</strong>：<code>slow == fast</code>。</p></li></ul><h4 id="Phase-2：同步指针找入口-Answer"><a href="#Phase-2：同步指针找入口-Answer" class="headerlink" title="Phase 2：同步指针找入口 (Answer)"></a><strong>Phase 2：同步指针找入口 (Answer)</strong></h4><ul><li><p><strong>操作</strong>：</p><ol><li><p><code>slow</code> 重置回起点 <code>0</code>。</p></li><li><p><code>fast</code> 保持在刚才的相遇点不变。</p></li><li><p>两个指针<strong>每次都走 1 步</strong>。</p></li></ol></li><li><p><strong>目的</strong>：找到环的入口节点。</p></li><li><p><strong>终止条件</strong>：<code>slow == fast</code> (再次相遇的位置即为重复数)。</p></li></ul><h3 id="3-为什么-Phase-2-能找到入口？-数学原理"><a href="#3-为什么-Phase-2-能找到入口？-数学原理" class="headerlink" title="3. 为什么 Phase 2 能找到入口？(数学原理)"></a>3. 为什么 Phase 2 能找到入口？(数学原理)</h3><p>假设：</p><ul><li><p>起点到环入口距离为 <strong>$x$</strong>。</p></li><li><p>环入口到相遇点距离为 <strong>$y$</strong>。</p></li><li><p>环的剩余长度为 <strong>$z$</strong>。</p></li><li><p>也就是：环的总长度 $L &#x3D; y + z$。</p></li></ul><p><strong>推导</strong>：</p><ol><li><p>快指针路程是慢指针的 2 倍：</p><p> $2(x + y) &#x3D; x + y + n \cdot L$ (快指针多跑了 n 圈)</p></li><li><p>化简消去 $(x+y)$：</p><p> $x + y &#x3D; n \cdot L$</p></li><li><p>移项求 $x$：</p><p> $x &#x3D; n \cdot L - y$</p><p> $x &#x3D; (n-1) \cdot L + (L - y)$</p><p> $x &#x3D; (n-1) \cdot L + z$</p></li></ol><p>总结：</p><p>“起点到入口的距离 ($x$)” 恰好等于 “相遇点继续往前走回到入口的距离 ($z$)” (忽略跑在这个过程中的整圈数)。</p><p>所以，一个从头走，一个从相遇点走，只要每次一步，必在入口相遇。</p>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>cycle-detection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图</title>
    <link href="/2026/01/23/obsidian/cpp/Notes/12.graph/%E5%9B%BE/"/>
    <url>/2026/01/23/obsidian/cpp/Notes/12.graph/%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>跟<a href="../2.ListNode/%E9%93%BE%E8%A1%A8.md">之前自己定义的链表</a>不同，c++定义的链表将前后指针都封装起来了，转而采用c++风格的push_back()等成员函数进行操作。</p><h3 id="98-可达路径"><a href="#98-可达路径" class="headerlink" title="98. 可达路径"></a>98. 可达路径</h3><p><a href="https://kamacoder.com/problempage.php?pid=1170">原题链接</a></p><p>主要是学习图的存储方式。这里使用dfs，分别使用邻接数组和邻接表进行存储，代码如下</p><p>使用邻接数组的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 收集符合条件的路径</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 1节点到终点的路径</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 当前遍历的节点x 到达节点n </span><br>    <span class="hljs-keyword">if</span> (x == n) &#123; <span class="hljs-comment">// 找到符合条件的一条路径</span><br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">// 遍历节点x链接的所有节点</span><br>        <span class="hljs-keyword">if</span> (graph[x][i] == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 找到 x链接的节点</span><br>            path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 遍历到的节点加入到路径中来</span><br>            <span class="hljs-built_in">dfs</span>(graph, i, n); <span class="hljs-comment">// 进入下一层递归</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销本节点</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, s, t;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-comment">// 节点编号从1到n，所以申请 n+1 这么大的数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-comment">// 使用邻接矩阵 表示无线图，1 表示 s 与 t 是相连的</span><br>        graph[s][t] = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 无论什么路径已经是从0节点出发</span><br>    <span class="hljs-built_in">dfs</span>(graph, <span class="hljs-number">1</span>, n); <span class="hljs-comment">// 开始遍历</span><br><br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;pa : result) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pa.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123;<br>            cout &lt;&lt; pa[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; pa[pa.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]  &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用邻接表的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 收集符合条件的路径</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 1节点到终点的路径</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (x == n) &#123; <span class="hljs-comment">// 找到符合条件的一条路径</span><br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : graph[x]) &#123; <span class="hljs-comment">// 找到 x指向的节点</span><br>        path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 遍历到的节点加入到路径中来</span><br>        <span class="hljs-built_in">dfs</span>(graph, i, n); <span class="hljs-comment">// 进入下一层递归</span><br>        path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销本节点</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, s, t;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-comment">// 节点编号从1到n，所以申请 n+1 这么大的数组</span><br>    vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>); <span class="hljs-comment">// 邻接表</span><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-comment">// 使用邻接表 ，表示 s -&gt; t 是相连的</span><br>        graph[s].<span class="hljs-built_in">push_back</span>(t);<br><br>    &#125;<br><br>    path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 无论什么路径已经是从0节点出发</span><br>    <span class="hljs-built_in">dfs</span>(graph, <span class="hljs-number">1</span>, n); <span class="hljs-comment">// 开始遍历</span><br><br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;pa : result) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pa.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123;<br>            cout &lt;&lt; pa[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; pa[pa.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]  &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意邻接表中list的操作方式。包括遍历(<code>int i : graph[x]</code>),新增(<code>graph[s].push_back(t)</code>)等。实际上list在这里的用法跟数组相差不大了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈和队列</title>
    <link href="/2026/01/23/obsidian/cpp/Notes/6.StackandQueue/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2026/01/23/obsidian/cpp/Notes/6.StackandQueue/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><p><img src="https://cdn.jsdelivr.net/gh/HRbenY/blog-assets@master//img/20260117145538050.png" alt="栈和队列"></p><h2 id="STL概念"><a href="#STL概念" class="headerlink" title="STL概念"></a>STL概念</h2><p>STL (Standard Template Library, 标准模板库) 是 C++ 标准库的核心部分，它提供了一套功能强大的通用数据结构和算法。STL 基于泛型编程 (Generic Programming) 的思想，通过模板实现了代码的高度可重用性。</p><h3 id="STL-四大核心组件"><a href="#STL-四大核心组件" class="headerlink" title="STL 四大核心组件"></a>STL 四大核心组件</h3><ol><li><p><strong>容器 (Containers)</strong></p><ul><li><strong>作用</strong>：用于存储和管理数据的类模板，即各种数据结构。</li><li><strong>分类</strong>：<ul><li><strong>序列容器</strong> (<code>vector</code>, <code>deque</code>, <code>list</code>)：按线性顺序存储元素。</li><li><strong>关联容器</strong> (<code>set</code>, <code>map</code>)：根据键值自动排序元素，查找速度快。</li><li><strong>无序关联容器</strong> (<code>unordered_set</code>, <code>unordered_map</code>)：基于哈希表，提供更快的平均查找速度。</li><li><strong>容器适配器</strong> (<code>stack</code>, <code>queue</code>, <code>priority_queue</code>)：在现有容器基础上提供特定接口。</li></ul></li></ul></li><li><p><strong>算法 (Algorithms)</strong></p><ul><li><strong>作用</strong>：一系列用于处理容器中元素的函数模板，如排序、搜索、复制等。</li><li><strong>特点</strong>：算法独立于任何特定容器，通过迭代器与数据进行交互。例如 <code>sort()</code>, <code>find()</code>, <code>copy()</code>。</li></ul></li><li><p><strong>迭代器 (Iterators)</strong></p><ul><li><strong>作用</strong>：扮演容器和算法之间的“胶水”或桥梁。它是一种行为类似指针的对象，用于遍历容器中的元素。</li><li><strong>特点</strong>：使得任何算法都可以与任何容器协同工作。</li></ul></li><li><p><strong>函数对象 (Functors)</strong></p><ul><li><strong>作用</strong>：行为类似函数的对象，可以通过重载 <code>operator()</code> 来实现。</li><li><strong>用途</strong>：常用于自定义算法的行为，例如为 <code>sort()</code> 提供自定义的排序规则。</li></ul></li></ol><hr><h2 id="2-STL-容器适配器：stack-与-queue"><a href="#2-STL-容器适配器：stack-与-queue" class="headerlink" title="2. STL 容器适配器：stack 与 queue"></a>2. STL 容器适配器：<code>stack</code> 与 <code>queue</code></h2><p>它们是通过封装其他容器（默认为 <code>deque</code>）来实现的，仅提供符合其数据结构特性的有限接口。</p><h3 id="栈-std-stack"><a href="#栈-std-stack" class="headerlink" title="栈 (std::stack)"></a>栈 (std::stack)</h3><p><strong>后进先出 (LIFO - Last-In, First-Out)</strong> 的数据结构。需要包含头文件 <code>&lt;stack&gt;</code>。</p><table><thead><tr><th align="left">函数 (Function)</th><th align="left">功能描述</th><th align="left">用法示例</th></tr></thead><tbody><tr><td align="left"><code>push(element)</code></td><td align="left">在栈顶压入一个新元素。</td><td align="left"><code>s.push(10);</code></td></tr><tr><td align="left"><code>pop()</code></td><td align="left"><strong>移除</strong>栈顶的元素（无返回值）。</td><td align="left"><code>s.pop();</code></td></tr><tr><td align="left"><code>top()</code></td><td align="left"><strong>返回</strong>对栈顶元素的引用（不移除）。</td><td align="left"><code>int val = s.top();</code></td></tr><tr><td align="left"><code>empty()</code></td><td align="left">检查栈是否为空，空则返回 <code>true</code>。</td><td align="left"><code>if (s.empty()) { ... }</code></td></tr><tr><td align="left"><code>size()</code></td><td align="left">返回栈中元素的数量。</td><td align="left"><code>int count = s.size();</code></td></tr></tbody></table><h3 id="队列-std-queue"><a href="#队列-std-queue" class="headerlink" title="队列 (std::queue)"></a>队列 (std::queue)</h3><p><strong>先进先出 (FIFO - First-In, First-Out)</strong> 的数据结构。需要包含头文件 <code>&lt;queue&gt;</code>。</p><table><thead><tr><th align="left">函数 (Function)</th><th align="left">功能描述</th><th align="left">用法示例</th></tr></thead><tbody><tr><td align="left"><code>push(element)</code></td><td align="left">在队尾推入一个新元素（入队）。</td><td align="left"><code>q.push(10);</code></td></tr><tr><td align="left"><code>pop()</code></td><td align="left"><strong>移除</strong>队头的元素（无返回值）。</td><td align="left"><code>q.pop();</code></td></tr><tr><td align="left"><code>front()</code></td><td align="left"><strong>返回</strong>对<strong>队头</strong>元素的引用。</td><td align="left"><code>int val = q.front();</code></td></tr><tr><td align="left"><code>back()</code></td><td align="left"><strong>返回</strong>对<strong>队尾</strong>元素的引用。</td><td align="left"><code>int val = q.back();</code></td></tr><tr><td align="left"><code>empty()</code></td><td align="left">检查队列是否为空，空则返回 <code>true</code>。</td><td align="left"><code>if (q.empty()) { ... }</code></td></tr><tr><td align="left"><code>size()</code></td><td align="left">返回队列中元素的数量。</td><td align="left"><code>int count = q.size();</code></td></tr></tbody></table><hr><h2 id="力扣"><a href="#力扣" class="headerlink" title="力扣"></a>力扣</h2><h3 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h3><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">原题链接</a></p><p>思路很简单，这里记一下一些类型转换函数。</p><blockquote><h4 id="C-sto-系列函数用法详解"><a href="#C-sto-系列函数用法详解" class="headerlink" title="C++ sto* 系列函数用法详解"></a>C++ <code>sto*</code> 系列函数用法详解</h4><p><code>sto*</code> 系列函数是 C++11 引入的，定义在 <code>&lt;string&gt;</code> 头文件中。它们是将字符串转换为数值类型的现代、安全的首选方法，主要优点是通过抛出异常来处理错误，避免了 C 风格函数（如 <code>atoi</code>）的 ambiguity。</p><h5 id="主要函数列表"><a href="#主要函数列表" class="headerlink" title="主要函数列表"></a>主要函数列表</h5><table><thead><tr><th align="left">函数 (Function)</th><th align="left">功能 (Description)</th><th align="left">返回类型 (Return Type)</th><th align="left">示例代码 (Example)</th></tr></thead><tbody><tr><td align="left"><code>std::stoi</code></td><td align="left">转换为有符号整型</td><td align="left"><code>int</code></td><td align="left"><code>int i = stoi(&quot; -123 &quot;);</code></td></tr><tr><td align="left"><code>std::stol</code></td><td align="left">转换为有符号长整型</td><td align="left"><code>long</code></td><td align="left"><code>long l = stol(&quot; 12345 &quot;);</code></td></tr><tr><td align="left"><code>std::stoll</code></td><td align="left">转换为有符号长长整型</td><td align="left"><code>long long</code></td><td align="left"><code>long long ll = stoll(&quot;1234567890&quot;);</code></td></tr><tr><td align="left"><code>std::stoul</code></td><td align="left">转换为无符号长整型</td><td align="left"><code>unsigned long</code></td><td align="left"><code>unsigned long ul = stoul(&quot;98765&quot;);</code></td></tr><tr><td align="left"><code>std::stoull</code></td><td align="left">转换为无符号长长整型</td><td align="left"><code>unsigned long long</code></td><td align="left"><code>unsigned long long ull = stoull(&quot;9876543210&quot;);</code></td></tr><tr><td align="left"><code>std::stof</code></td><td align="left">转换为单精度浮点数</td><td align="left"><code>float</code></td><td align="left"><code>float f = stof(&quot;3.14f&quot;);</code></td></tr><tr><td align="left"><code>std::stod</code></td><td align="left">转换为双精度浮点数</td><td align="left"><code>double</code></td><td align="left"><code>double d = stod(&quot;2.71828&quot;);</code></td></tr><tr><td align="left"><code>std::stold</code></td><td align="left">转换为长双精度浮点数</td><td align="left"><code>long double</code></td><td align="left"><code>long double ld = stold(&quot; -1.23e+4 &quot;);</code></td></tr></tbody></table><h5 id="通用特性"><a href="#通用特性" class="headerlink" title="通用特性"></a>通用特性</h5><ul><li><strong>错误处理</strong>:<ul><li><code>std::invalid_argument</code>: 如果字符串无法进行任何转换（例如 <code>stoi(&quot;hello&quot;)</code>），则抛出此异常。</li><li><code>std::out_of_range</code>: 如果转换后的值超出了返回类型的表示范围（例如 <code>stoi(&quot;3000000000&quot;)</code>），则抛出此异常。</li></ul></li><li><strong>参数</strong>:<ul><li>这些函数通常接受可选的第二个参数（<code>size_t* idx</code>）来获取已处理的字符数，以及第三个参数（<code>int base</code>）来指定进制（仅适用于整型函数）。</li></ul></li></ul></blockquote><h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h3><p><a href="https://leetcode.cn/problems/sliding-window-maximum/description/">原题链接</a></p><p>要注意在滑动窗口的前提下，当前的窗口最大值的生命周期是有限的。每次滑动都有新入列和新出列的元素。可以重新定义pop和push方法，使push入列之后内部是顺序排列的，当pop的值是列内最大值就把最大值排出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">myQue</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        deque&lt;<span class="hljs-type">int</span>&gt; myq;<br>        <span class="hljs-built_in">myQue</span>() &#123;&#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (!myq.<span class="hljs-built_in">empty</span>() &amp;&amp; val == myq.<span class="hljs-built_in">front</span>()) &#123;<br>                myq.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (myq.<span class="hljs-built_in">empty</span>()) &#123;<br>                myq.<span class="hljs-built_in">push_back</span>(val);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (!myq.<span class="hljs-built_in">empty</span>() &amp;&amp; val &gt; myq.<span class="hljs-built_in">back</span>()) &#123;<br>                    myq.<span class="hljs-built_in">pop_back</span>();<br>                &#125;<br>                myq.<span class="hljs-built_in">push_back</span>(val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> myq.<span class="hljs-built_in">front</span>(); &#125;<br>    &#125;;<br></code></pre></td></tr></table></figure><p>由于我们要重新定义pop和push方法，这里在题目给定的类内部新建私有类myQue。由于需要同时对头尾进行操作，这里使用deque数据结构。用法如下：</p><blockquote><h4 id="构造函数-Constructors"><a href="#构造函数-Constructors" class="headerlink" title="构造函数 (Constructors)"></a>构造函数 (Constructors)</h4><p>用于创建 <code>deque</code> 对象。</p><table><thead><tr><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>deque()</code></td><td align="left">默认构造函数，创建一个空的 <code>deque</code>。</td></tr><tr><td align="left"><code>explicit deque(size_type n)</code></td><td align="left">创建一个包含 <code>n</code> 个默认初始化元素的 <code>deque</code>。</td></tr><tr><td align="left"><code>deque(size_type n, const T&amp; value)</code></td><td align="left">创建一个包含 <code>n</code> 个值为 <code>value</code> 的元素的 <code>deque</code>。</td></tr><tr><td align="left"><code>deque(InputIt first, InputIt last)</code></td><td align="left">用迭代器 <code>first</code> 和 <code>last</code> 之间的元素创建 <code>deque</code>。</td></tr><tr><td align="left"><code>deque(const deque&amp; other)</code></td><td align="left">拷贝构造函数，创建 <code>other</code> 的一个副本。</td></tr><tr><td align="left"><code>deque(deque&amp;&amp; other)</code></td><td align="left">移动构造函数，接管 <code>other</code> 的资源。</td></tr><tr><td align="left"><code>deque(std::initializer_list&lt;T&gt; ilist)</code></td><td align="left">用初始化列表创建 <code>deque</code> (例如 <code>std::deque&lt;int&gt; d = {1, 2, 3};</code>)。</td></tr></tbody></table><hr><h4 id="元素访问-Element-access"><a href="#元素访问-Element-access" class="headerlink" title="元素访问 (Element access)"></a>元素访问 (Element access)</h4><p>用于访问 <code>deque</code> 中的数据。</p><table><thead><tr><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>at(size_type pos)</code></td><td align="left">返回在指定位置 <code>pos</code> 的元素的引用。会进行边界检查，如果越界会抛出 <code>std::out_of_range</code> 异常。</td></tr><tr><td align="left"><code>operator[](size_type pos)</code></td><td align="left">返回在指定位置 <code>pos</code> 的元素的引用。<strong>不进行</strong>边界检查，如果越界是未定义行为。</td></tr><tr><td align="left"><code>front()</code></td><td align="left">返回第一个元素的引用。在一个空 <code>deque</code> 上调用是未定义行为。</td></tr><tr><td align="left"><code>back()</code></td><td align="left">返回最后一个元素的引用。在一个空 <code>deque</code> 上调用是未定义行为。</td></tr></tbody></table><hr><h4 id="修改器-Modifiers"><a href="#修改器-Modifiers" class="headerlink" title="修改器 (Modifiers)"></a>修改器 (Modifiers)</h4><p>用于修改 <code>deque</code> 的内容。</p><table><thead><tr><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>push_front(const T&amp; value)</code></td><td align="left">在 <code>deque</code> 的开头插入一个元素。</td></tr><tr><td align="left"><code>push_back(const T&amp; value)</code></td><td align="left">在 <code>deque</code> 的末尾添加一个元素。</td></tr><tr><td align="left"><code>pop_front()</code></td><td align="left">移除 <code>deque</code> 的第一个元素。</td></tr><tr><td align="left"><code>pop_back()</code></td><td align="left">移除 <code>deque</code> 的最后一个元素。</td></tr><tr><td align="left"><code>insert(iterator pos, const T&amp; value)</code></td><td align="left">在迭代器 <code>pos</code> 指向的位置之前插入元素 <code>value</code>。</td></tr><tr><td align="left"><code>insert(iterator pos, size_type n, const T&amp; value)</code></td><td align="left">在 <code>pos</code> 之前插入 <code>n</code> 个值为 <code>value</code> 的元素。</td></tr><tr><td align="left"><code>insert(iterator pos, InputIt first, InputIt last)</code></td><td align="left">在 <code>pos</code> 之前插入由迭代器 <code>[first, last)</code> 范围指定的元素。</td></tr><tr><td align="left"><code>erase(iterator pos)</code></td><td align="left">移除迭代器 <code>pos</code> 指向的元素。</td></tr><tr><td align="left"><code>erase(iterator first, iterator last)</code></td><td align="left">移除迭代器 <code>[first, last)</code> 范围内的所有元素。</td></tr><tr><td align="left"><code>swap(deque&amp; other)</code></td><td align="left">与另一个 <code>deque</code> 交换内容。</td></tr><tr><td align="left"><code>clear()</code></td><td align="left">清空 <code>deque</code> 中的所有元素，使其大小变为 0。</td></tr><tr><td align="left"><code>emplace_front(Args&amp;&amp;... args)</code></td><td align="left">在 <code>deque</code> 的开头就地构造一个元素，比 <code>push_front</code> 更高效（避免额外拷贝）。</td></tr><tr><td align="left"><code>emplace_back(Args&amp;&amp;... args)</code></td><td align="left">在 <code>deque</code> 的末尾就地构造一个元素，比 <code>push_back</code> 更高效。</td></tr><tr><td align="left"><code>emplace(iterator pos, Args&amp;&amp;... args)</code></td><td align="left">在迭代器 <code>pos</code> 指向的位置之前就地构造一个元素。</td></tr><tr><td align="left"><code>assign(size_type n, const T&amp; value)</code></td><td align="left">赋予 <code>deque</code> 新内容，替换掉原有内容（<code>n</code> 个 <code>value</code>）。</td></tr><tr><td align="left"><code>assign(InputIt first, InputIt last)</code></td><td align="left">赋予 <code>deque</code> 新内容，替换掉原有内容（来自迭代器范围）。</td></tr></tbody></table><hr><h4 id="容量-Capacity"><a href="#容量-Capacity" class="headerlink" title="容量 (Capacity)"></a>容量 (Capacity)</h4><p>用于查询 <code>deque</code> 的大小和容量状态。</p><table><thead><tr><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>empty()</code></td><td align="left">检查 <code>deque</code> 是否为空。如果是，返回 <code>true</code>。</td></tr><tr><td align="left"><code>size()</code></td><td align="left">返回 <code>deque</code> 中元素的数量。</td></tr><tr><td align="left"><code>max_size()</code></td><td align="left">返回 <code>deque</code> 能够容纳的最大元素数量。</td></tr><tr><td align="left"><code>resize(size_type n)</code></td><td align="left">改变 <code>deque</code> 的大小为 <code>n</code>。如果 <code>n</code> 小于当前大小，则丢弃末尾元素；如果 <code>n</code> 大于当前大小，则在末尾添加默认初始化的元素。</td></tr><tr><td align="left"><code>resize(size_type n, const T&amp; value)</code></td><td align="left">功能同上，但在扩容时添加值为 <code>value</code> 的元素。</td></tr><tr><td align="left"><code>shrink_to_fit()</code></td><td align="left">请求 <code>deque</code> 减少其内存使用以适应其大小（这只是一个请求，不保证一定实现）。</td></tr></tbody></table><hr><h4 id="迭代器-Iterators"><a href="#迭代器-Iterators" class="headerlink" title="迭代器 (Iterators)"></a>迭代器 (Iterators)</h4><p>用于遍历 <code>deque</code>。<code>deque</code> 的迭代器是随机访问迭代器。</p><table><thead><tr><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>begin()</code></td><td align="left">返回指向第一个元素的迭代器。</td></tr><tr><td align="left"><code>end()</code></td><td align="left">返回指向末尾元素之后位置的迭代器。</td></tr><tr><td align="left"><code>rbegin()</code></td><td align="left">返回指向最后一个元素的反向迭代器。</td></tr><tr><td align="left"><code>rend()</code></td><td align="left">返回指向第一个元素之前位置的反向迭代器。</td></tr><tr><td align="left"><code>cbegin()</code>, <code>cend()</code></td><td align="left">返回 <code>const</code> 迭代器，用于只读访问。</td></tr><tr><td align="left"><code>crbegin()</code>, <code>crend()</code></td><td align="left">返回 <code>const</code> 反向迭代器，用于只读访问。</td></tr></tbody></table></blockquote><h3 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a>232. 用栈实现队列</h3><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/description/">原题链接</a></p><p>用两个栈可以实现队列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">MyQueue</span>():<span class="hljs-built_in">inStack</span>(), <span class="hljs-built_in">outStack</span>() &#123;&#125;<br></code></pre></td></tr></table></figure><p>这是之前在链表中讲过的构造函数，使用的成员初始化列表进行初始化。这里没有给初始值，如果需要给初始值的话，除了用成员初始化列表，也可以在函数内部（花括号内部）进行赋值操作。两者有一些重要区别：</p><blockquote><h4 id="成员初始化列表-vs-赋值初始化"><a href="#成员初始化列表-vs-赋值初始化" class="headerlink" title="成员初始化列表 vs. 赋值初始化"></a>成员初始化列表 vs. 赋值初始化</h4><p>为了方便对比，我们使用一个简单的 <code>Student</code> 类作为例子。</p><p><strong>方式一：成员初始化列表 (Member Initializer List)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    std::string name;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> studentID;<br><br><br><br>    <span class="hljs-comment">// 使用成员初始化列表</span><br><br>    <span class="hljs-built_in">Student</span>(std::string n, <span class="hljs-type">int</span> id) : <span class="hljs-built_in">name</span>(n), <span class="hljs-built_in">studentID</span>(id) &#123;<br><br>        <span class="hljs-comment">// 构造函数体可以是空的</span><br><br>    &#125;<br><br>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>方式二：赋值初始化 (In-body Assignment)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    std::string name;<br><br>    <span class="hljs-comment">// const int studentID; // 错误！const 成员不能在此处使用赋值初始化</span><br><br><br><br>    <span class="hljs-comment">// 在构造函数体内赋值</span><br><br>    <span class="hljs-built_in">Student</span>(std::string n) &#123;<br><br>        name = n;<br><br>    &#125;<br><br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="核心对比"><a href="#核心对比" class="headerlink" title="核心对比"></a>核心对比</h4><table><thead><tr><th align="left">对比项</th><th align="left">成员初始化列表 (Member Initializer List)</th><th align="left">赋值初始化 (In-body Assignment)</th></tr></thead><tbody><tr><td align="left"><strong>本质</strong></td><td align="left"><strong>初始化 (Initialization)</strong></td><td align="left"><strong>赋值 (Assignment)</strong></td></tr><tr><td align="left"><strong>详细说明</strong></td><td align="left">在对象创建时，成员变量被“直接构建”出来，一步到位。就像婴儿出生时直接取好名字。</td><td align="left">成员变量会先被<strong>默认初始化</strong>，然后在构造函数体内被赋予新值。就像婴儿出生时先有个临时编号，之后再改名。</td></tr><tr><td align="left"><strong>执行时机</strong></td><td align="left">在进入构造函数体 <code>{}</code> <strong>之前</strong>执行。</td><td align="left">在构造函数体 <code>{}</code> <strong>之内</strong>执行。</td></tr><tr><td align="left"><strong>效率</strong></td><td align="left"><strong>更高</strong>。尤其对于类类型的成员（如 <code>string</code> 或其他自定义类），它避免了“默认构造 + 赋值”的两次开销。</td><td align="left"><strong>较低</strong>。对于复杂类型，会产生额外的函数调用开销，影响性能。</td></tr><tr><td align="left"><strong>适用性</strong></td><td align="left"><strong>通用性强</strong>。是唯一可以初始化以下三种成员的方式：<br>1. <code>const</code> 常量成员<br>2. 引用 (<code>&amp;</code>) 成员<br>3. 没有默认构造函数的类成员</td><td align="left"><strong>通用性差</strong>。无法用于初始化 <code>const</code> 成员、引用成员或没有默认构造函数的类成员，会导致编译错误。</td></tr><tr><td align="left"><strong>代码风格</strong></td><td align="left"><strong>推荐</strong>。被认为是现代 C++ 的最佳实践，代码更高效、更清晰。</td><td align="left"><strong>不推荐</strong>。只应在初始化逻辑非常复杂（如需要 <code>if/else</code> 或循环）时，在函数体内进行后续的赋值操作。</td></tr></tbody></table><h4 id="黄金法则"><a href="#黄金法则" class="headerlink" title="黄金法则"></a>黄金法则</h4><blockquote><p><strong>能用初始化列表的，就都用初始化列表。</strong></p></blockquote><blockquote></blockquote><blockquote><p>这是一个简单且高效的准则。它不仅能带来性能上的好处，还能避免因 <code>const</code> 或引用成员无法被赋值而导致的编译错误，是更健壮、更专业的写法。</p></blockquote></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-comment">//this-&gt;push(res);//这样会把元素push到队列尾部</span><br>    outStack.<span class="hljs-built_in">push</span>(res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>this</code>表示当前对象，这里强调调用当前对象自己的pop()函数，避免歧义。  </p><h3 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a>225. 用队列实现栈</h3><p>题目要求用两个队列，其实一个就可以了。主要是pop()这一步。<br><strong>用两个队列</strong>的话把除了尾部元素以外的所有元素全部push到另一个队列中，取出尾部元素后将其余元素再push回去。<br><strong>用一个队列</strong>则是把头部的push到队列尾部，如此循环直到取出最开始的尾部元素。</p><h3 id="347"><a href="#347" class="headerlink" title="347"></a>347</h3><blockquote><h4 id="C-知识点笔记：基于小顶堆解决-Top-K-问题"><a href="#C-知识点笔记：基于小顶堆解决-Top-K-问题" class="headerlink" title="C++ 知识点笔记：基于小顶堆解决 Top K 问题"></a><strong>C++ 知识点笔记：基于小顶堆解决 Top K 问题</strong></h4><h5 id="1-核心数据结构：std-priority-queue"><a href="#1-核心数据结构：std-priority-queue" class="headerlink" title="1. 核心数据结构：std::priority_queue"></a><strong>1. 核心数据结构：<code>std::priority_queue</code></strong></h5><p><code>std::priority_queue</code> 是 C++ 标准库中的一个容器适配器，通常基于堆（Heap）数据结构实现。默认行为是<strong>大顶堆</strong>，即顶部元素始终是优先级最高（最大）的。</p><p><strong>1.1. 模板参数</strong></p><p>其定义包含三个模板参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> = vector&lt;T&gt;, <span class="hljs-keyword">class</span> Compare = less&lt;T&gt;&gt;<br><br><span class="hljs-keyword">class</span> priority_queue;<br><br></code></pre></td></tr></table></figure><ul><li><p><strong><code>T</code> (Type)</strong>: 存储的元素类型。</p><ul><li><em>示例代码应用</em>: <code>std::pair&lt;int, int&gt;</code>，用于存储键值对 <code>(数值, 频率)</code>。</li></ul></li><li><p><strong><code>Container</code></strong>: 实现堆所需的底层容器。</p><ul><li><p><strong>要求</strong>: 必须是支持随机访问迭代器的序列容器，例如 <code>std::vector</code> (默认) 或 <code>std::deque</code>。</p></li><li><p><em>示例代码应用</em>: <code>std::vector&lt;std::pair&lt;int, int&gt;&gt;</code>。</p></li></ul></li><li><p><strong><code>Compare</code></strong>: 比较器，用于定义元素间的优先级顺序。</p><ul><li><p><strong>默认值</strong>: <code>std::less&lt;T&gt;</code>，它通过 <code>a &lt; b</code> 进行比较，建立大顶堆。</p></li><li><p><strong>自定义</strong>: 通过提供自定义的比较器类型，可以改变其行为，例如实现小顶堆。</p></li></ul></li></ul><hr><h5 id="2-关键技术：自定义比较器"><a href="#2-关键技术：自定义比较器" class="headerlink" title="2. 关键技术：自定义比较器"></a><strong>2. 关键技术：自定义比较器</strong></h5><p>当默认的排序行为不满足需求时，必须提供自定义比较器。在本例中，需求是：1) 根据 <code>pair</code> 的第二个元素（频率）排序；2) 实现小顶堆。</p><p><strong>2.1. 比较器 (Comparator)</strong></p><p>比较器是一个可调用实体，它接受两个同类型参数并返回一个布尔值，用于确定它们的相对顺序。</p><p><strong>2.2. 实现方式：函数对象 (Functor)</strong></p><p>函数对象是一个重载了函数调用运算符 <code>operator()</code> 的类的对象。这是向 STL 模板传递自定义逻辑的标准方法。</p><ul><li><p><strong>定义</strong>:</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mycomparison</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// 重载 operator()</span><br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span> <span class="hljs-type">const</span> </span>&#123;<br><br>        <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br><br>    &#125;<br><br>&#125;;<br><br></code></pre></td></tr></table></figure></li><li><p><strong>工作原理</strong>:</p><ul><li><p><code>priority_queue</code> 的第三个模板参数接收一个<strong>类型</strong> (<code>mycomparison</code>)。</p></li><li><p>在内部，<code>priority_queue</code> 会创建该类型的一个实例（一个函数对象）。</p></li><li><p>当需要比较两个元素 <code>a</code> 和 <code>b</code> 的优先级时，它会调用 <code>comp_obj(a, b)</code>，其中 <code>comp_obj</code> 就是创建的函数对象。</p></li></ul></li></ul><p><strong>2.3. 比较逻辑与小顶堆的实现</strong></p><p><code>priority_queue</code> 的比较器逻辑遵循“严格弱序”。其核心规则是：</p><ul><li><p><code>Compare(a, b)</code> 若返回 <code>true</code>，则认为 <code>b</code> 的优先级高于 <code>a</code>。</p></li><li><p>在 <code>return lhs.second &gt; rhs.second;</code> 的逻辑下：</p><ul><li><p>如果 <code>lhs</code> 的频率大于 <code>rhs</code> 的频率，表达式为 <code>true</code>。</p></li><li><p>这意味着 <code>rhs</code> (频率较小者) 的优先级被视为更高，会被放置在堆的更上层。</p></li><li><p>最终，频率最小的元素会成为堆顶。这就构成了一个基于频率的<strong>小顶堆</strong>。</p></li></ul></li></ul><hr><h5 id="3-C-基础概念"><a href="#3-C-基础概念" class="headerlink" title="3. C++ 基础概念"></a><strong>3. C++ 基础概念</strong></h5><p><strong>3.1. 作用域解析运算符 <code>::</code></strong></p><p><code>::</code> 用于指定一个名称（类型、函数、变量等）所属的作用域。</p><ul><li><p><strong>访问命名空间成员</strong>: <code>std::cout</code>，表示 <code>cout</code> 属于 <code>std</code> 命名空间。</p></li><li><p><strong>访问嵌套类型</strong>: <code>std::unordered_map&lt;int, int&gt;::iterator</code>，表示 <code>iterator</code> 类型是在 <code>std::unordered_map</code> 类内部定义的。</p></li></ul><p><strong>3.2. 头文件 (<code>#include</code>) 与命名空间 (<code>namespace</code>)</strong></p><p>这两个概念协同工作但功能不同。</p><ul><li><p><code>#include &lt;header&gt;</code>: 预处理指令，它将指定头文件的内容包含进来，使其中声明的类、函数等对编译器<strong>可见</strong>。</p></li><li><p><code>namespace</code>: 避免命名冲突的机制。标准库的所有组件都定义在 <code>std</code> 命名空间中。要使用它们，必须通过 <code>std::</code> 前缀显式指定其作用域，或者使用 <code>using</code> 指令。</p></li></ul><p><strong>3.3. 迭代器 (<code>iterator</code>)</strong></p><p>迭代器是一种对象，其行为类似于指针，用于遍历容器中的元素。</p><ul><li><p><strong><code>container::iterator</code></strong>: 迭代器的类型，由容器类嵌套定义。</p></li><li><p><strong><code>container.begin()</code></strong>: 返回一个指向容器第一个元素的迭代器。</p></li><li><p><strong><code>container.end()</code></strong>: 返回一个指向容器“尾后”（past-the-end）位置的迭代器，它不指向任何有效元素。</p></li><li><p><strong><code>*it</code></strong>: 解引用，获取迭代器当前指向的元素。</p></li><li><p><strong><code>it++</code></strong>: 移动迭代器到下一个元素。</p></li></ul></blockquote><p>比较器<br>return true –&gt; 左边优先级低</p><p>return false –&gt; 左边优先级高</p>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>stack</tag>
      
      <tag>queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希表</title>
    <link href="/2026/01/23/obsidian/cpp/Notes/3.Hash%20table/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2026/01/23/obsidian/cpp/Notes/3.Hash%20table/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p><strong>什么时候使用哈希法？</strong> 当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</p><p>概述和初始化</p><ul><li><p>std::unordered_map (哈希映射): 存储唯一的<strong>键值对</strong>（key-value pairs）。<strong>键用于快速查找和访问</strong>，值可以重复。适合需要通过键来获取关联值的场景。</p><ul><li>初始化：<code>std::unordered_map&lt;KeyType, ValueType&gt; myMap = &#123;&#123;key1, val1&#125;, &#123;key2, val2&#125;&#125;</code>;</li><li>示例：<code>std::unordered_map&lt;std::string, int&gt; ages = &#123;&#123;&quot;Alice&quot;, 25&#125;, &#123;&quot;Bob&quot;, 30&#125;&#125;</code>;</li></ul></li><li><p>std::unordered_set (哈希集合): 存储唯一的元素（unique keys）。它只关心元素本身，不存储额外的值。适合需要快速判断一个元素是否存在的场景。</p><ul><li>初始化：<code>std::unordered_set&lt;ElementType&gt; mySet = &#123;elem1, elem2, elem3&#125;</code>;</li><li>示例：<code>std::unordered_set&lt;std::string&gt; names = &#123;&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;&#125;</code>;</li></ul></li></ul><p>常用成员函数对比</p><table><thead><tr><th align="left">函数</th><th align="left">std::unordered_map (哈希映射)</th><th align="left">std::unordered_set (哈希集合)</th></tr></thead><tbody><tr><td align="left">插入</td><td align="left">mymap.insert({key, value})<br>myMap.[key] &#x3D; value;</td><td align="left">insert(element)（如果元素已存在，操作无效）</td></tr><tr><td align="left">查找</td><td align="left">find(key)：返回指向键值对的迭代器，未找到则返回 end()</td><td align="left">find(element)：返回指向元素的迭代器，未找到则返回 end()</td></tr><tr><td align="left">访问</td><td align="left">myMap.at(key) <br> myMap[key]</td><td align="left">不支持通过索引访问，需使用迭代器或遍历</td></tr><tr><td align="left">删除</td><td align="left">erase(key)<br>erase(iterator)</td><td align="left">erase(element)<br>erase(iterator)</td></tr><tr><td align="left">清空</td><td align="left">clear()</td><td align="left">clear()</td></tr><tr><td align="left">大小</td><td align="left">size()</td><td align="left">size()</td></tr><tr><td align="left">判断空</td><td align="left">empty()</td><td align="left">empty()</td></tr><tr><td align="left">计数</td><td align="left">count(key)：键是唯一的，返回 0 或 1</td><td align="left">count(element)：元素是唯一的，返回 0 或 1</td></tr></tbody></table><p>区别总结</p><ul><li>存储结构：map 存储键和值，而 set 只存储键（即元素本身）。</li><li>访问方式：map 可以通过 at(key) 或 [] 运算符快速访问值，而 set 只能通过遍历或查找获得元素本身。</li><li>应用场景：当你需要一个**“查找表”（通过键找值）时，使用 map；当你需要一个“去重集合”**（快速判断元素是否存在）时，使用 set。</li></ul><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h3><p><a href="https://leetcode.cn/problems/valid-anagram/description/">原题链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> record[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++ )&#123;<br>            record[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] += <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-built_in">size</span>(); i++ )&#123;<br>            record[t[i] - <span class="hljs-string">&#x27;a&#x27;</span>] -= <span class="hljs-number">1</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p>在C++中，<code>std::string</code>类型可以被看作是一个字符数组。可以用之前学到的.size()计算长度，用索引访问内部元素等。</p><p>这两个for循环体现了哈希表的思想：<code>record</code>是哈希表，<code>s[i] - &#39;a&#39;</code>是哈希函数，字符串中的每个字符是索引，<code>record</code>数组中对应索引位置的数是值。这个过程可以总结为</p><blockquote><p>遍历字符串 s 时，取出一个字符（键），用哈希函数 <code>s[i] - &#39;a&#39;</code> 算出它在 <code>record</code> 数组中的位置，然后在这个位置上将值加1。</p></blockquote><p>这里可以用数组做哈希的题目的原因是，题目限定了索引数（26个字母）</p><h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h3><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">原题链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">unordered_set&lt;<span class="hljs-type">int</span>&gt; result_set;<br><span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums1_set</span><span class="hljs-params">(nums<span class="hljs-number">1.</span>begin(), nums<span class="hljs-number">1.</span>end())</span></span>;<br></code></pre></td></tr></table></figure><p>unordered_set的初始化方式。注意要声明元素格式。</p><blockquote><p>初始化unorderes_set的方式有四种。  </p><ul><li>默认初始化不赋值</li><li>范围初始化。使用begin和end进行范围赋值</li><li>列表初始化，例如<code>unordered_set&lt;string&gt; fruits = &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;apple&quot;&#125;;</code></li><li>拷贝和移动初始化。例如</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::unordered_set&lt;<span class="hljs-type">double</span>&gt; s1 = &#123;<span class="hljs-number">1.1</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">3.3</span>&#125;;<br><br><span class="hljs-comment">// 拷贝构造函数：s2 是 s1 的一个完整副本</span><br><span class="hljs-function">std::unordered_set&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">s2</span><span class="hljs-params">(s1)</span></span>; <br><br><span class="hljs-comment">// 移动构造函数：s3 “接管”了 s1 的资源，效率更高</span><br><span class="hljs-function">std::unordered_set&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">s3</span><span class="hljs-params">(std::move(s1))</span></span>; <br><span class="hljs-comment">// s1 现在处于一个不确定的状态，通常不应再使用</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums2)&#123;<br>    <span class="hljs-keyword">if</span> (nums1_set.<span class="hljs-built_in">find</span>(num) != nums1_set.<span class="hljs-built_in">end</span>())&#123;<br>    result_set.<span class="hljs-built_in">insert</span>(num);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里的for条件，<code>int num : nums2</code>的意思是<code>num</code>遍历<code>nums2</code>中的所有值。所以num的格式与nums中元素的格式要保持一致。int可以换成auto，就不用考虑格式的事情了。或者，<code>const auto&amp; num : nums2</code>  ,这是最正确的写法。</p><p><code>if (nums1_set.find(num) != nums1_set.end())</code>中，if条件的意思是，如果nums1_set中没找到num。<code>.find(num)</code>可以在nums1_set中遍历寻找num。找到则返回指向num的迭代器。没找到则返回的迭代器指向末尾虚位，即nums1_set.end()。</p><h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h3><p><a href="https://leetcode.cn/problems/happy-number/description/">原题链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(hash_n.<span class="hljs-built_in">count</span>(n) == <span class="hljs-number">0</span>)&#123;<br>        hash_n.<span class="hljs-built_in">insert</span>(n);<br>        n = <span class="hljs-built_in">sum</span>(n);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>哈希表法，利用哈希表快速判断元素是否存在于集合中。这里当陷入死循环或确定是快乐数都会陷入循环，通过检查元素是否重复可以判断出来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(slow != fast)&#123;<br>    slow = <span class="hljs-built_in">sum</span>(slow);<br>    fast = <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">sum</span>(fast));<br>&#125;<br></code></pre></td></tr></table></figure><p>快慢指针，陷入循环快慢指针就会碰面。</p><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h3><p><a href="https://leetcode.cn/problems/3sum/description/">原题链接</a></p><p>这题用双指针简单一点。之后再补一下哈希表的做法？做的时候把各指针去重逻辑想清楚。尤其是left和right，使用<code>(nums[left + 1] == nums[left])</code>判断去重后，实际上left是指向的最后一个重复元素，此时还需要在最后补上一句<code>left++</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><p>sort的用法，要引用algorithm头文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);<br></code></pre></td></tr></table></figure><p><code>.push_back()</code>在<code>result</code>最后添加一个元素。要注意这里添加的元素类型要和<code>result</code>定义的保持一致。对于一个向量，所有元素要用花括号括起来。</p><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p><a href="https://leetcode.cn/problems/two-sum/">原题链接</a></p><p>这题的思路就是逐个取给定数组中的元素x，计算要与target的差值y，然后查找这个差值y存不存在。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; num_map;<br></code></pre></td></tr></table></figure><p>哈希map的定义，这里定义成<code>&lt;int, int&gt;</code> 键值对。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">return</span> &#123;i, (num_map.<span class="hljs-built_in">find</span>(target - nums[i])-&gt;second)&#125;;<br></code></pre></td></tr></table></figure><p>iterator-&gt;second表示迭代器指向键值对的第二项，即键值对的值。</p><h3 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a>454. 四数相加 II</h3><p><a href="https://leetcode.cn/problems/4sum-ii/description/">原题链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : nums1)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b : nums2)&#123;<br>        A[a+b]++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先注意这里循环的写法，直接用元素值遍历数组，更简洁。也可以写成用索引遍历的，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; a &lt; nums<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(); a++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = <span class="hljs-number">0</span>; b &lt; nums<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>(); b++)&#123;<br>        A[nums1[a]+nums2[b]]++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在对unordered_map添加键值对的时候，可以直接使用<code>A[a+b]++</code>。或者用insert函数插入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c : nums3)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d : nums4)&#123;<br>        <span class="hljs-comment">// if(A.count(0 - c - d))&#123;</span><br>            <span class="hljs-comment">// result += A.find(0 - c - d)-&gt;second;</span><br>            result += A[<span class="hljs-number">0</span> - c - d];<br>            <span class="hljs-comment">// &#125;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里要注意，如果用.find的话，在更新result值的时候不能直接<code>result += A.find(0 - c - d)-&gt;second</code>，必须要先if判断一下该键是否存在，不然find如果找不到键值对会返回末尾虚节点，导致报错。使用A[0 - c - d]就不用if判断了</p><h3 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h3><p><a href="https://leetcode.cn/problems/4sum/description/">原题链接</a></p><p>这题是15.三数之和再套一层循环。还是一对left right，再由i 和j 两层循环来查找剩下两个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">3</span>); i++)&#123;<br>    <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])&#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>一开始写成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (i != <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])&#123;<br>        i++;<br></code></pre></td></tr></table></figure><p>这样i有越界的风险。要写成上面正确的形式，用<code>continue</code>跳过循环。此外，使用<code>continue</code>的时候，要记得把<code>while</code>循环改成<code>if</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>((<span class="hljs-built_in">long</span>(nums[i]) + nums[j] + nums[left] + nums[right]) &lt; target)&#123;<br>    left ++;<br>&#125;<br></code></pre></td></tr></table></figure><p>小心数值溢出！这里四个int加一起，先强制转换一个为long就可以了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>hash-table</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串</title>
    <link href="/2026/01/23/obsidian/cpp/Notes/4.String/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2026/01/23/obsidian/cpp/Notes/4.String/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="循环写法"><a href="#循环写法" class="headerlink" title="循环写法"></a>循环写法</h2><table><thead><tr><th align="left">循环写法</th><th align="left">含义</th><th align="left">性能</th><th align="left">能否修改原始元素？</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left"><code>for (string s : words)</code></td><td align="left"><strong>值拷贝 (Pass by Value)</strong></td><td align="left"><strong>慢</strong> (每次循环都复制整个字符串)</td><td align="left"><strong>不能</strong></td><td align="left">很少使用，除非你需要在循环内修改副本且不影响原数据。</td></tr><tr><td align="left"><code>for (string&amp; s : words)</code></td><td align="left"><strong>引用 (Pass by Reference)</strong></td><td align="left"><strong>快</strong> (没有复制开销)</td><td align="left"><strong>能</strong></td><td align="left">当你需要<strong>遍历并修改</strong>容器中的元素时。</td></tr><tr><td align="left"><code>for (const string&amp; s : words)</code></td><td align="left"><strong>常量引用 (Pass by const Reference)</strong></td><td align="left"><strong>快</strong> (没有复制开销)</td><td align="left"><strong>不能</strong> (只读)</td><td align="left">当你只需要<strong>遍历并读取</strong>元素，不进行修改时。<strong>（最佳实践）</strong></td></tr><tr><td align="left"><code>for (const string s : words)</code></td><td align="left"><strong>常量值拷贝 (const Pass by Value)</strong></td><td align="left"><strong>慢</strong> (依然有复制开销)</td><td align="left"><strong>不能</strong></td><td align="left">几乎无用，结合了值拷贝的低效和 <code>const</code> 的只读，意义不大。</td></tr></tbody></table><p>或者，使用auto关键字</p><table><thead><tr><th align="left">使用 <code>auto</code> 的写法</th><th align="left">等价于</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>for (auto s : words)</code></td><td align="left"><code>for (string s : words)</code></td><td align="left"><code>auto</code> 被推断为 <code>string</code> 类型，进行<strong>值拷贝</strong>。<strong>（慢）</strong></td></tr><tr><td align="left"><code>for (auto&amp; s : words)</code></td><td align="left"><code>for (string&amp; s : words)</code></td><td align="left"><code>auto&amp;</code> 被推断为 <code>string&amp;</code> 类型，进行<strong>引用</strong>。<strong>（快，可修改）</strong></td></tr><tr><td align="left"><code>for (const auto&amp; s : words)</code></td><td align="left"><code>for (const string&amp; s : words)</code></td><td align="left"><code>const auto&amp;</code> 被推断为 <code>const string&amp;</code> 类型，进行<strong>常量引用</strong>。<strong>（快，只读）</strong></td></tr></tbody></table><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="1-容量和大小-Capacity"><a href="#1-容量和大小-Capacity" class="headerlink" title="1. 容量和大小 (Capacity)"></a>1. 容量和大小 (Capacity)</h3><ul><li><strong><code>.size()</code> 和 <code>.length()</code></strong>: 功能相同，返回字符串中的字符数。</li><li><strong><code>.capacity()</code></strong>: 返回在不重新分配内存的情况下，字符串可以容纳的字符数。</li><li><strong><code>.empty()</code></strong>: 检查字符串是否为空 (<code>size() == 0</code>)。返回 <code>true</code> 或 <code>false</code>。</li><li><strong><code>.reserve(n)</code></strong>: 请求为字符串预留至少 <code>n</code> 个字符的存储空间。</li><li><strong><code>.shrink_to_fit()</code></strong>: (C++11) 请求减少容量以匹配其大小。</li><li><strong><code>.resize(n, c)</code></strong>: 改变字符串的大小为 <code>n</code>。如果 <code>n</code> 更大，用字符 <code>c</code> 填充；如果更小，则截断。</li><li><strong><code>.clear()</code></strong>: 清空字符串内容，使其变为空字符串。</li></ul><h3 id="2-元素访问-Element-Access"><a href="#2-元素访问-Element-Access" class="headerlink" title="2. 元素访问 (Element Access)"></a>2. 元素访问 (Element Access)</h3><ul><li><strong><code>operator[]</code></strong>: 使用下标访问字符，例如 <code>str[i]</code>。不进行边界检查。</li><li><strong><code>.at(i)</code></strong>: 与 <code>[]</code> 类似，但会进行边界检查，越界会抛出异常。</li><li><strong><code>.front()</code></strong>: 返回第一个字符的引用。</li><li><strong><code>.back()</code></strong>: 返回最后一个字符的引用。</li></ul><h3 id="3-修改器-Modifiers"><a href="#3-修改器-Modifiers" class="headerlink" title="3. 修改器 (Modifiers)"></a>3. 修改器 (Modifiers)</h3><ul><li><strong><code>operator+=</code></strong>: 拼接（追加）另一个字符串、C风格字符串或单个字符。</li><li><strong><code>.append(...)</code></strong>: 功能更丰富的追加操作。</li><li><strong><code>.push_back(c)</code></strong>: 在字符串末尾追加一个字符 <code>c</code>。</li><li><strong><code>.assign(...)</code></strong>: 赋新值，替换字符串原有内容。</li><li><strong><code>.insert(pos, ...)</code></strong>: 在指定位置 <code>pos</code> 插入字符或字符串。</li><li><strong><code>.erase(pos, count)</code></strong>: 删除从位置 <code>pos</code> 开始的 <code>count</code> 个字符。</li><li><strong><code>.replace(pos, count, ...)</code></strong>: 替换字符串中的一部分内容。</li><li><strong><code>.swap(other_str)</code></strong>: 与另一个 <code>std::string</code> 对象交换内容。</li><li><strong><code>.pop_back()</code></strong>: (C++11) 删除字符串的最后一个字符。</li></ul><h3 id="4-字符串操作-String-Operations"><a href="#4-字符串操作-String-Operations" class="headerlink" title="4. 字符串操作 (String Operations)"></a>4. 字符串操作 (String Operations)</h3><ul><li><strong><code>.c_str()</code></strong>: 返回一个指向以空字符 <code>\0</code> 结尾的C风格字符串 (<code>const char*</code>)。</li><li><strong><code>.data()</code></strong>: (C++11) 返回指向字符串内部数据数组的指针。</li><li><strong><code>.find(substr, pos)</code></strong>: 从位置 <code>pos</code> 开始，查找 <code>substr</code> 第一次出现的位置。</li><li><strong><code>.rfind(substr, pos)</code></strong>: 从位置 <code>pos</code> 开始，反向查找 <code>substr</code> 第一次出现的位置。</li><li><strong><code>.find_first_of(chars, pos)</code></strong>: 查找 <code>chars</code> 中任意一个字符第一次出现的位置。</li><li><strong><code>.find_last_of(chars, pos)</code></strong>: 查找 <code>chars</code> 中任意一个字符最后一次出现的位置。</li><li><strong><code>.find_first_not_of(chars, pos)</code></strong>: 查找第一个不属于 <code>chars</code> 中任意一个字符的位置。</li><li><strong><code>.find_last_not_of(chars, pos)</code></strong>: 查找最后一个不属于 <code>chars</code> 中任意一个字符的位置。</li><li><strong><code>.substr(pos, count)</code></strong>: 提取从位置 <code>pos</code> 开始，长度为 <code>count</code> 的子字符串。</li><li><strong><code>.compare(other_str)</code></strong>: 按字典序比较两个字符串。</li></ul><h3 id="5-迭代器-Iterators"><a href="#5-迭代器-Iterators" class="headerlink" title="5. 迭代器 (Iterators)"></a>5. 迭代器 (Iterators)</h3><ul><li><strong><code>.begin()</code> &#x2F; <code>.cbegin()</code></strong>: 返回指向字符串头部的迭代器。</li><li><strong><code>.end()</code> &#x2F; <code>.cend()</code></strong>: 返回指向字符串尾部之后位置的迭代器。</li><li><strong><code>.rbegin()</code> &#x2F; <code>.crbegin()</code></strong>: 返回指向字符串尾部的反向迭代器。</li><li><strong><code>.rend()</code> &#x2F; <code>.crend()</code></strong>: 返回指向字符串头部之前位置的反向迭代器。</li></ul><p><a href="https://kamacoder.com/problempage.php?pid=1064">原题链接</a></p><h3 id="54-替换数字（第八期模拟笔试）"><a href="#54-替换数字（第八期模拟笔试）" class="headerlink" title="54. 替换数字（第八期模拟笔试）"></a>54. 替换数字（第八期模拟笔试）</h3><p>替换数字，涉及到数组扩容，我们可以先扩容然后从后往前填充。这也是常用做法。具体是一个指针从原字符串末尾往左走，另一个字符串从扩容后的字符串末尾往左走。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (cin &gt;&gt; s)<br></code></pre></td></tr></table></figure><p>这里cin一次输入一个字符串（而不是一个字符），检测到空格停止输入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">s.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">5</span> * count);<br></code></pre></td></tr></table></figure><p><code>.resize()</code>函数。</p><h3 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a>151. 反转字符串中的单词</h3><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">原题链接</a></p><p>分三步，首先把字符串全部反转，再去除多余空格，最后把每个单词反转。这里去除空格的逻辑容易搞错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (start &lt; end)<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(s[start++], s[end--]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之前写过的反转字符串函数，可以接收输入反转的起点和终点，即将字符串的[start, end]闭区间反转。<strong>不过后面不要求自己写的话可以直接调用algorithm中的reverse函数</strong>，接受两个迭代器输入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteSpace</span><span class="hljs-params">(string &amp;s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> fast = <span class="hljs-number">0</span>; fast &lt; s.<span class="hljs-built_in">size</span>(); fast ++)&#123;<br>        <span class="hljs-keyword">if</span> (s[fast] != <span class="hljs-string">&#x27; &#x27;</span>)&#123; <br>            <span class="hljs-keyword">if</span> (slow != <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//排除开头第一个单词的情况</span><br>                s[slow++] = <span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(fast &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[fast] != <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                s[slow++] = s[fast++];<br>            &#125;<br>        &#125;<br>    &#125;<br>    s.<span class="hljs-built_in">resize</span>(slow);<br>&#125;<br></code></pre></td></tr></table></figure><p>消除多余空格的函数，从三个角度考虑：消除开头的空格，消除单词间的空格，消除末尾的空格。<br><code>if (s[fast] != &#39; &#39;)</code>当检查到字母再进行后续程序。当条件成立说明找到了单词，<code>slow</code>指针添加一个空格，再进入后续循环。<br>特别要想清楚处理完成后字符串的长度是多少。因为slow指针在存放完最后一个单词的最后一个字母后又右移了一位，所以指向的是<code>s.size()</code>，所以<code>s.resize(slow)</code></p><h3 id="55-右旋转字符串（卡玛）"><a href="#55-右旋转字符串（卡玛）" class="headerlink" title="55. 右旋转字符串（卡玛）"></a>55. 右旋转字符串（卡玛）</h3><p><a href="https://kamacoder.com/problempage.php?pid=1065">原题链接</a></p><p>先整体反转，再分别反转。</p><p>KMP算法，要在文本串中查找特定的模式串。因为我们肯定是在文本串中顺序比对的，当匹配到一半发现有不一样的字符之后本来要重新从第二个字符开始匹配。显然会浪费大量时间。由于我们之前的匹配过程中已经得到了部分文本串的信息，比如要在”aabaabaafa”中查找“aabaaf”,文本串第六个字符处失配，对应模式串第六个字符。由于我们已经匹配了模式串的前五个字符了，为了避免再从头开始匹配模式串，可以比较一下模式串的前缀和后缀的区别。例如这里匹配上的前五个字符有相同前后缀“aa”，这意味着文本串匹配模式串第四五个字符的同时，也匹配了前两个字符。这样一来碰到第六个失配字符，可以移动到上一步匹配好的第四五个字符进行下一次迭代。即文本串的第四五个字符匹配上了模式串的第一二个字符，然后开始比对下一个字符。</p><p><img src="https://cdn.jsdelivr.net/gh/HRbenY/blog-assets@master//img/20260117145504169.png" alt="KMP算法"></p><p>KMP算法中next数组是实现上述过程的重要变量。数组中存放着模式串各字符的最大相等前后缀 - 1，比如在这个例子中”aabaaf”的第六个元素next[5]&#x3D;2-1,即最大相等前后缀2，减一代表对应的字符串索引。这样一来next[5]就告诉了程序当碰到第六个元素刚好失配时指针应该去哪里（第二个元素）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>    <span class="hljs-keyword">while</span> ((j != <span class="hljs-number">-1</span>) &amp;&amp; (s[i] != s[j + <span class="hljs-number">1</span>]))<br>    &#123;<br>        j = next[j];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s[i] == s[j + <span class="hljs-number">1</span>])<br>    &#123;<br>        j++;<br>    &#125;<br>    next[i] = j;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是计算next数组的函数，从s[1]开始计算依次next数组，next[0]赋值-1。while循环代表前后缀不匹配时的迭代过程。j &#x3D; next[j]是最关键的步骤，意味着当前后缀在j+1处失配时，又调用了之前计算的部分next数组进行高效的回退。可以想象成这里吧某个长度的后缀当作文本串，相等长度的前缀当成模式串进行匹配。理所当然可以利用已经计算好的next数组。</p>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2026/01/23/obsidian/cpp/Notes/7.Tree/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2026/01/23/obsidian/cpp/Notes/7.Tree/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="前中后序遍历"><a href="#前中后序遍历" class="headerlink" title="前中后序遍历"></a>前中后序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">前序</a><br><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">中序</a><br><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/">后序</a></p><h4 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h4><p>递归写法的话，只有Traversal函数中的顺序不同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br><span class="hljs-built_in">Traversal</span> (cur-&gt;left, res);<br><span class="hljs-built_in">Traversal</span> (cur-&gt;right, res);<br></code></pre></td></tr></table></figure><p>这是前序的写法，是什么序就把push操作放在哪个位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(vector&lt;string&gt; &amp;res, string path, TreeNode* Node)</span></span>&#123;<br>    path += <span class="hljs-built_in">to_string</span>(Node-&gt;val);<br>    <span class="hljs-keyword">if</span>((Node-&gt;left == <span class="hljs-literal">nullptr</span>) &amp;&amp; (Node-&gt;right == <span class="hljs-literal">nullptr</span>))&#123;<br>        res.<span class="hljs-built_in">push_back</span>(path);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(Node-&gt;left)&#123;<br>        <span class="hljs-built_in">traversal</span>(res, path + <span class="hljs-string">&quot;-&gt;&quot;</span>, Node-&gt;left);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(Node-&gt;right)&#123;<br>        <span class="hljs-built_in">traversal</span>(res, path + <span class="hljs-string">&quot;-&gt;&quot;</span>, Node-&gt;right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>题257的简化递归写法，有两个细节：</p><ul><li><code>traversal</code>函数接收的<code>path</code>输入不带<code>&amp;</code>，说明每次调用时都会创建一个新的<code>path</code>副本，事实上实现了<code>path</code>的回溯操作。因为当前traversal函数执行完毕回到上一层后path也回到上一层的值了。</li><li>调用<code>traversal</code>函数时<code>path + &quot;-&gt;&quot;</code>作为一整个参数传入。也是为了<code>path</code>的回溯，这样执行结束之后不影响上一层循环的<code>path</code>值。</li></ul><blockquote><p><strong>递归三要素</strong><br><strong>1.确定递归函数的参数和返回值</strong>： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</p><p><strong>2.确定终止条件</strong>： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</p><p><strong>3.确定单层递归的逻辑</strong>： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p></blockquote><h4 id="迭代写法"><a href="#迭代写法" class="headerlink" title="迭代写法"></a>迭代写法</h4><p>普通的迭代写法三种都不一样，不过前序和后序写法比较类似。中序的普通迭代法比较难写出来。因为对于中序遍历来说，访问到了某一个节点并不一定要立刻处理，而是要先处理其所有左子树。所以需要一个标识来表示某节点的左子树全部处理完成了。这里用空指针表示下一个节点处理完成可以Push_back到结果数组中。<br>空指针表示的迭代法对于前中后三种遍历方式的形式都是很相似的，所以称为统一迭代法。  </p><ul><li><strong>中序</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>    cur = st.<span class="hljs-built_in">top</span>();<br>    <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">nullptr</span>)&#123;<br>        st.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(cur-&gt;right)st.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        st.<span class="hljs-built_in">push</span>(cur);<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-keyword">if</span>(cur-&gt;left)st.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        st.<span class="hljs-built_in">pop</span>();<br>        res.<span class="hljs-built_in">push_back</span>(st.<span class="hljs-built_in">top</span>()-&gt;val);<br>        st.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是中序遍历的统一迭代法。要注意的是，叶子节点也是左子树全部处理完毕的节点，所以逻辑可以整合到一起。整个代码运行过程就像：如果当前节点不是空节点，就按照右中null左的顺序重新入栈。一旦访问到空指针，说明下一个节点处理完成，可以存入数组中。前序、中序和后序只在if中的语句顺序不同。</p><ul><li><strong>前序</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">nullptr</span>)&#123;<br>    st.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span>(cur-&gt;right)st.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>    <span class="hljs-keyword">if</span>(cur-&gt;left)st.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>    st.<span class="hljs-built_in">push</span>(cur);<br>    st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>后序</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">nullptr</span>)&#123;<br>    <span class="hljs-comment">//st.pop();</span><br>    <span class="hljs-comment">//st.push(cur);这两行抵消了。</span><br>    st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-keyword">if</span>(cur-&gt;right)st.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>    <span class="hljs-keyword">if</span>(cur-&gt;left)st.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">102.二叉树的层序遍历</a><br><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/">107.二叉树的层序遍历II</a><br><a href="https://leetcode.cn/problems/binary-tree-right-side-view/description/">199.二叉树的右视图</a><br><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/">637.二叉树的层平均值</a></p><p>层序遍历，即从上往下一层一层遍历。适合使用队列。具体操作是在对新的一层进行遍历之前，存储queue大小size，代表这层的节点数量。然后把这size个节点分别求左右孩子，插入到队列尾部。遍历完成后当前的queue就变成了下一层的节点了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> result;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; row;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                row.<span class="hljs-built_in">push_back</span>(que.<span class="hljs-built_in">front</span>()-&gt;val);<br>                <span class="hljs-keyword">if</span> (que.<span class="hljs-built_in">front</span>()-&gt;left)<br>                    que.<span class="hljs-built_in">push</span>(que.<span class="hljs-built_in">front</span>()-&gt;left);<br>                <span class="hljs-keyword">if</span> (que.<span class="hljs-built_in">front</span>()-&gt;right)<br>                    que.<span class="hljs-built_in">push</span>(que.<span class="hljs-built_in">front</span>()-&gt;right);<br>                que.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            result.<span class="hljs-built_in">push_back</span>(row);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h3><p><a href="https://leetcode.cn/problems/symmetric-tree/description/">原题链接</a></p><p>不难发现，一颗二叉树为对称二叉树的判断条件是根节点的左右子树对称，而左右子树对称的判断条件是左子树的左子树与右子树的右子树对称，左子树的右子树与右子树的左子树对称。于是就发现了递归点：在想判断二叉树的对称条件时，与其子树的对称条件有关系。</p><h3 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222.完全二叉树的节点个数"></a>222.完全二叉树的节点个数</h3><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/description/">原题链接</a></p><p>跟<a href="#101%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91">对称二叉树</a>一样，因为当前节点作为根的二叉树的节点个数与左右孩子的二叉树的节点个数有关，所以可以使用递归。<br>层序遍历也可以。</p><h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110.平衡二叉树"></a>110.平衡二叉树</h3><p><a href="https://leetcode.cn/problems/balanced-binary-tree/description/">原题链接</a></p><p>这里聊一下二叉树的高度和深度。leetcode和wiki并未达成共识，我们按照leet的标准，叶子节点的高度为1，根节点的高度取左右子树计算得高度的较大值。比如这里左侧2节点的高度应为3。计算高度时，因为遍历到当前节点时并不知道下面还有多少节点，所以适合采用后序遍历，从下往上计数。计算深度则前序或层序遍历，从上往下就行。<br><img src="https://cdn.jsdelivr.net/gh/HRbenY/blog-assets@master//img/20260117145547528.png" alt="平衡二叉树"></p><h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257.二叉树的所有路径"></a>257.二叉树的所有路径</h3><p><a href="https://leetcode.cn/problems/binary-tree-paths/description/">原题链接</a></p><p>初次接触回溯算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(vector&lt;string&gt; &amp;result, vector&lt;TreeNode*&gt; &amp;path, TreeNode* cur)</span></span>&#123;<br>        path.<span class="hljs-built_in">push_back</span>(cur);<br>        <span class="hljs-keyword">if</span>((cur-&gt;left == <span class="hljs-literal">nullptr</span>) &amp;&amp; (cur-&gt;right == <span class="hljs-literal">nullptr</span>))&#123;<br>            string res;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; Node : path)&#123;<br>                res += <span class="hljs-built_in">to_string</span>(Node-&gt;val);<br>                res += <span class="hljs-string">&quot;-&gt;&quot;</span>;<br>            &#125;<br>            res.<span class="hljs-built_in">resize</span>(res.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>);<br>            result.<span class="hljs-built_in">push_back</span>(res);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;left)&#123;<br>                <span class="hljs-built_in">traversal</span>(result, path, cur-&gt;left);<br>                path.<span class="hljs-built_in">pop_back</span>();<br>                <br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur-&gt;right)&#123;<br>                <span class="hljs-built_in">traversal</span>(result, path, cur-&gt;right);<br>                path.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h3><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/description/">原题链接</a></p><p>这几道题的递归方式都比较像。都是当前节点为空作为结束条件，递归体现在当前节点的左右孩子调用递归函数。</p><p>第一次写完这题报了个错，下面这两行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">node-&gt;left = <span class="hljs-built_in">mt</span>(root1-&gt;left, root2-&gt;left);<br>node-&gt;right = <span class="hljs-built_in">mt</span>(root1-&gt;right, root2-&gt;right);<br></code></pre></td></tr></table></figure><p>由于传入的root1和root2可能是空指针，这里可能出现访问空指针的错误。后来采用if分了三种情况。root1和root2有一个nullptr时，直接把另一个加入合并树就可以不用管了。</p><h3 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700.二叉搜索树中的搜索"></a>700.二叉搜索树中的搜索</h3><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/description/">原题链接</a></p><p>由于题目是二叉搜索树，而二叉搜索树有个特性是root的左孩子更小，右孩子更大。据此可以很简单地写出迭代逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(cur-&gt;val &gt; val)cur = cur-&gt;left;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur-&gt;val &lt; val)cur = cur-&gt;right;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> cur;<br></code></pre></td></tr></table></figure><p>要注意，当当前节点<code>cur-&gt;val</code>比目标值大时要往左走。这里我写反过。</p><h3 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a>701. 二叉搜索树中的插入操作</h3><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/">原题链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(val &gt; root-&gt;val)root-&gt;right = <span class="hljs-built_in">insertIntoBS</span>(root-&gt;right, val);<br><span class="hljs-keyword">if</span>(val &lt; root-&gt;val)root-&gt;left = <span class="hljs-built_in">insertIntoBS</span>(root-&gt;left, val);<br></code></pre></td></tr></table></figure><p>用了一个比较巧妙的方法，用递归函数返回值完成新加入节点的父子关系复制操作。<strong>下一层将加入节点返回，本层用root-&gt;left或者root-&gt;right将其接住。</strong></p><h3 id="405-二叉搜索树的删除操作"><a href="#405-二叉搜索树的删除操作" class="headerlink" title="405. 二叉搜索树的删除操作"></a>405. 二叉搜索树的删除操作</h3><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/description/">原题链接</a></p><p>与上题类似，也可以用递归函数返回值处理。<br>搜索树的删除操作，难点在当前节点左右子树都不为空的情况下。可以把左子树直接接到右子树最左节点的左边。这样跟原来的树是等价的，就把条件转换成了只有右子树的情况。</p><h3 id="669-修建二叉搜索树"><a href="#669-修建二叉搜索树" class="headerlink" title="669. 修建二叉搜索树"></a>669. 修建二叉搜索树</h3><p><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/description/">原题链接</a></p><p>简单的迭代，考虑清楚当前节点在范围外的情形就行。</p><p>今后注意如果使用迭代法，务必记住除了当前节点不存在可以返回<code>nullptr</code>，其他情况要谨慎<code>return</code>明确的值（比如<code>return root-&gt;left</code>）,大部分情况下都要<code>return(trimBST(root-&gt;left, low, high))</code> 这样的迭代形式。</p><h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h3><p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">原题链接</a></p><p>取中点作为新的根，其左孩子为vector左侧的中点，右孩子作为vector右侧的中点，递归就可以了。这里有几点语法要注意。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> it&gt;<br><span class="hljs-function">TreeNode* <span class="hljs-title">sa2BST</span><span class="hljs-params">(it begin, it end)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(begin == end)<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    it mid = begin + <span class="hljs-built_in">distance</span>(begin, end)/<span class="hljs-number">2</span>;<br>    TreeNode* Node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(*mid);<br>    Node-&gt;left = <span class="hljs-built_in">sa2BST</span>(begin, mid);<br>    Node-&gt;right = <span class="hljs-built_in">sa2BST</span>(mid + <span class="hljs-number">1</span>, end);<br>    <span class="hljs-keyword">return</span> Node;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>模版声明<code>template &lt;typename it&gt;</code>。<br>如果不用模版声明，这个<code>sa2BST</code>函数的传入参数需要指定<code>iterator</code>的类型，比如<code>std::vector&lt;int&gt;</code>使得sa2BST无法接受其他的比如<code>std::vector&lt;double&gt;::iterator</code>的输入。比较死板。加上模版声明实际上是定义了一个类型占位符，名称叫<code>it</code>，意味着<code>sa2BST</code>函数实际上需要两个<code>it</code>类型的输入。当调用<code>sa2BST</code>的时候，编译器会自动将模版中定义的占位符<code>it</code>全部替换成具体的类型(这里是<code>std::vector&lt;int&gt;::iterator</code>)。使得函数可以兼容不同的<code>iterator</code>。</li><li>迭代器操作。<br>要记住，迭代器本质上还是指针，访问值的时候需要解引用(*mid)。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>binary-tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯</title>
    <link href="/2026/01/23/obsidian/cpp/Notes/8.backTracking/%E5%9B%9E%E6%BA%AF/"/>
    <url>/2026/01/23/obsidian/cpp/Notes/8.backTracking/%E5%9B%9E%E6%BA%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，是的，所有回溯法的问题都可以抽象为树形结构！</p><p>因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度就构成了树的深度。(见<a href="image.png">77</a>)</p><p>回溯跟递归是不分家的，回溯也有传入参数和返回值、终止条件、每层逻辑三要素。通用模版如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通常回溯法需要遍历所有可能性，因此返回参数一般为void。</p><h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77.组合"></a>77.组合</h3><p><a href="https://leetcode.cn/problems/combinations/description/">原题链接</a></p><p><img src="https://cdn.jsdelivr.net/gh/HRbenY/blog-assets@master//img/20260117145556494.png" alt="77"></p><p>for循环是在每层内横向遍历，递归调用则是纵向遍历。第一层可以从所有的数字中选取一个，用for循环选取。在for循环中调用自身进行递归，在选取了一个数字的条件下进行深入遍历，这样在递归中的另外一层for循环就选好了第二个数字。<br>由于组合是没有顺序的，第一层选过某一个数字之后不再取，所以还需要传入startIndex参数来控制for循环的起始位置。<br>这样基本的逻辑就完成了。进一步进行剪枝，当当前循环剩下数字的个数小于需要的个数的时候，可以立马判断没有符合条件的组合，直接退出for循环。如下：</p><ul><li>当前已选：<code>path.size()</code> </li><li>还需选:<code>k - path.size()</code></li><li>剩下的数字个数:<code>n - i + 1</code><br>所以有<code>n - i + 1 &gt;=  k - path.size()</code><br>代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= n + path.<span class="hljs-built_in">size</span>() - k + <span class="hljs-number">1</span>; i ++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">backtracking</span>(n, k, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h3><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">原题链接</a></p><p>本题for循环的用途是遍历一个数字所对应的所有字母，递归则是在遍历所有数字。回溯的是数字的编号。关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> unordered_map&lt;<span class="hljs-type">int</span>, string&gt; digitsMap = &#123;<br>    &#123;<span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>&#125;,    &#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;&quot;</span>&#125;,    &#123;<span class="hljs-number">2</span>, <span class="hljs-string">&quot;abc&quot;</span>&#125;,  &#123;<span class="hljs-number">3</span>, <span class="hljs-string">&quot;def&quot;</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-string">&quot;ghi&quot;</span>&#125;,<br>    &#123;<span class="hljs-number">5</span>, <span class="hljs-string">&quot;jkl&quot;</span>&#125;, &#123;<span class="hljs-number">6</span>, <span class="hljs-string">&quot;mno&quot;</span>&#125;, &#123;<span class="hljs-number">7</span>, <span class="hljs-string">&quot;pqrs&quot;</span>&#125;, &#123;<span class="hljs-number">8</span>, <span class="hljs-string">&quot;tuv&quot;</span>&#125;, &#123;<span class="hljs-number">9</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;,<br>&#125;;<br>vector&lt;string&gt; result;<br>string str;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span> Index, <span class="hljs-type">const</span> string &amp;digits)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (Index == digits.<span class="hljs-built_in">size</span>()) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(str);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        string tmp = digitsMap.<span class="hljs-built_in">at</span>(<span class="hljs-built_in">int</span>(digits.<span class="hljs-built_in">at</span>(Index) - <span class="hljs-string">&#x27;0&#x27;</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tmp.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            str.<span class="hljs-built_in">push_back</span>(tmp[i]);<br>            <span class="hljs-built_in">backTracking</span>(Index + <span class="hljs-number">1</span>, digits);<br>            str.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>由于要存储每个数字对应的字母，这里使用哈希表存储键值对。回溯函数接受Index表示当前是第Index个数字，和digits表示接受的用户输入。</p><h3 id="40-组合总和II"><a href="#40-组合总和II" class="headerlink" title="40.组合总和II"></a>40.组合总和II</h3><p><a href="https://leetcode.cn/problems/combination-sum-ii/description/">原题链接</a></p><p>这题的难点在于要做去重操作。由于candidate中可能有重复的元素，因此在每个for循环中都需要去除重复的情况。为了方便判断，首先要对candidate进行排序。再判断相邻元素的相等情况。具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backTracking</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(target &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span> (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>])<span class="hljs-keyword">continue</span>;<br>            path.<span class="hljs-built_in">push_back</span>(candidates.<span class="hljs-built_in">at</span>(i));<br>            <span class="hljs-built_in">backTracking</span>(candidates, target - candidates.<span class="hljs-built_in">at</span>(i), i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>首先，由于元素不能重复选取，递归调用中<code>backTracking(candidates, target - candidates.at(i), i + 1);</code>中startIndex要+1。  </p><p>然后进行每层的去重。注意这里的逻辑是<code>if (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - 1])continue;</code>除了判断当前的编号<code>candidate[i]</code>和前一个遍历的编号<code>candidate[i-1]</code>相等以外，还要<strong>确保前一个<code>candidate</code>是本层遍历过的</strong>。比如1 1 2，取两个元素，第一层1，第二层1。第二层的1跟上个数字<code>candidate[i-1]</code>相等，但是上一个1是上一层遍历的，本层根本不会遍历到他。使用<code>i &gt; startIndex</code>确保从本层第二个元素开始判断去重。</p><h3 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h3><p><a href="https://leetcode.cn/problems/palindrome-partitioning/description/">原题链接</a></p><p>还需要写一个判断是否回文的函数。这个函数最好能接受字符串和起止点输入。方便循环中切割子字符串后判断。具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i ++, j --)&#123;<br>            <span class="hljs-keyword">if</span>(s[i] != s[j])<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    vector&lt;vector&lt;string&gt;&gt; result;<br>    vector&lt;string&gt; vec;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backTracking</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (startIndex == s.<span class="hljs-built_in">size</span>())&#123;<br>            result.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isPalindrome</span>(s, startIndex, i))&#123;<br>                vec.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">substr</span>(startIndex, i - startIndex + <span class="hljs-number">1</span>));<span class="hljs-comment">//注意细节</span><br>                <span class="hljs-built_in">backTracking</span>(s, i + <span class="hljs-number">1</span>);<br>                vec.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>与之前不同的是，只有当当前层切出一个回文串才能进入递归，判断下一层。否则接着continue，继续延长。</p><h3 id="93-复原ip地址"><a href="#93-复原ip地址" class="headerlink" title="93.复原ip地址"></a>93.复原ip地址</h3><p><a href="https://leetcode.cn/problems/restore-ip-addresses/description/">原题链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;string&gt; result;<br>    vector&lt;string&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (end - start &gt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">stoi</span>(s.<span class="hljs-built_in">substr</span>(start, end - start + <span class="hljs-number">1</span>)) &gt; <span class="hljs-number">255</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//注意要先验证子串长度，以免溢出INT_MAX</span><br>        <span class="hljs-keyword">if</span> (end &gt; start &amp;&amp; s[start] == <span class="hljs-string">&#x27;0&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//注意是&#x27;0&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backTracking</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == <span class="hljs-number">4</span>)&#123;<br>            <span class="hljs-keyword">if</span>(startIndex == s.<span class="hljs-built_in">size</span>())&#123;<br>                string ip = path[<span class="hljs-number">0</span>] + <span class="hljs-string">&#x27;.&#x27;</span> + path[<span class="hljs-number">1</span>] + <span class="hljs-string">&#x27;.&#x27;</span> + path[<span class="hljs-number">2</span>] + <span class="hljs-string">&#x27;.&#x27;</span> + path[<span class="hljs-number">3</span>];<br>                result.<span class="hljs-built_in">push_back</span>(ip);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s, startIndex, i))&#123;<br>                path.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">substr</span>(startIndex, i - startIndex + <span class="hljs-number">1</span>));<br>                <span class="hljs-built_in">backTracking</span>(s, i + <span class="hljs-number">1</span>);<br>                path.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这题我犯了很多小错误，总结列举出来。</p><ul><li>在 <code>backTracking</code> 函数的递归调用中，使用了 <code>backTracking(s, startIndex + 1)</code>。<code>startIndex</code> 代表当前选择的起点，而 <code>i</code> 代表当前选择的终点。当一段 <code>[startIndex, i]</code> 被选定后，下一段的选择应该从 <code>i + 1</code> 开始，而不是 <code>startIndex + 1</code> </li><li>最初我定义了一个nums来存储当前分出了几个数字。其实用path.size()就可以了。</li><li>在 isValid 函数中，写了 <code>s[start] == 0</code> 来判断前导零。这里<code>s[start]</code>是char类型，所以要判断 <code>s[start] == ‘0’ </code>这是一个非常容易搞错的点，一定要注意，<strong>字符类型的数字判断大小也要和字符类型比较。</strong></li><li>在<code>stoi</code>调用中,<code>if (stoi(s.substr(start, end - start + 1)) &gt; 255)</code>可能会出现转换之后的大小超过int存储范围。所以这里要先判断转换后的位数是不是在三位以内。</li></ul><h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a>78.子集</h3><p><a href="https://leetcode.cn/problems/subsets/description/">原题链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backTracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span> </span>&#123;<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">if</span> (startIndex == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backTracking</span>(nums, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>非常经典的子集问题，可以与组合问题<a href="#77%E7%BB%84%E5%90%88">77.组合</a>相比较。</p><ul><li>收集时机，子集在每个节点都收集结果，因为每次遍历都能得到新的合法子集。而组合只在叶子节点收集结果，因为组合问题必须要把所有元素全部分好才能输出一个结果。</li></ul><h3 id="491-非递减子序列"><a href="#491-非递减子序列" class="headerlink" title="491.非递减子序列"></a>491.非递减子序列</h3><p><a href="https://leetcode.cn/problems/non-decreasing-subsequences/description/">原题链接</a></p><p>这题坑很多，主要是三个问题。首先不能排序，其次要判断path是否递增，最后去重逻辑与之前的都不一样。代码图下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backTracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(startIndex &gt; nums.<span class="hljs-built_in">size</span>())<span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">2</span>)&#123;<br>                result.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; usedNums;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">if</span>(!path.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &lt; path.<span class="hljs-built_in">back</span>())<span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(usedNums.<span class="hljs-built_in">count</span>(nums[i]))<span class="hljs-keyword">continue</span>;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            usedNums.<span class="hljs-built_in">insert</span>(nums[i]);<br>            <span class="hljs-built_in">backTracking</span>(nums, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findSubsequences</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backTracking</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>为什么不能排序？题目要求的是整数数组的所有不同递增子序列，可能原数组是递减的，排序会破坏元素关系。</li><li>既然不能排序，那就要在函数里手动判断path是否是递增的。只有当下一个元素比path的末尾元素更大才加入到path中，并再次基础上进行递归。否则直接continue。</li><li>也是由于不能排序，去重逻辑跟之前的也不一样。像上面的<a href="#40%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Cii">40.组合总和II</a>或<a href="https://leetcode.cn/problems/subsets-ii/description/">90.子集II</a>是可以先排序再通过相邻元素的大小关系去重的。这里只能通过哈希表去重。</li></ul><h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h3><p><a href="https://leetcode.cn/problems/permutations/description/">原题链接</a></p><p>全排列问题，跟子集、子序列等的不同点在于全排列每层的for循环都要遍历剩下的所有元素，所以需要一个used数组来存储每个元素的选用状态。而子集和子序列由于其无序性，为了避免重复只允许向后选择。</p><p>简单来说，<strong>used 数组是为了解决“元素可重用但不可复选”的问题，而 startIndex 是为了解决“元素不可重用且不可复选”的去重问题。</strong></p><p>了解了这点不同全排列的代码也比较好写了。如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backTracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, vector&lt;<span class="hljs-type">bool</span>&gt; used)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>())&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">if</span>(used[i])<span class="hljs-keyword">continue</span>;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backTracking</span>(nums, used);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backTracking</span>(nums, used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="47-全排列II"><a href="#47-全排列II" class="headerlink" title="47.全排列II"></a>47.全排列II</h3><p><a href="https://leetcode.cn/problems/permutations-ii/description/">原题链接</a></p><p>在<a href="#46%E5%85%A8%E6%8E%92%E5%88%97">上一题</a>的基础上要求排列不能重复。所以在used标记的基础上加上去重逻辑，用unordered_set记录一层内已经选用过的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backTracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, vector&lt;<span class="hljs-type">bool</span>&gt;used)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>())&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; uset;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">if</span>(used[i])<span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(uset.<span class="hljs-built_in">count</span>(nums[i]))<span class="hljs-keyword">continue</span>;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            uset.<span class="hljs-built_in">insert</span>(nums[i]);<br>            <span class="hljs-built_in">backTracking</span>(nums, used);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332.重新安排行程"></a>332.重新安排行程</h3><p><a href="https://leetcode.cn/problems/reconstruct-itinerary/description/">原题链接</a></p><p>下面是我写的，效率太低了。整体思想是到达一个机场后，遍历所有机票找能用的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;string&gt; result;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backTracking</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets, vector&lt;<span class="hljs-type">bool</span>&gt; &amp;used)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(result.<span class="hljs-built_in">size</span>() == tickets.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tickets.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">if</span>(used[i] || tickets[i][<span class="hljs-number">0</span>] != result.<span class="hljs-built_in">back</span>())<span class="hljs-keyword">continue</span>;<br>            result.<span class="hljs-built_in">push_back</span>(tickets[i][<span class="hljs-number">1</span>]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">backTracking</span>(tickets, used))<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            result.<span class="hljs-built_in">pop_back</span>();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        result.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;JFK&quot;</span>);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(tickets.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">sort</span>(tickets.<span class="hljs-built_in">begin</span>(), tickets.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backTracking</span>(tickets, used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>实际上应该在最开始建立机场之间的映射表。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;string, multiset&lt;string&gt;&gt; map;<br>    vector&lt;string&gt; result;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backTracking</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;cur)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(!map[cur].<span class="hljs-built_in">empty</span>())&#123;<br>            string next = *map[cur].<span class="hljs-built_in">begin</span>();<br>            map[cur].<span class="hljs-built_in">erase</span>(map[cur].<span class="hljs-built_in">begin</span>());<br>            <span class="hljs-built_in">backTracking</span>(next);<br>        &#125;<br>        result.<span class="hljs-built_in">push_back</span>(cur);<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        map.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;i : tickets)&#123;<br>            map[i[<span class="hljs-number">0</span>]].<span class="hljs-built_in">insert</span>(i[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-built_in">backTracking</span>(<span class="hljs-string">&quot;JFK&quot;</span>);<br>        <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span>(result);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>有些细节：</p><ul><li>在销毁使用过的机票<code>map[cur].erase(map[cur].begin());</code>时，必须像这样销毁指定的<strong>一张</strong>机票。我错写成了<code>map[cur].erase(next);</code>,导致删除了所有跟next相等的机票，可能不止一张。</li><li>在传入常量时，即<code>backTracking(&quot;JFK&quot;);</code>必须保证函数接受的传入擦树也为常量，即要用<code>const</code>修饰。</li><li>在构建初始临接图时，用<code>map[i[0]].insert(i[1]);</code>而不是<code>map.insert({i[0],i[1]});</code>后者只适合<code>unordered_map&lt;string, string&gt;</code>的形式。</li></ul><p>这题用到的算法涉及图论，使用Hierholzer算法计算欧拉路径。这种算法的回溯方式跟之前的都不一样。无论是集合还是排列，这些问题的回溯都是要撤销之前的处理。但是Hierholzer算法不需要。因为此算法是从后往前得到结果。当遍历到死胡同，把死胡同输出后，并不需要撤销删除上一节点到死胡同的路径。而且正因为这条路径的删除，将上一节点变成了新的死胡同。即使还有其他路径可以遍历，最终还是会回到这个节点，然后被作为新死胡同加入结果集中。重复这个过程。所以Hierholzer的回溯实际上体现在递归调用回溯函数时的return操作上，说明此层已遍历完所有机票，回到了上一节点。Hierholzer算法如下</p><blockquote><h4 id="Hierholzer-算法核心笔记"><a href="#Hierholzer-算法核心笔记" class="headerlink" title="Hierholzer 算法核心笔记"></a><strong>Hierholzer 算法核心笔记</strong></h4><h5 id="1-算法定义与目标-目标-寻找图中的欧拉路径（遍历每条边一次）或欧拉回路（起点和终点相同的欧拉路径）。"><a href="#1-算法定义与目标-目标-寻找图中的欧拉路径（遍历每条边一次）或欧拉回路（起点和终点相同的欧拉路径）。" class="headerlink" title="1. 算法定义与目标 * 目标: 寻找图中的欧拉路径（遍历每条边一次）或欧拉回路（起点和终点相同的欧拉路径）。"></a><strong>1. 算法定义与目标</strong> * <strong>目标</strong>: 寻找图中的<strong>欧拉路径</strong>（遍历每条边一次）或<strong>欧拉回路</strong>（起点和终点相同的欧拉路径）。</h5><ul><li><strong>核心思想</strong>: <strong>逐步合并回路</strong>。通过深度优先搜索（DFS），找到并消耗路径，直到终点，然后回溯拼接所有子回路。</li></ul><h5 id="2-前提条件-无向图"><a href="#2-前提条件-无向图" class="headerlink" title="2. 前提条件  无向图:"></a><strong>2. 前提条件</strong>  <strong>无向图</strong>:</h5><ul><li><strong>回路</strong>: 图连通，所有顶点度数为偶数。  </li><li><strong>路径</strong>: 图连通，恰好有两个顶点度数为奇数。  </li><li><strong>有向图</strong>:  <ul><li><strong>回路</strong>: 图强连通，所有顶点的入度&#x3D;出度。  </li><li><strong>路径</strong>: 图连通，一个顶点出度-入度&#x3D;1（起点），一个顶点入度-出度&#x3D;1（终点），其余顶点入度&#x3D;出度。</li></ul></li></ul><h5 id="3-算法流程-DFS-实现-1-选择起点：从指定的起点开始（路径）或任意节点（回路）。"><a href="#3-算法流程-DFS-实现-1-选择起点：从指定的起点开始（路径）或任意节点（回路）。" class="headerlink" title="3. 算法流程 (DFS 实现) 1.  选择起点：从指定的起点开始（路径）或任意节点（回路）。"></a><strong>3. 算法流程 (DFS 实现)</strong> 1.  <strong>选择起点</strong>：从指定的起点开始（路径）或任意节点（回路）。</h5><ol start="2"><li><strong>循环探索</strong>：在当前节点的函数中，使用 <code>while</code> 循环，条件为当前节点仍有未访问的出边。  </li><li><strong>前进与消耗</strong>：</li></ol><ul><li>在循环中，选择下一条边通往 <code>next</code> 节点。  </li><li><strong>永久删除</strong>这条边，表示已访问。  </li><li>对 <code>next</code> 节点进行递归调用 <code>dfs(next)</code>。</li></ul><ol start="4"><li><strong>记录节点 (核心)</strong>：当 <code>while</code> 循环结束（表示当前节点的所有出边都已被探索完毕），将<strong>当前节点</strong>添加到结果列表的末尾。  </li><li><strong>输出</strong>：初始 <code>dfs</code> 调用结束后，将结果列表<strong>反转</strong>，即为最终的欧拉路径。</li></ol><h5 id="4-核心思想：“新死胡同”-算法的回溯是一种任务完成机制，而非状态恢复。"><a href="#4-核心思想：“新死胡同”-算法的回溯是一种任务完成机制，而非状态恢复。" class="headerlink" title="4. 核心思想：“新死胡同” * 算法的回溯是一种任务完成机制，而非状态恢复。"></a><strong>4. 核心思想：“新死胡同”</strong> * 算法的回溯是一种<strong>任务完成</strong>机制，而非状态恢复。</h5><ul><li>一个节点（例如 <code>P</code>）只有在<strong>所有</strong>从它出发的子路径都被完整探索后，它自身才成为一个“<strong>新死胡同</strong>”。  </li><li>由于欧拉图的性质，任何从 <code>P</code> 出发的子路径都必然是一个闭合的回路，最终会返回到 <code>P</code>。  </li><li><code>while</code> 循环确保了所有这些子回路都被消耗完毕。循环结束时，<code>P</code> 成为“新死胡同”，此时才可被记录到结果中。</li></ul><h5 id="5-力扣-332-题-重新安排行程-应用要点-问题映射-寻找从-“JFK”-出发的、按字典序最小的欧拉路径。"><a href="#5-力扣-332-题-重新安排行程-应用要点-问题映射-寻找从-“JFK”-出发的、按字典序最小的欧拉路径。" class="headerlink" title="5. 力扣 332 题 (重新安排行程) 应用要点 * 问题映射: 寻找从 “JFK” 出发的、按字典序最小的欧拉路径。"></a><strong>5. 力扣 332 题 (重新安排行程) 应用要点</strong> * <strong>问题映射</strong>: 寻找从 “JFK” 出发的、按字典序最小的欧拉路径。</h5><ul><li><strong>数据结构</strong>: <code>unordered_map&lt;string, multiset&lt;string&gt;&gt;</code>  <ul><li><code>unordered_map</code>: 按机场名快速索引。  </li><li><code>multiset</code>: 自动满足<strong>字典序最小</strong>的要求，并能处理<strong>重复机票</strong>。</li></ul></li><li><strong>边的消耗</strong>: 必须使用基于<strong>迭代器</strong>的 <code>erase</code> 来精确删除<strong>一张</strong>机票。  <ul><li><strong>正确</strong>: <code>map[cur].erase(map[cur].begin());</code>  </li><li><strong>错误</strong>: <code>map[cur].erase(next);</code> (这会删除所有目的地为 <code>next</code> 的机票)</li></ul></li><li><strong>最终代码结构</strong>: <code>dfs</code> 函数实现上述算法流程，主函数调用 <code>dfs(&quot;JFK&quot;)</code> 后，对结果进行 <code>reverse</code>。</li></ul></blockquote><h3 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51.N皇后"></a>51.N皇后</h3><p><a href="https://leetcode.cn/problems/n-queens/description/">原题链接</a><br>细节很多，最需要考虑的是怎么表示两条斜线。右斜线上的坐标之差相等，左斜线上的坐标之和相等。比如一行二列放下一个皇后，坐标(1,2)，其右对角线为所有列-行&#x3D;1的格子(比如2行3列，3行4列),右对角线为所有列+行&#x3D;3的格子(比如2行1列)。这样可以再定义两个bool数组，分别表示两条斜线。当当前格子和差与其中一条相等时说明处于斜线上。有个细节，因为右对角线的值范围为[1-n, n-1]，代码中要加一个n-1的偏置来保证索引为正。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">bool</span>&gt; &amp;used, vector&lt;<span class="hljs-type">bool</span>&gt; &amp;rban, vector&lt;<span class="hljs-type">bool</span>&gt; &amp;lban)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == n)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)&#123;<br>            <span class="hljs-keyword">if</span>(used[i] || rban[path.<span class="hljs-built_in">size</span>() - i + n - <span class="hljs-number">1</span>] || lban[path.<span class="hljs-built_in">size</span>() + i])<span class="hljs-keyword">continue</span>;<br><br>            used[i] = <span class="hljs-literal">true</span>;<br>            rban[path.<span class="hljs-built_in">size</span>() - i + n - <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>            lban[path.<span class="hljs-built_in">size</span>() + i] = <span class="hljs-literal">true</span>;<br>            path.<span class="hljs-built_in">push_back</span>(i);<span class="hljs-comment">//注意由于行数计算要用到path，这里在push之前的才是当前的行数。</span><br>            <span class="hljs-built_in">backTracking</span>(n, used, rban, lban);<br>            path.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//同样的，pop之后才是正确的行数</span><br>            used[i] = <span class="hljs-literal">false</span>;<br>            rban[path.<span class="hljs-built_in">size</span>() - i + n - <span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>            lban[path.<span class="hljs-built_in">size</span>() + i] = <span class="hljs-literal">false</span>;<br><br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">rban</span><span class="hljs-params">(<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">lban</span><span class="hljs-params">(<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backTracking</span>(n, used, rban, lban);<br>        vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">res</span>(result.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;string&gt;(n));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; result.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k ++)&#123;<br>                    <span class="hljs-keyword">if</span>(result[i][j] == k)res[i][j].<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;Q&#x27;</span>);<br>                    <span class="hljs-keyword">else</span> res[i][j].<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<br>                &#125;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意代码中的注释部分的细节。</p><h3 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37.解数独"></a>37.解数独</h3><p><a href="https://leetcode.cn/problems/sudoku-solver/description/">原题链接</a></p><p>一开始用的三个哈希表分别存储行、列、九宫格使用的数字，可以AC但是耗时耗空间。Gemini教我一种bitmask方法，用一个数组九位数上的bit来表示这个格子有没有被选取。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">short</span> xbit[<span class="hljs-number">9</span>];<br>    <span class="hljs-type">short</span> ybit[<span class="hljs-number">9</span>];<br>    <span class="hljs-type">short</span> bbit[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backTracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-type">int</span> xNext, yNext;<br>        <span class="hljs-keyword">if</span> (y == <span class="hljs-number">9</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        xNext = x + <span class="hljs-number">1</span>;<br>        yNext = y;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">9</span>)&#123;<br>            xNext = <span class="hljs-number">0</span>;<br>            yNext = y + <span class="hljs-number">1</span>;<br>        &#125; <br>        <span class="hljs-keyword">if</span>(board[y][x] != <span class="hljs-string">&#x27;.&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-built_in">backTracking</span>(board, xNext, yNext);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; i ++)&#123;<br>            <span class="hljs-type">int</span> mask = <span class="hljs-number">1</span> &lt;&lt; (i - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(xbit[x] &amp; mask || ybit[y] &amp; mask || bbit[y/<span class="hljs-number">3</span>][x/<span class="hljs-number">3</span>] &amp; mask)<span class="hljs-keyword">continue</span>;<span class="hljs-comment">//用&amp;而非&amp;&amp;</span><br>            xbit[x] |= mask;<br>            ybit[y] |= mask;<br>            bbit[y/<span class="hljs-number">3</span>][x/<span class="hljs-number">3</span>] |= mask;<br>            board[y][x] = i + <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">backTracking</span>(board, xNext, yNext))<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            xbit[x] ^= mask;<br>            ybit[y] ^= mask;<br>            bbit[y/<span class="hljs-number">3</span>][x/<span class="hljs-number">3</span>] ^= mask;<br>            board[y][x] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i ++)&#123;<br>            xbit[i] = <span class="hljs-number">0</span>;<br>            ybit[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i ++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j ++)&#123;<br>                bbit[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; <span class="hljs-number">9</span>; y ++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">9</span>; x ++)&#123;<br>                <span class="hljs-keyword">if</span>(board[y][x] == <span class="hljs-string">&#x27;.&#x27;</span>)<span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">int</span> num = board[y][x] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-type">int</span> mask = <span class="hljs-number">1</span> &lt;&lt; (num - <span class="hljs-number">1</span>);<br>                ybit[y] |= mask;<br>                xbit[x] |= mask;<br>                bbit[y/<span class="hljs-number">3</span>][x/<span class="hljs-number">3</span>] |= mask; <br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">backTracking</span>(board, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>首先是数组的预处理。<code>mask = 1 &lt;&lt; (num - 1)</code>计算出了当前格子数字对应的掩码。比如当前数字为3，则mask&#x3D;100。然后用位与操作将这个对应3的bit存入数组中。</p><p>在回溯函数中，注意注释的地方。这里用位操作判断数字是否重复，一定要用位与&amp;，不要用&amp;&amp;。<br>此外在数组的回溯过程中，注意代码用的异或。可以用一个例子感受一下。假设mask为100对应写入一个3。写完后数组变成101,那么要回溯的话直接找到mask和bit数组都为1的位就好了，把这位置零，就不难得出真值表了，正是异或的真值表。</p><p>我这里回溯函数接受的是格子的坐标，后序还可以优化成新建一个空格数组存放所有空格的坐标。</p>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>backtracking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2026/01/23/obsidian/cpp/Notes/2.ListNode/%E9%93%BE%E8%A1%A8/"/>
    <url>/2026/01/23/obsidian/cpp/Notes/2.ListNode/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p><p>链表的入口节点称为链表的头结点也就是head。</p><p><img src="https://cdn.jsdelivr.net/gh/HRbenY/blog-assets@master//img/20260117145443363.png" alt="链表结构"></p><p>在此基础上，每个节点新增一个指针域，一个指向下一个节点，一个指向上一个节点，就形成了双链表。</p><p><img src="https://cdn.jsdelivr.net/gh/HRbenY/blog-assets@master//img/20260117145443364.png" alt="双链表"></p><p>将单链表首尾相连，就是循环链表</p><p><img src="https://cdn.jsdelivr.net/gh/HRbenY/blog-assets@master//img/20260117145443365.png" alt="循环链表"></p><h2 id="链表的操作"><a href="#链表的操作" class="headerlink" title="链表的操作"></a>链表的操作</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单链表</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;  <span class="hljs-comment">// 节点上存储的元素</span><br>    ListNode* next;  <span class="hljs-comment">// 指向下一个节点的指针</span><br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;  <span class="hljs-comment">// 节点的构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>ListNode(int x)</code>函数的名字与结构名完全相同，这告诉编译器他是一个构造函数。<code>(int x)</code>是传参列表</p><p><code>val(x)</code> <code>next(NULL)</code>是初始化列表，C++独特的初始化成员变量的方式。这种赋值方式发生在函数体<code>{}</code>(这里为空)执行之前。</p><p>注意结构定义后要加分号。</p><p>值得注意的是，如果不定义构造函数，会生成一个默认构造函数，但是在初始化的时候不能给变量赋值。</p><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode* node0 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p><code>ListNode* node0</code>创建了一个指向ListNode类型的指针node0；<br><code>new ListNode(10)</code>使用<code>new</code>关键字在内存中创建了一个ListNode节点，并使用构造函数赋值为10；<br><code>=</code>号将新创建的链表节点地址赋值给了node0。</p><p>实际上，创建指针和创建节点可以分开来做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode* node0 = <span class="hljs-literal">NULL</span>;<br>node0 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>当像这样分开写时，通常是因为在声明指针时，还不知道它要指向哪个对象。</p><ul><li><code>ListNode* head;</code>: 这行代码只是在<strong>栈区</strong>（stack）声明了一个名为 <code>head</code> 的指针变量。此时，<code>head</code> 还没有被初始化，它里面存储的是一个不确定的、随机的内存地址（俗称“野指针”）。</li><li><code>head = new ListNode(10);</code>: 这行代码是在后续的某个时刻，才去动态地创建 <code>ListNode</code> 对象，并将它的地址赋给 <code>head</code>。</li></ul><h2 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h2><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h3><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">原题链接</a></p><p>两种方法，把头节点单独分析或创建一个虚拟头节点，剩下的所有节点都用同一个逻辑。</p><h4 id="直接判断"><a href="#直接判断" class="headerlink" title="直接判断"></a>直接判断</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (head != <span class="hljs-literal">NULL</span> &amp;&amp; head-&gt;val == val)&#123;<br>    ListNode* tmp = head;<br>    head = head-&gt;next;<br>    <span class="hljs-keyword">delete</span> tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>一般都要在操作之前判断当前节点是否为空，保证有意义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode* cur = head; <br><span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;next != <span class="hljs-literal">NULL</span>)&#123; <br>    <span class="hljs-keyword">if</span> (cur-&gt;next-&gt;val == val) &#123; <br>        ListNode* tmp = cur-&gt;next;<br>        cur-&gt;next = cur-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> tmp;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cur = cur-&gt;next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ListNode* cur = head</code>创建了一个指向当前操作节点的指针。<br><code>if (cur-&gt;next-&gt;val == val)</code>注意这里是判断<code>cur-&gt;next</code>节点的值，因为对于单链表来说无法回溯到上一个节点，如果直接判断当前节点的值的话就不好更改上一个节点的指向了。</p><h4 id="虚拟头节点"><a href="#虚拟头节点" class="headerlink" title="虚拟头节点"></a>虚拟头节点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode* DummyNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>DummyNode-&gt;next = head;<br></code></pre></td></tr></table></figure><p>创建虚拟头节点<code>DummyNode</code>，next指向给定链表的实际头节点。这样整个链表都可以用同一个逻辑处理了。</p><h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a>707. 设计链表</h3><p>题目要求实现的函数全部封装在一个class内。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">MyLinkedList *obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyLinkedList</span>();<br>obj-&gt;<span class="hljs-built_in">deleteAtIndex</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">delete</span> obj;<br>obj = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure><p>调用时使用<code>MyLinkedList *obj = new MyLinkedList()</code>是为了控制对象的生命周期。用指针形式使当前函数结束，这个对象也不会自动销毁，直到被手动释放。</p><p>创建<code>obj</code>对象后使用<code>-&gt;</code>访问其成员函数。  </p><p>obj使用完成后要完成两步删除，一是删除obj指向对象对应的内存空间，二是清除obj指针自身。因为delete不会清除指针本身。<strong>为了避免悬空指针问题最好在指针不用之后手动delete并置nullptr</strong>。</p><blockquote><p>关于<code>-&gt;</code>和<code>.</code>操作符，前者用于通过指针操作一个对象，等效于<code>(*pointer).member</code>，即先解指针，得到它指向的对象，再用点操作符访问其成员。后者用于直接访问对象实例的成员。</p><p>在C++中，对象实例存放在栈上，指向对象的指针存放在堆上</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (index--)<br>&#123;<br>    cur = cur-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><p>输入index，查询对应序号的节点。常将index–作为while循环的条件，循环次数是index次。</p><p>注意，<code>cur = cur-&gt;next;</code>不要写成<code>cur-&gt;next=cur-&gt;next-&gt;next</code>了，看似差不多，其实后者相当于删除了<code>cur-&gt;next</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> _size; <span class="hljs-comment">// 这里先不初始化</span><br>    ListNode *_DummyNode;<br></code></pre></td></tr></table></figure><p>由于各成员函数都需要访问和修改链表大小和虚拟头节点这两个变量，将它们设为私有，是为了确保只有这些被授权的成员函数才能安全地修改它们。</p><h3 id="206-翻转链表"><a href="#206-翻转链表" class="headerlink" title="206. 翻转链表"></a>206. 翻转链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode* cur = head;<br>ListNode* pre = <span class="hljs-literal">NULL</span>;<br>ListNode* tmp;<br></code></pre></td></tr></table></figure><p>这里注意不要直接把pre赋值为cur了，不然后续会出现死循环。</p><h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">原题链接</a></p><p>没什么好说的，注意在对节点操作的时候仔细一点。画个图一步一步走一下逻辑。</p><h3 id="19-删除链表的倒数第N个结点"><a href="#19-删除链表的倒数第N个结点" class="headerlink" title="19.删除链表的倒数第N个结点"></a>19.删除链表的倒数第N个结点</h3><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">原题链接</a></p><p>双指针法，因为要倒数第N个节点，正常想法是先遍历一遍找一共M个点，再遍历M-N次找到倒数第N个。这样的流程都可以简化到一个循环中，快指针先走N次，再同步前进。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(Fastptr-&gt;next != <span class="hljs-literal">nullptr</span>)&#123;<br>    Fastptr = Fastptr-&gt;next;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>    &#123;<br>        Slowptr = Slowptr-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        n--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="面试题02-07-链表相交"><a href="#面试题02-07-链表相交" class="headerlink" title="面试题02.07 链表相交"></a>面试题02.07 链表相交</h3><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/submissions/662678653/">原题链接</a></p><p>提一个我到现在都写错了的地方。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (curA -&gt;next != <span class="hljs-literal">NULL</span>)&#123;<br>    curA = curA -&gt;next;<br>    sizeA ++;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里<code>while</code>的条件应该是<code>curA != NULL</code>。我之前担心如果不检查<code>cur-&gt;next</code>是否为空，会导致循环内<code>curA = curA -&gt;next</code>报错。但其实<strong>指针被赋值为NULL并不会报错</strong>，这样当前指针就是空指针。<strong>真正会报错的是对空指针进行解指针的过程</strong>，即在<code>cur=nullptr</code>的情况下索引<code>cur-&gt;next</code>。此外，由于我们的<code>curA</code>指针是从<code>DummyHead</code>开始的，如果这里直接改成<code>while (curA != NULL)</code>会导致<code>curA</code>最后停留在最后一个节点之后，算出来的<code>sizeA</code>比正确值大一。可行做法是在初始化的时候<code>curA = DummyHead-&gt;next</code></p><h3 id="142-环形链表"><a href="#142-环形链表" class="headerlink" title="142. 环形链表"></a>142. 环形链表</h3><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">原题链接</a></p><p>快慢指针法，快指针每次走两步，慢指针每次走一步。当慢指针追上快指针则说明有环。由于快慢指针相对速度总是一，所以如果有环则一定可以追上，且快指针总比慢指针多走<strong>环剩下长度+n*环总长度</strong>。此时在起点和快慢指针交汇处分别设置一个指针，每次走一步，则新设指针交汇点一定是环入口。证明如下：</p><blockquote><p>设起点到环入口为 $l$,快慢指针交汇于距离环入口$x$处，记为点A，环剩下的长度为 $y$，环总长 $z&#x3D;x+y$。由于快慢指针速度关系，有</p><p>$$</p><pre><code class="hljs">2(x+l) - (x+l) = n(x+y)\\l=n(x+y)-x\\l=(n-1)(x+y)+y</code></pre><p>$$</p><p>我们要求的就是这个 $l$，最后一个式子说明 $l$ 的距离相当于从A走到环入口，再绕 $(n-1)$ 圈。证明了新设的两个指针一定会在环入口交汇。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/HRbenY/blog-assets@master//img/20260117145443366.png" alt="总结"></p>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>编程语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心</title>
    <link href="/2026/01/23/obsidian/cpp/Notes/9.greedy%20algorithm/%E8%B4%AA%E5%BF%83/"/>
    <url>/2026/01/23/obsidian/cpp/Notes/9.greedy%20algorithm/%E8%B4%AA%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h3 id="445-分发饼干"><a href="#445-分发饼干" class="headerlink" title="445.分发饼干"></a>445.分发饼干</h3><p><a href="https://leetcode.cn/problems/assign-cookies/description/">原题链接</a></p><p>主要思想就是拿着饼干从大到小找小孩。注意饼干和小孩都要先排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> index = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> nums = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> nums;<br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = g.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- )&#123;<br>            <span class="hljs-keyword">if</span>(s[index] &gt;= g[i])&#123;<br>                nums ++;<br>                <span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<br>                index --;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376.摆动序列"></a>376.摆动序列</h3><p><a href="https://leetcode.cn/problems/wiggle-subsequence/description/">原题链接</a></p><p>一些小错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        &#125;<br>        <span class="hljs-type">int</span> curr_diff = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> prev_diff = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            curr_diff = nums[i] - nums[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>((curr_diff &gt; <span class="hljs-number">0</span> &amp;&amp; prev_diff &lt;= <span class="hljs-number">0</span>) || (curr_diff &lt; <span class="hljs-number">0</span> &amp;&amp; prev_diff &gt;= <span class="hljs-number">0</span>))&#123;<span class="hljs-comment">//注意prev_diff可以等于0</span><br>                result ++;<br>            prev_diff = curr_diff;<br>            &#125;<span class="hljs-comment">//要等到找到非平坡才更新</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意注释的地方。prev_diff可以等于零，这样才可以将第一次变化计入。更新prev_diff时也要在找到正负交替时进行，否则会丢失上一个差值。</p><p>由于只要nums非空，就必会有一个长度为1的摆动序列，所以result初始化为1.</p><h3 id="53-最大子子数和"><a href="#53-最大子子数和" class="headerlink" title="53.最大子子数和"></a>53.最大子子数和</h3><p><a href="https://leetcode.cn/problems/maximum-subarray/description/">原题链接</a></p><p>kadane算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> globalMax = INT_MIN;<br>        <span class="hljs-type">int</span> preMax = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : nums)&#123;<br>            preMax = <span class="hljs-built_in">max</span>(i, preMax + i);<br>            globalMax = <span class="hljs-built_in">max</span>(globalMax, preMax);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> globalMax;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><h4 id="kadane算法"><a href="#kadane算法" class="headerlink" title="kadane算法"></a>kadane算法</h4><p>kadane算法的思想是从左往右遍历整个数组，判断当前和（左边所有数的和）加上当前值会不会比当前值更大。如果变小了说明当前和是负数，直接抛弃，在当前位置另起炉灶计算当前和。如果变大了则正常循环。</p><p>所以kadane算法需要维护两个参数，即上面代码中的全局最大值<code>globalMax</code>和当前最大值<code>preMax</code></p></blockquote><h3 id="45-跳跃游戏II"><a href="#45-跳跃游戏II" class="headerlink" title="45.跳跃游戏II"></a>45.跳跃游戏II</h3><p><a href="https://leetcode.cn/problems/jump-game-ii/description/">原题链接</a></p><p>整体思想还是从左往右遍历，在遍历中更新step。step的更新逻辑是当前遍历到当前步数能到达的最远距离后+1.代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> farest = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> loopFar = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> step = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123;<br>            loopFar = <span class="hljs-built_in">max</span>(loopFar, i + nums[i]);<br>            <span class="hljs-keyword">if</span> (i == farest) &#123;<br>                step++;<br>                farest = loopFar;<br>            &#125;<br>            <span class="hljs-comment">// if (loopFar &gt;= nums.size() - 1)</span><br>            <span class="hljs-comment">//     break;因为这个loopfar是下一步能够到的范围，但是当前这步还没到。</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> step;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意注释部分。</p><h3 id="1005-k次取反后最大的数组和"><a href="#1005-k次取反后最大的数组和" class="headerlink" title="1005.k次取反后最大的数组和"></a>1005.k次取反后最大的数组和</h3><p><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/">原题链接</a></p><p>要用到比较器。刚好复习一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestSumAfterKNegations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">absCmp</span> &#123;<br>        <span class="hljs-keyword">public</span>:<br>            <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> <span class="hljs-type">const</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(x)&gt; <span class="hljs-built_in">abs</span>(y);<br><br>            &#125;<br>        &#125;;<br>        absCmp cmp;<br>        <span class="hljs-type">int</span> curIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; curIndex &lt; nums.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (nums[curIndex] &lt; <span class="hljs-number">0</span>) &#123;<br>                nums[curIndex] = -nums[curIndex];<br>                k--;<br>            &#125;<br>            curIndex++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : nums) &#123;<br>            result += i;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>            result -= <span class="hljs-number">2</span> * (nums.<span class="hljs-built_in">back</span>());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意，<code>std::sort</code> 的比较器必须实现“<strong>严格弱序</strong>”（Strict Weak Ordering）。不能出现&gt;&#x3D;或&lt;&#x3D;。</p><p>注意代码中比较器的定义方式。可以使用普通函数，也可以用函数对象。前者是一个重载了operator()的类，可以有自己的成员变量，功能更强大。一个使用成员变量的函数对象例子：</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThresholdComparator</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> threshold; <span class="hljs-comment">// 成员变量，用于存储阈值</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ThresholdComparator</span>(<span class="hljs-type">int</span> t) : <span class="hljs-built_in">threshold</span>(t) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (a &lt; threshold &amp;&amp; b &gt;= threshold) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (a &gt;= threshold &amp;&amp; b &lt; threshold) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a &lt; b;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><p>上面的例子还同时定义了构造函数，使用时这样<code>ThresholdComparator cmp(8)</code>就可以定义一个8为阈值的比较器。</p><h3 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134.加油站"></a>134.加油站</h3><p><a href="https://leetcode.cn/problems/gas-station/description/">原题链接</a></p><p>解题思路是将站点遍历一遍，用一个变量gasSum记录从start开始gas-cost的累加值。当gasSum小于零时说明从start到当前位置没有符合条件的出发点，随后把start重新设为i+1</p><h3 id="452-用最少的箭射爆气球"><a href="#452-用最少的箭射爆气球" class="headerlink" title="452.用最少的箭射爆气球"></a>452.用最少的箭射爆气球</h3><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/">原题链接</a></p><p>区间重合判断，首先排序。这里按左区间排序，判断与下一区间是否重合。重合则更新判断边界，不重合则说明左侧必定需要一支箭。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(),<br>            [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b) &#123;<br>                <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>])<br>                    <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>            &#125;);<br>        <span class="hljs-type">int</span> pos = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> ArrowNums = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; points.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">0</span>] &lt;= pos) &#123;<br>                pos = <span class="hljs-built_in">min</span>(pos, points[i][<span class="hljs-number">1</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ArrowNums++;<br>                pos = points[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ArrowNums + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>用pos判断是否重合。如果下一节点的左边界小于pos说明有一段是重合的，用<code>pos = min(pos, points[i][1]);</code>更新pos。</p><h3 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435.无重叠区间"></a>435.无重叠区间</h3><p><a href="https://leetcode.cn/problems/non-overlapping-intervals/description/">原题链接</a></p><p>跟<a href="#452%E7%94%A8%E6%9C%80%E5%B0%91%E7%9A%84%E7%AE%AD%E5%B0%84%E7%88%86%E6%B0%94%E7%90%83">452</a>类似，如果用452的算法判断出必须射一根箭，也正好说明范围内有一个无重叠区间。需要注意的是边界条件。本体区间都是开区间，端点重合也是无重叠。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(),<br>             [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b) &#123;<br>                 <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>])<br>                     <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>                 <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>             &#125;);<br>        <span class="hljs-type">int</span> nums = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(end &gt; intervals[i][<span class="hljs-number">0</span>])&#123;<br>                end = <span class="hljs-built_in">min</span>(end, intervals[i][<span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                nums ++;<br>                end = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> intervals.<span class="hljs-built_in">size</span>() - nums;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763.划分字母区间"></a>763.划分字母区间</h3><p><a href="https://leetcode.cn/problems/partition-labels/description/">原题链接</a></p><p>先遍历一遍字符串得到每个字母的最后出现位置，再遍历一遍进行分割。分割边界取边界和当前字母最后出现位置的较大值。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">lastLables</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            lastLables[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>        &#125;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> last = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            index = <span class="hljs-built_in">max</span>(lastLables[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>], index);<br>            <span class="hljs-keyword">if</span> (i == index)&#123;<br>                result.<span class="hljs-built_in">push_back</span>(i - last + <span class="hljs-number">1</span>);<br>                last = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意边界条件。在第一次分割时<code>last</code>表示的是字符串的第一个字符，所以后续更新<code>last</code>的时候要更新成<code>last = i + 1</code>。</p><h3 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968.监控二叉树"></a>968.监控二叉树</h3><p><a href="https://leetcode.cn/problems/binary-tree-cameras/description/">原题链接</a></p><p>贪心在于给每个叶子节点的父节点安装摄像头。另外，要注意一个摄像头可以监控左右孩子和父节点，因此下一个摄像头最远可以间距两层。具体代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> nums = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123; <span class="hljs-comment">// 0表示已安装，1表示被覆盖，2表示未被覆盖</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">traversal</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">traversal</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">2</span> || right == <span class="hljs-number">2</span>) &#123;<br>            nums++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> || right == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCameraCover</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(root) == <span class="hljs-number">2</span>)nums ++;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>根据之前分析的，两个摄像头之间最多可以间隔两层。所以这里的遍历函数要用返回值来表示节点状态（已安装摄像头、被摄像头覆盖、未安装摄像头）。在确定返回值时，要明确状态转移过程。函数中分了三种情况，第一种<code>left == 2 || right == 2</code>左右节点至少有一个未被覆盖，说明当前节点必须安装摄像头。第二种<code>left == 0 || right == 0</code>至少有一个安装了摄像头，那当前节点就是被覆盖的状态。其余所有状况归于第三种。</p><h3 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738.单调递增的数字"></a>738.单调递增的数字</h3><p><a href="https://leetcode.cn/problems/monotone-increasing-digits/description/">原题链接</a></p><p>核心在于原数字中，如果高一位数字大于第一位数字，那么为了让结果最大，高位数字-1，低位数字置9。从右往左遍历。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        string stN = <span class="hljs-built_in">to_string</span>(n);<br>        <span class="hljs-type">int</span> set9flag = stN.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = stN.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i --)&#123;<br>            <span class="hljs-keyword">if</span>(stN[i] &lt; stN[i - <span class="hljs-number">1</span>])&#123;<br>                stN[i<span class="hljs-number">-1</span>] = stN[i<span class="hljs-number">-1</span>] - <span class="hljs-number">1</span>;<br>                set9flag = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = stN.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= set9flag; i --)&#123;<br>            stN[i] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">stoi</span>(stN);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>greedy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SM</title>
    <link href="/2026/01/23/obsidian/GPU/SM/"/>
    <url>/2026/01/23/obsidian/GPU/SM/</url>
    
    <content type="html"><![CDATA[<p>流式多处理器<br><img src="https://cdn.jsdelivr.net/gh/HRbenY/blog-assets@master//img/20260117231048749.png" alt="Pasted image 20260104221619"><br>上面是H100的一个SM，显示了 4_个子分区_，每个子分区包含一个张量核心、一个线程束调度器、一个寄存器文件以及不同精度的 CUDA 核心组。</p><h2 id="Memmory"><a href="#Memmory" class="headerlink" title="Memmory"></a>Memmory</h2><p>除了计算单元之外，GPU 还具有内存层次结构，其中最大的是 HBM（GPU 主内存），然后是一系列较小的缓存（L2、L1&#x2F;SMEM、TMEM、寄存器内存）。</p><ul><li><p><strong>寄存器：</strong> 每个子分区都有自己的寄存器文件，其中包含 H100&#x2F;B200（每个 SM）上的 16,384 个 32 位字，<code>4 * 16384 * 4 = 256kiB</code>CUDA 内核可以访问该文件。</p><ul><li>每个 CUDA 核心一次最多只能访问 256 个寄存器，因此尽管我们可以为每个 SM 调度多达 64 个“驻留线程束”，但<code>256 * 1024 / (4 * 32 * 256)</code>如果每个线程使用 256 个寄存器，则一次只能容纳 8 个线程束。</li></ul></li><li><p><strong>SMEM（L1缓存）</strong>：每个SM都有其自身的256kB片上缓存，称为SMEM。SMEM既可以由程序员控制作为“共享内存”，也可以由硬件用作片上缓存。SMEM用于存储TC矩阵乘法器的激活值和输入值。</p></li><li><p><strong>L2缓存</strong>：所有SM共享9使用相对较大的约 50MB L2 缓存来减少主内存访问。</p><ul><li>它的大小与TPU的VMEM类似，但速度慢<strong>得多</strong>，而且不受程序员控制。这就导致了一种“远程控制”的现象：程序员需要修改内存访问模式，以确保L2缓存得到充分利用。10</li><li>NVIDIA并未公布其芯片的L2带宽，但经测量约为5.5TB&#x2F;s。这大约是HBM带宽的1.6倍，但由于是全双工模式，因此实际双向带宽接近3倍。相比之下，TPU的VMEM容量是其两倍，带宽也更高（约为40TB&#x2F;s）。</li></ul></li><li><p><strong>HBM：</strong> GPU 主内存，用于存储模型权重、梯度、激活值等。</p><ul><li>HBM 容量从 Volta 的 32GB 大幅增加到 Blackwell (B200) 的 192GB。</li><li>从 HBM 到 CUDA Tensor Core 的带宽称为 HBM 带宽或内存带宽，在 H100 上约为 3.35TB&#x2F;s，在 B200 上约为 9TB&#x2F;s。</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>gpu</tag>
      
      <tag>sm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matrix Transpose</title>
    <link href="/2026/01/23/obsidian/GPU/leetGPU/Matrix%20Transpose/"/>
    <url>/2026/01/23/obsidian/GPU/leetGPU/Matrix%20Transpose/</url>
    
    <content type="html"><![CDATA[<p>假设要实现$B &#x3D; A^T$<br>native实现在转置后写入矩阵的时候会出现stride不连续的问题，降低HBM的访问效率。所以要用shared_memory做访问合并</p><h2 id="合并访问"><a href="#合并访问" class="headerlink" title="合并访问"></a>合并访问</h2><p>根本思路是合并转置后的非连续访问，使用shared memory来做坐标映射，实现</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">连续读取-&gt;连续写入shared memory-&gt;非连续读出-&gt;连续写入<br></code></pre></td></tr></table></figure><p>的过程。shared memory乱序读取的开销可以忽略不计。</p><p>由于引入了shared memory，问题可以从宏观和微观两个角度考虑。宏观考虑的是当前处理的block怎么对应，微观考虑的是block内部怎么对应。</p><h3 id="宏观"><a href="#宏观" class="headerlink" title="宏观"></a>宏观</h3><p>比如我们拿到了A的第0行第3列的block，可以断言这个block的元素都跟B的第3行第0列block的元素一一对应（不考虑边界），只是中间经由shared memory扭转了一下顺序。那么可以确定最终的B的索引一定有一部分是<br>$$<br>\begin{aligned}<br>Bx &#x3D; blockDim.y * blockIdx.y + ? \<br>By &#x3D; blockDim.x * blockIdx.x + ?<br>\end{aligned}<br>$$</p><h3 id="微观"><a href="#微观" class="headerlink" title="微观"></a>微观</h3><p>因为B默认是行优先存储，所以列是连续的。要达到连续写入B，必须保证B的列索引是连续的。可以反推出必须使用threadIdx.x作为B的列索引。</p><blockquote><p>这里和直觉相反。朴素实现是用A的列索引作为B的行索引，也符合转置的理解。但是这里为了访问速度，用A的列索引也作为B的列索引，中间的数据用shared memory做缓冲。所以需要进行坐标变换。</p></blockquote><p>最终确定每个线程对矩阵B的操作是</p><p>$$<br>\boxed{<br>\begin{aligned}<br>Bx &#x3D; blockDim.y * blockIdx.y + threadIdx.x \<br>By &#x3D; blockDim.x * blockIdx.x + threadIdx.y<br>\end{aligned}<br>}<br>$$<br>由此我们得到了每个线程需要修改的矩阵B的位置。再根据B的索引找出对应的shared memory中的元素就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">__global__ <span class="hljs-type">void</span> <span class="hljs-title function_">matrix_transpose_kernel</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">float</span>* input, <span class="hljs-type">float</span>* output, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols)</span> &#123;<br><br>    __shared__ <span class="hljs-type">float</span> s[TILE_WIDTH][TILE_WIDTH];<br><br>    <span class="hljs-type">int</span> x = blockDim.x * blockIdx.x + threadIdx.x;<br><br>    <span class="hljs-type">int</span> y = blockDim.y * blockIdx.y + threadIdx.y;<br><br>  <br><br>    <span class="hljs-type">int</span> tx = threadIdx.x;<br><br>    <span class="hljs-type">int</span> ty = threadIdx.y;<br><br>  <br><br>    <span class="hljs-keyword">if</span>(x &lt; cols &amp;&amp; y &lt; rows)&#123;<br><br>        s[ty][tx] = input[y * cols + x];<br><br>  <br><br>    &#125;<br><br>    __syncthreads();<br><br>  <br><br>    <span class="hljs-type">int</span> new_x = blockDim.y * blockIdx.y + threadIdx.x;<br><br>    <span class="hljs-type">int</span> new_y = blockDim.x * blockIdx.x + threadIdx.y;<br><br>  <br><br>    <span class="hljs-keyword">if</span>(new_x &lt; rows &amp;&amp; new_y &lt; cols)&#123;<br><br>        output[new_y * rows + new_x] = s[tx][ty];<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>gpu</tag>
      
      <tag>matrix-transpose</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组</title>
    <link href="/2026/01/23/obsidian/cpp/Notes/1.Array/%E6%95%B0%E7%BB%84/"/>
    <url>/2026/01/23/obsidian/cpp/Notes/1.Array/%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是存放在<strong>连续内存空间</strong>上的<strong>相同类型数据</strong>的集合。<br>正因为如此，可以方便地通过下标索引的方式（地址）获取到下标对应的数据。  </p><p>由于内存空间是连续的，所以我们在删除或者增添元素的时候，就难免要<strong>移动其他元素的地址</strong>。<br><img src="/image.png" alt="删除数组元素"></p><p>数组的元素是不能删的，<strong>只能覆盖</strong>。</p><p>C++的话，要注意vector 和 array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。</p><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p>成员函数（Member Function）是属于一个类（Class）的函数。可以把它想象成是这个类所拥有的行为或能力。C++ 标准库中的容器，如 <code>vector</code>, <code>string</code>, <code>set</code>, <code>map</code> 等，都有一套非常丰富且通用的成员函数</p><h3 id="I-容量与大小-Capacity-Size"><a href="#I-容量与大小-Capacity-Size" class="headerlink" title="I. 容量与大小 (Capacity &amp; Size)"></a>I. 容量与大小 (Capacity &amp; Size)</h3><p>这些函数用于查询和管理容器的元素数量和内存空间。</p><ul><li><p><strong><code>.empty()</code></strong></p><ul><li><strong>作用</strong>：检查容器是否为空。</li><li><strong>返回值</strong>：如果容器没有元素，返回 <code>true</code>。这是一个高效的 $O(1)$ 操作。</li><li><strong>适用容器</strong>：所有标准容器。</li></ul></li><li><p><strong><code>.size()</code></strong></p><ul><li><strong>作用</strong>：返回容器中元素的数量。</li><li><strong>返回值</strong>：一个无符号整数类型（<code>size_t</code>）。</li><li><strong>适用容器</strong>：所有标准容器。</li></ul></li><li><p><strong><code>.max_size()</code></strong></p><ul><li><strong>作用</strong>：返回容器能容纳的最大元素数量。</li><li><strong>返回值</strong>：<code>size_t</code> 类型。</li><li><strong>适用容器</strong>：所有标准容器。</li></ul></li><li><p><strong><code>.reserve()</code></strong></p><ul><li><strong>作用</strong>：请求容器为至少指定数量的元素预留内存，通常用于 <code>vector</code> 和 <code>string</code> 以避免多次重新分配内存。</li><li><strong>适用容器</strong>：<code>vector</code>, <code>string</code>。</li></ul></li><li><p><strong><code>.shrink_to_fit()</code></strong></p><ul><li><strong>作用</strong>：释放容器中多余的内存空间，使其容量与当前元素数量相匹配。</li><li><strong>适用容器</strong>：<code>vector</code>, <code>string</code>, <code>deque</code>。</li></ul></li></ul><hr><h3 id="II-迭代器-Iterators"><a href="#II-迭代器-Iterators" class="headerlink" title="II. 迭代器 (Iterators)"></a>II. 迭代器 (Iterators)</h3><p>这些函数返回迭代器，用于遍历容器。</p><ul><li><p><strong><code>.begin()</code> &#x2F; <code>.end()</code></strong></p><ul><li><strong>作用</strong>：返回指向容器<strong>首个元素</strong>和<strong>末尾虚位</strong>的迭代器。</li><li><strong>用途</strong>：用于正向遍历容器，如 <code>for (auto it = c.begin(); it != c.end(); ++it)</code>.</li><li><strong>适用容器</strong>：所有标准容器。</li></ul></li><li><p><strong><code>.cbegin()</code> &#x2F; <code>.cend()</code></strong></p><ul><li><strong>作用</strong>：返回<strong>常量迭代器</strong>，用法和 <code>begin()</code> &#x2F; <code>end()</code> 相同，但不能通过它们修改元素。</li><li><strong>用途</strong>：只读遍历，能提升代码安全性和可读性。</li><li><strong>适用容器</strong>：所有标准容器。</li></ul></li><li><p><strong><code>.rbegin()</code> &#x2F; <code>.rend()</code></strong></p><ul><li><strong>作用</strong>：返回<strong>反向迭代器</strong>，分别指向容器的最后一个元素和第一个元素的前一个虚位。</li><li><strong>用途</strong>：用于从后往前反向遍历。</li><li><strong>适用容器</strong>：支持反向迭代器的容器，如 <code>vector</code>, <code>string</code>, <code>list</code>, <code>deque</code>。</li></ul></li><li><p><strong><code>.crbegin()</code> &#x2F; <code>.crend()</code></strong></p><ul><li><strong>作用</strong>：返回<strong>常量反向迭代器</strong>，用于从后往后只读遍历。</li><li><strong>适用容器</strong>：支持反向迭代器的容器。</li></ul></li></ul><hr><h3 id="III-元素访问-Element-Access"><a href="#III-元素访问-Element-Access" class="headerlink" title="III. 元素访问 (Element Access)"></a>III. 元素访问 (Element Access)</h3><p>这些函数用于直接访问容器中的特定元素，通常返回对元素的引用。</p><ul><li><p><strong><code>[ ]</code> 操作符</strong></p><ul><li><strong>作用</strong>：通过索引（<code>vector</code>）或键（<code>map</code>）来访问元素。</li><li><strong>注意</strong>：不进行边界检查。如果索引或键不存在，可能导致未定义行为。</li><li><strong>适用容器</strong>：<code>vector</code>, <code>deque</code>, <code>string</code>, <code>map</code>, <code>unordered_map</code>。</li></ul></li><li><p><strong><code>.at()</code></strong></p><ul><li><strong>作用</strong>：通过索引或键来访问元素，<strong>会进行边界检查</strong>。</li><li><strong>注意</strong>：如果索引或键不存在，会抛出 <code>std::out_of_range</code> 异常。</li><li><strong>适用容器</strong>：<code>vector</code>, <code>deque</code>, <code>string</code>, <code>map</code>, <code>unordered_map</code>。</li></ul></li><li><p><strong><code>.front()</code> &#x2F; <code>.back()</code></strong></p><ul><li><strong>作用</strong>：分别返回对容器<strong>第一个</strong>和<strong>最后一个</strong>元素的引用。</li><li><strong>适用容器</strong>：<code>vector</code>, <code>string</code>, <code>list</code>, <code>deque</code>。</li></ul></li></ul><hr><h3 id="IV-查找与统计-Lookup-Statistics"><a href="#IV-查找与统计-Lookup-Statistics" class="headerlink" title="IV. 查找与统计 (Lookup &amp; Statistics)"></a>IV. 查找与统计 (Lookup &amp; Statistics)</h3><p>这些函数用于高效地在容器中查找元素或统计数量。</p><ul><li><p><strong><code>.find()</code></strong></p><ul><li><strong>作用</strong>：在容器中查找指定元素（或键）。</li><li><strong>返回值</strong>：如果找到，返回指向该元素的<strong>迭代器</strong>；如果找不到，返回 <code>container.end()</code>。</li><li><strong>适用容器</strong>：<code>set</code>, <code>map</code>, <code>unordered_set</code>, <code>unordered_map</code>。</li></ul></li><li><p><strong><code>.count()</code></strong></p><ul><li><strong>作用</strong>：检查容器中是否存在某个元素（或键），或统计其出现次数。</li><li><strong>返回值</strong>：对于 <code>set</code>&#x2F;<code>map</code>，返回 <code>1</code> 或 <code>0</code>。对于 <code>multiset</code>&#x2F;<code>multimap</code>，返回元素出现的次数。</li><li><strong>适用容器</strong>：<code>set</code>, <code>map</code>, <code>multiset</code>, <code>multimap</code>, <code>unordered_set</code>, <code>unordered_map</code>。</li></ul></li></ul><hr><h3 id="V-修改器-Modifiers"><a href="#V-修改器-Modifiers" class="headerlink" title="V. 修改器 (Modifiers)"></a>V. 修改器 (Modifiers)</h3><p>这些函数用于添加、删除或修改容器的元素。</p><ul><li><p><strong><code>.insert()</code></strong></p><ul><li><strong>作用</strong>：插入一个或多个元素。对于 <code>set</code>&#x2F;<code>map</code>，会自动找到正确位置。</li><li><strong>适用容器</strong>：所有标准容器。</li><li>insert(iterator, val)或insert(val)</li></ul></li><li><p><strong><code>.erase()</code></strong></p><ul><li><strong>作用</strong>：删除一个或多个元素。可以接受一个值、一个迭代器或一个迭代器范围。</li><li><strong>适用容器</strong>：所有标准容器。</li></ul></li><li><p><strong><code>.clear()</code></strong></p><ul><li><strong>作用</strong>：删除容器中的<strong>所有</strong>元素，使其变为空。</li><li><strong>适用容器</strong>：所有标准容器。</li></ul></li><li><p><strong><code>.push_back()</code> &#x2F; <code>.pop_back()</code></strong></p><ul><li><strong>作用</strong>：在容器<strong>末尾</strong>添加或删除一个元素。</li><li><strong>适用容器</strong>：<code>vector</code>, <code>string</code>, <code>list</code>, <code>deque</code>。</li></ul></li><li><p><strong><code>.emplace()</code> &#x2F; <code>.emplace_back()</code></strong></p><ul><li><strong>作用</strong>：在容器中直接构造新元素，而不是先构造再拷贝或移动。通常比 <code>insert()</code> 或 <code>push_back()</code> 更高效。</li><li><strong>适用容器</strong>：所有标准容器（<code>emplace</code>），<code>vector</code> 等支持 <code>push_back</code> 的容器（<code>emplace_back</code>）。</li></ul></li><li><p><strong><code>.swap()</code></strong></p><ul><li><strong>作用</strong>：与另一个同类型容器交换所有元素，这是一个非常高效的操作，通常为常数时间 $O(1)$。</li><li><strong>适用容器</strong>：所有标准容器。</li></ul></li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h3><p><a href="https://leetcode.cn/problems/binary-search/">原题链接</a></p><p>二分法注意区间开闭，这类问题一定要考虑好边界问题。</p><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h3><p><a href="https://leetcode.cn/problems/remove-element/description/">原题链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> fastIndex = <span class="hljs-number">0</span>; fastIndex &lt; nums.<span class="hljs-built_in">size</span>(); fastIndex++) &#123;<br>    <span class="hljs-keyword">if</span> (val != nums[fastIndex]) &#123;<br>        nums[slowIndex++] = nums[fastIndex];<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>快慢指针，这里注意用快指针做循环。</p><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a>977. 有序数组的平方</h3><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">原题链接</a></p><p>双指针</p><h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h3><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">原题链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) &#123;<br>           sum += nums[j];<br>           <span class="hljs-keyword">while</span> (sum &gt;= s) &#123;<br>               subLength = (j - i + <span class="hljs-number">1</span>);<br>               result = result &lt; subLength ? result : subLength;<br>               sum -= nums[i++];<br>           &#125;<br>       &#125;<br></code></pre></td></tr></table></figure><p>滑动窗口，这里用右端点做for循环，<strong>while循环判断窗口数值之和是否大于给定值</strong>。一旦大于就开始移动左端点。</p><h3 id="59-螺旋矩阵"><a href="#59-螺旋矩阵" class="headerlink" title="59. 螺旋矩阵"></a>59. 螺旋矩阵</h3><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/submissions/661551259/">原题链接</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">matrix</span>(n, std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><p>注意这里定义二维数组的方式，用<strong>两个vector嵌套</strong>。</p><p><code>std::vector&lt;int&gt;</code>声明这个vector的所有元素都是int类型。<br><code>std::vector&lt;std::vector&lt;int&gt;&gt;</code>声明外侧vector的所有元素都是<code>std::vector&lt;int&gt;</code>类型。</p><p><code>std::vector&lt;int&gt;(n, 0)</code>是vector的构造函数，创建一个长度为n的向量，并初始化为零。<br><code>std::vector&lt;std::vector&lt;int&gt;&gt; matrix(n, std::vector&lt;int&gt;(n, 0))</code>外侧vector创建了一个长度为n的向量，并将所有元素初始化为<code>std::vector&lt;int&gt;(n, 0)</code></p><p>如果要创建一个<strong>m行n列</strong>的二维数组，应写成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">matrix</span>(m, std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><p>因为本质是用<strong>m个有n个元素的行向量</strong>拼成的。</p><h3 id="卡码58-区间和"><a href="#卡码58-区间和" class="headerlink" title="卡码58. 区间和"></a>卡码58. 区间和</h3><p><a href="https://kamacoder.com/problempage.php?pid=1070">原题链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(cin &gt;&gt; a &gt;&gt; b)&#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span>)&#123;<br>        result = psum[b];<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        result = psum[b] - psum[a<span class="hljs-number">-1</span>];<br>    &#125;<br><br>    cout &lt;&lt; result &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>前缀和。避免每次计算新区间都重新循环累加。先计算下标0~n的元素和，再根据输入的a和b用前b项减去前a-1项:<code>psum[b] - psum[a-1]</code>  </p><p>使用<code>while(cin &gt;&gt; a &gt;&gt; b)</code>监听输入。</p><p>注意当a&#x3D;1时要单独考虑</p>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2026/01/23/obsidian/cpp/Notes/10.dp/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2026/01/23/obsidian/cpp/Notes/10.dp/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h3 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343.整数拆分"></a>343.整数拆分</h3><p><a href="https://leetcode.cn/problems/integer-break/">原题链接</a></p><p>这里dp[i]代表把i拆分之后乘积的最大值。那么递推过程可以是dp[i]从dp[i], j * (i - j), j * dp[i - j]中选一个最大的。其中j从1到i&#x2F;2遍历。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i ++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i / <span class="hljs-number">2</span>; j ++)&#123;<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], <span class="hljs-built_in">max</span>(j * (i - j), j * dp[i - j]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>为什么dp[i]要从dp[i], j * (i - j), j * dp[i - j]中选一个最大的？因为当前的dp[i]在j的循环中会被多次赋值，每个循环中都会计算出一个不同的分割方式下的dp[i]，所以要取这些dp[i]的最大值。<br>另外，这里是三个值求取max。用两个max嵌套。</p><h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96.不同的二叉搜索树"></a>96.不同的二叉搜索树</h3><p><a href="https://leetcode.cn/problems/unique-binary-search-trees/">原题链接</a></p><p>这题的dp[i]的含义是，以i为根的二叉搜索树的数量。i的左子树有i - 1个值，右子树有n - i个值，且左右子树内数值都是连续的，使得存在如下关系。比如当右子树为4、5这两个值（对应5个数选取3做根），形成的二叉搜索树的数量跟用1、2为值是一样的。各自组成二叉搜索树，就形成了递推关系。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++)&#123;<br>            <span class="hljs-type">int</span> tmp_sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j ++)&#123;<br>                tmp_sum += dp[j - <span class="hljs-number">1</span>] * dp[i - j];<br>            &#125;<br>            dp[i] = tmp_sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p><a href="https://kamacoder.com/problempage.php?pid=1046">携带材料</a></p><p>这里要使用二维数组，一维遍历容量，一维遍历物品id。</p><p>首先初始化第一排，只选择物品0时当背包空间逐渐增大，算出价值。<br>由于每个物品只有选和不选两种状态，所以第二排可以利用第一排推导的结果：当空间不够放下物品1时，跟上一排的对应位置是一样的。即<code>dp[i][j] = dp[i - 1][j]</code>当足够放下物品1，则当前的最大价值则是物品1的价值<code>doc[1][1]</code>和剩余空间放物品0的价值 <code>dp[0][j - doc[1][0]]</code>和只放物品0 <code>dp[0][j]</code>的较大值。这样就形成了递推，可以一步步算出最终的结果。</p><p>比如下面这个图，要计算4格容量下可以放物品0和1（重量分别为1、3，价值分别为15、20）时的最大价值，就是比较四格容量下只放物品0的价值（15）和预留一个物品1的空间，剩下的空间退化到上一行（一格容量放物品0）的价值。</p><p><img src="https://cdn.jsdelivr.net/gh/HRbenY/blog-assets@master//img/20260117145644484.png" alt="01背包"></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, bagweight;<span class="hljs-comment">// bagweight代表行李箱空间</span><br><br>    cin &gt;&gt; n &gt;&gt; bagweight;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">weight</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 存储每件物品所占空间</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">value</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// 存储每件物品价值</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; weight[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>        cin &gt;&gt; value[j];<br>    &#125;<br>    <span class="hljs-comment">// dp数组, dp[i][j]代表行李箱空间为j的情况下,从下标为[0, i]的物品里面任意取,能达到的最大价值</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(weight.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">// 初始化, 因为需要用到dp[i - 1]的值</span><br>    <span class="hljs-comment">// j &lt; weight[0]已在上方被初始化为0</span><br>    <span class="hljs-comment">// j &gt;= weight[0]的值就初始化为value[0]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) &#123;<br>        dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历科研物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历行李箱容量</span><br>            <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j]; <span class="hljs-comment">// 如果装不下这个物品,那么就继承dp[i - 1][j]的值</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[n - <span class="hljs-number">1</span>][bagweight] &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意遍历容量时是从0遍历到bagweight，是可以取到右端点的。</p><p>另外，可以只使用一维dp数组滚动存储。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-type">int</span> m, n;<br>  cin &gt;&gt; m;<br>  cin &gt;&gt; n;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">weight</span><span class="hljs-params">(m, <span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">value</span> <span class="hljs-params">(m, <span class="hljs-number">0</span>)</span></span>;<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++)&#123;<br>    cin &gt;&gt; weight[i];<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++)&#123;<br>    cin &gt;&gt; value[i];<br>  &#125;<br><br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt;= <span class="hljs-number">0</span>; j --)&#123;<br>      <span class="hljs-keyword">if</span>(j &gt;= weight[i])<br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>  &#125;<br><br>  cout &lt;&lt; dp[n];<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，这里**对dp数组进行遍历时要从右到左。**即代码中的<code>for (int j = n; j &gt;= 0; j --)</code>原因是当前dp[j]的值只与左边的有关。如果从左边遍历会出现更新dp[j]时用到已经更新过的某个值，而导致某件物品被重复计算。从右边开始更新则没有这个问题。</p><h3 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416.分割等和子集"></a>416.分割等和子集</h3><p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/submissions/672958262/">原题链接</a></p><p>01背包问题。集合中每个元素只能取一次。这里由于元素是数字，其重量和价值都是自己本身。返回true的条件是大小为sum &#x2F; 2的背包能刚好被装满。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(sum / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = sum / <span class="hljs-number">2</span>; j &gt;= nums[i]; j --)&#123;<span class="hljs-comment">//注意j的取值下限</span><br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(dp[sum / <span class="hljs-number">2</span>] == sum / <span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注释部分因为<code>j&lt;nums[i]</code>意味着放不下新的元素<code>nums[i]</code>,所以也不会更新<code>dp[j]</code>。</p><h3 id="1049-最后一块石头的重量"><a href="#1049-最后一块石头的重量" class="headerlink" title="1049 最后一块石头的重量"></a>1049 最后一块石头的重量</h3><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/description/">原题链接</a></p><p>思路还是选取两堆石头，使其和都接近所有石头总重的一半。返回两堆的差。本质上跟上一题区别不大。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lastStoneWeightII</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; stones)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            sum += stones[i];<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(sum / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = sum / <span class="hljs-number">2</span>; j &gt;= stones[i]; j --)&#123;<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(sum - <span class="hljs-number">2</span> * dp.<span class="hljs-built_in">back</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494.目标和"></a>494.目标和</h3><p><a href="https://leetcode.cn/problems/target-sum/">原题链接</a></p><p>看似跟前两题差不多，实际这里的dp数组的含义有比较大的不同。首先确定dp表格横向肯定是所有数字，纵向是数字的和。纵向遍历的最大值是<code>sum + target / 2</code>。</p><p><code>dp[i][j]</code>的值代表可以选择数字i，和为j时的方法数量。在这个场景下<code>dp[i][j]</code>，即可以选择数字i，和为j的方法数等于可以选择数字i - 1，和为j的方法数加上可以选择数字i - 1，和为j - 数字i的方法数,即<code>dp[i - 1][j] + dp[i - 1][j - nums[i]]</code>。<br>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(target) &gt; sum)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>((sum + target) % <span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> tar = (sum + target) / <span class="hljs-number">2</span>;<span class="hljs-comment">//因为这里必须是一个整数，所以上一步中(sum + target) % 2就必须是0.</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(tar + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &lt;= tar + <span class="hljs-number">1</span>)dp[<span class="hljs-number">0</span>][nums[<span class="hljs-number">0</span>]] = <span class="hljs-number">1</span>;<span class="hljs-comment">//注意这里的判断条件</span><br>        <span class="hljs-type">int</span> numZero = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<span class="hljs-comment">//注意排除数字为0的情况。这种情况下结果为0的组合数量不止1</span><br>            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)numZero ++;<br>            dp[i][<span class="hljs-number">0</span>] = (<span class="hljs-type">int</span>) <span class="hljs-built_in">pow</span>(<span class="hljs-number">2.0</span>, numZero);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= tar; j ++)&#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">if</span>(j &gt;= nums[i]) dp[i][j] += dp[i - <span class="hljs-number">1</span>][j - nums[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][tar];<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>要注意代码中的注释部分。</p><p>第2个注释 <code>if(nums[0] &lt;= tar + 1)</code>是为了防止第一个数字太大，超过了<code>sum + target / 2</code>的最大限制。比如一个数组中有元素1000 -1000， target为0时，不加判断第一个元素就越界了。</p><p>第3个注释是为了排除数组中存在零元素的情况。当有零时，和为0的组合数就不只是1了，而是这些0的全组合。比如，有俩个0时就是01, 02, 01 + 02, null。有一个就是0, null.没有就是null。即2^n。</p><h3 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a>474. 一和零</h3><p><a href="https://leetcode.cn/problems/ones-and-zeroes/description/">原题链接</a></p><p>注意题目要求的是<strong>不大于</strong>m个0和n个1的最大子集长度。将二进制字符串作为待选物品，0和1的个数作为质量的两个维度。实际上是一个经典的01背包。在不大于给定质量的条件下求最大价值，这里的价值就是子集长度。dp[i][j]的含义是不大于i个0和j个1的条件下的最大子集长度。实际上这里的dp数组维度经过了压缩，遍历字符串的维度直接在上一层的基础上更新，所以要将i和j都反向遍历。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">binNum</span>(strs.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; strs.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> j : strs[i])&#123;<br>                <span class="hljs-keyword">if</span>(j == <span class="hljs-string">&#x27;0&#x27;</span>)binNum[i][<span class="hljs-number">0</span>]++;<br>            &#125;<br>            binNum[i][<span class="hljs-number">1</span>] = strs[i].<span class="hljs-built_in">size</span>() - binNum[i][<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> index = <span class="hljs-number">0</span>; index &lt; binNum.<span class="hljs-built_in">size</span>(); index ++)&#123;<br>            <span class="hljs-keyword">if</span>(binNum[index][<span class="hljs-number">0</span>] &gt; m || binNum[index][<span class="hljs-number">1</span>] &gt; n)<span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = m; i &gt;= binNum[index][<span class="hljs-number">0</span>]; i --)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = n; j &gt;=binNum[index][<span class="hljs-number">1</span>]; j --)&#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - binNum[index][<span class="hljs-number">0</span>]][j - binNum[index][<span class="hljs-number">1</span>]] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>dp数组的转移方程是<code>dp[i][j] = max(dp[i][j], dp[i - binNum[index][0]][j - binNum[index][1]] + 1)</code>。含义是不选当前字符串的子集长度和选了当前字符串后的子集长度的较大值。</p><p><strong>不要搞错</strong>成<code>dp[i][j] = dp[i][j] + dp[i - binNum[index][0]][j - binNum[index][1]]</code>，后者的含义是凑成恰好 i 个 ‘0’ 和 j 个 ‘1’ 的方法总数，是<a href="#494%E7%9B%AE%E6%A0%87%E5%92%8C">494题</a>的方法。</p><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p><a href="https://kamacoder.com/problempage.php?pid=1052">原题链接</a></p><p>相比01背包最大的区别是元素可重复选取。带来的影响是dp数组的递推中，最大价值是不选该元素和选该元素的价值最大值。这里选该元素的价值最大值也是在第i行查找，而非01背包的i-1行。示意图如下<img src="https://cdn.jsdelivr.net/gh/HRbenY/blog-assets@master//img/20260117145644485.png" alt="完全背包"></p><p>对比<a href="#01%E8%83%8C%E5%8C%85">01背包的示意图</a>更加清楚。</p><p>本题代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n, v;<br>  cin &gt;&gt; n;<br>  cin &gt;&gt; v;<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pack</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : pack) &#123;<br>    cin &gt;&gt; i[<span class="hljs-number">0</span>]; <span class="hljs-comment">//重量</span><br>    cin &gt;&gt; i[<span class="hljs-number">1</span>]; <span class="hljs-comment">//价值</span><br>  &#125;<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(v + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = pack[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]; j &lt;= v; j++) &#123;<br>    dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - pack[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]] + pack[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= v; j++) &#123;<br>      <span class="hljs-keyword">if</span> (j &lt; pack[i][<span class="hljs-number">0</span>])<br>        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>      <span class="hljs-keyword">else</span> &#123;<br>        dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - pack[i][<span class="hljs-number">0</span>]] + pack[i][<span class="hljs-number">1</span>]);<br>      &#125;<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; dp[n - <span class="hljs-number">1</span>][v];<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>几点细节：</p><ul><li>初始化时初始化第一行。因为dp数组递推中会用到上一行的结果。注意这里的初始化方式。</li><li>递推公式为<code>dp[i][j] = max(dp[i - 1][j], dp[i][j - pack[i][0]] + pack[i][1]);</code></li></ul><h3 id="518-零钱兑换"><a href="#518-零钱兑换" class="headerlink" title="518 零钱兑换"></a>518 零钱兑换</h3><p><a href="https://leetcode.cn/problems/coin-change-ii/description/">原题链接</a></p><p>完全背包问题求组合数。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(coins.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(amount + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= amount; j ++)&#123;<br>            <span class="hljs-keyword">if</span>(j % coins[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= amount; j ++)&#123;<br>                <span class="hljs-keyword">if</span>(j &lt; coins[i])dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">else</span> dp[i][j] = (<span class="hljs-type">long</span>) dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - coins[i]];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[coins.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>跟<a href="#494%E7%9B%AE%E6%A0%87%E5%92%8C">494.目标和</a>类似，都是求组合数。完全背包的递推公式有所不同，<code>dp[i][j] = (long) dp[i - 1][j] + dp[i][j - coins[i]]</code>是不选新元素的组合数加选新元素的组合数，选新元素的组合数从同行取，从左往右自然算出了多个新元素的情况。01背包的对应项则是从上一行取。这点区别也在<a href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85">完全背包</a>介绍了。</p><p>再就是<strong>注意第二层for循环的起点位置</strong>。<code>for (int j = 0; j &lt;= amount; j ++)</code>这里要从0开始循环。有些情况直接从coins[i]开始就好，主要是看coins[i]左侧的格子要不要更新。这里我经常写错，要注意。</p><p><strong>初始化第一行第一列</strong>。这里没有显示初始化，但是<code>if(j &lt; coins[i])dp[i][j] = dp[i - 1][j];</code>保证了每行第一列都是1。</p><p>下面是一维压缩dp数组的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">uint64_t</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= amount; j++)&#123;<br>            <span class="hljs-keyword">if</span> (j % coins[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)dp[j] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = coins[i]; j &lt;= amount; j ++)&#123;<br>                dp[j] += dp[j - coins[i]];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>跟01背包的一维压缩非常类似，递推也是<code>dp[j] += dp[j - coins[i]]</code>，只是遍历顺序有变化。<strong>完全背包的第二层遍历是正序</strong>的，这是因为完全背包较高重量的结果跟同一层较低质量的有关，所以<strong>依赖更新后的dp数组</strong>。而01背包依赖的都是上一层的结果，所以要避免在使用前就被更新，所以要倒序遍历。</p><p>这里第二层for循环<code>for (int j = coins[i]; j &lt;= amount; j ++)</code>就改变了遍历起始点，呼应了之前所说的。</p><h3 id="377-组合总数"><a href="#377-组合总数" class="headerlink" title="377. 组合总数"></a>377. 组合总数</h3><p>在<a href="#518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2">518.零钱兑换</a>的一维dp数组的基础上，交换for循环的顺序就是计算排列数了。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">uint64_t</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= target; j ++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>                <span class="hljs-keyword">if</span>(j &lt; nums[i])<span class="hljs-keyword">continue</span>;<br>                dp[j] += dp[j - nums[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>为什么？交换顺序后，循环的含义变成了在给定的容量内遍历所有值，凑出给定的容量。在固定容量为j(dp[j])的情况下，遍历所有值nums[i]，意味着找出了所有以nums[i]为结尾的组合。在循环中将这些组合数都加起来了(<code>dp[j] += dp[j - nums[i]]</code>)，最终就能得到容量为j下的排列数。即**<code>dp[j]</code>的含义是容量为j的所有排列数**。从左往右遍历到target，就能得到结果。</p><p>此外，求排列时**dp数组初始化应该是<code>dp[0]</code>为1，其余都是0。**dp数组的大小跟求组合数时相同。</p><h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a>322. 零钱兑换</h3><p><a href="https://leetcode.cn/problems/coin-change/description/">原题链接</a></p><p>完全背包问题，dp数组的含义是刚好凑成目标金额的最少硬币个数。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= amount; j ++)&#123;<br>            <span class="hljs-keyword">if</span>(j % coins[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)dp[j] = j / coins[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = coins[i]; j &lt;= amount; j ++)&#123;<br>                <span class="hljs-keyword">if</span>(dp[j] != <span class="hljs-number">-1</span> &amp;&amp; dp[j - coins[i]] != <span class="hljs-number">-1</span>)dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j - coins[i]] + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[j - coins[i]] != <span class="hljs-number">-1</span>)dp[j] = dp[j - coins[i]] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>转移方程是<code>dp[j] = min(dp[j], dp[j - coins[i]] + 1)</code>不取新硬币的硬币总数和取新硬币的硬币总数取较小值。for循环中的<code>if(dp[j] != -1 &amp;&amp; dp[j - coins[i]] != -1)</code>和<code>else if(dp[j - coins[i]] != -1)</code>是针对-1的处理。</p><h3 id="139单词拆分"><a href="#139单词拆分" class="headerlink" title="139单词拆分"></a>139单词拆分</h3><p>隐式的完全背包，排列问题。要移动字符串的分割点，与字典比对来判断是否能匹配上。dp数组dp[i]的含义是字符串s的前i个字符可以被完全表示。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;<br>        vector&lt;string&gt; word_set;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; word : wordDict) &#123;<br>            word_set.<span class="hljs-built_in">push_back</span>(word);<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size() + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> startIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= s.<span class="hljs-built_in">size</span>(); j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; word_set.<span class="hljs-built_in">size</span>(); i++) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt;= word_set[i].<span class="hljs-built_in">size</span>()) &#123;<br>                    startIndex = j - word_set[i].<span class="hljs-built_in">size</span>();<br>                    <span class="hljs-keyword">if</span> (word_set[i] ==<br>                        s.<span class="hljs-built_in">substr</span>(startIndex, word_set[i].<span class="hljs-built_in">size</span>())) &#123;<br>                        dp[j] = dp[j] || dp[j - word_set[i].<span class="hljs-built_in">size</span>()];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>自己最初写的版本。之所以说是排列问题，是因为字符串匹配有顺序差别。比如s&#x3D;”aaaaaaa”，用”aaa”和”aaaa”匹配，当组合算的话就会输出false。我们的dp数组要把所有可以被完全表示的分割点位置都列举出来，这个例子的dp数组就应该是{1,0,0,1,1,0,1,1}。表示s的子序列长度从0到7的表示情况。<br>上面的代码思路比较简单，两层for循环，外层<code>for (int j = 0; j &lt;= s.size(); j++)</code>遍历子序列长度，内层<code>for (int i = 0; i &lt; word_set.size(); i++)</code>遍历字典内容。比对内容是当前位置(j)往前推一个当前字典元素长度<code>word_set[i].size()</code>。用的vector做比对，时间复杂度比较高。常用的是下面的版本：<br>使用哈希表的优化版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;<br>        unordered_set&lt;string&gt; wordSet;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;word : wordDict)&#123;<br>            wordSet.<span class="hljs-built_in">insert</span>(word);<br>        &#125;<br>        vector&lt;<span class="hljs-type">bool</span>&gt;<span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= s.<span class="hljs-built_in">size</span>(); j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; j; i ++)&#123;<br>                string tmp = s.<span class="hljs-built_in">substr</span>(i, j - i);<br>                <span class="hljs-keyword">if</span>(wordSet.<span class="hljs-built_in">count</span>(tmp) &amp;&amp; dp[i])dp[j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用unordered_set，使查找的时间复杂度变为o(1)。此外，dp数组的含义没变 ，但是循环的含义变了。外层循环<code>for(int j = 0; j &lt;= s.size(); j++)</code>依旧是遍历子串长度(j是子串截止位置)，内层循环<code>for(int i = 0; i &lt; j; i ++)</code>遍历子串起始位置i。取出的子串是<code>s.substr(i, j - i)</code>。只有当取出的子串匹配上字典，而且子串开头位置是能被完全表示(<code>dp[i] == true</code>, 对应代码中的<code>if(wordSet.count(tmp) &amp;&amp; dp[i])</code>)才认为当前的分割点j分割出的前j个字符组成的字符串是能被完全表示的，<code>dp[j] = true</code>。</p><h3 id="背包问题学习总结"><a href="#背包问题学习总结" class="headerlink" title="背包问题学习总结"></a>背包问题学习总结</h3><p>这份总结归纳了从 <a href="#01%E8%83%8C%E5%8C%85">01背包</a> 到 <a href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85">完全背包</a> 及其常见变体的核心思想和解题范式。</p><hr><h4 id="1-两大核心模型对比：01背包-vs-完全背包"><a href="#1-两大核心模型对比：01背包-vs-完全背包" class="headerlink" title="1. 两大核心模型对比：01背包 vs 完全背包"></a>1. 两大核心模型对比：01背包 vs 完全背包</h4><p>背包问题的核心区别在于“物品是否可以重复选取”。</p><table><thead><tr><th align="left">特性</th><th align="left"><a href="#01%E8%83%8C%E5%8C%85">01背包</a></th><th align="left"><a href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85">完全背包</a></th></tr></thead><tbody><tr><td align="left"><strong>物品限制</strong></td><td align="left">每件物品<strong>只有1个</strong></td><td align="left">每件物品有<strong>无限个</strong></td></tr><tr><td align="left"><strong>二维状态转移</strong></td><td align="left"><code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i])</code></td><td align="left"><code>dp[i][j] = max(dp[i - 1][j], dp[i][j - w[i]] + v[i])</code></td></tr><tr><td align="left"><strong>核心差异</strong></td><td align="left">决策“放”物品时，依赖<strong>上一行</strong> <code>dp[i-1]</code> 的状态</td><td align="left">决策“放”物品时，依赖<strong>当前行</strong> <code>dp[i]</code> 的状态</td></tr><tr><td align="left"><strong>一维优化（滚动数组）</strong></td><td align="left"><strong>倒序</strong>遍历背包容量 (<code>j</code> 从 <code>n</code> 到 <code>0</code>)</td><td align="left"><strong>正序</strong>遍历背包容量 (<code>j</code> 从 <code>0</code> 到 <code>n</code>)</td></tr><tr><td align="left"><strong>一维优化原因</strong></td><td align="left">倒序是为了保证 <code>dp[j - w[i]]</code> 存储的是<strong>上一行</strong> (<code>i-1</code>) 的结果，防止物品被重复计算。</td><td align="left">正序是为了保证 <code>dp[j - w[i]]</code> 存储的是<strong>当前行</strong> (<code>i</code>) 已更新的结果，从而实现物品的重复选取。</td></tr></tbody></table><hr><h4 id="2-背包问题的目标变体"><a href="#2-背包问题的目标变体" class="headerlink" title="2. 背包问题的目标变体"></a>2. 背包问题的目标变体</h4><p>根据 <code>dp</code> 数组含义和状态转移方程的不同，背包问题可以解决不同目标。</p><h5 id="2-1-求最大价值-重量（最值问题）"><a href="#2-1-求最大价值-重量（最值问题）" class="headerlink" title="2.1 求最大价值 &#x2F; 重量（最值问题）"></a>2.1 求最大价值 &#x2F; 重量（最值问题）</h5><p>这是最经典的形式，<code>dp[j]</code> 含义是容量为 <code>j</code> 时能装的最大价值。</p><ul><li><strong>转移方程</strong>：<code>dp[j] = max(dp[j], dp[j - w[i]] + v[i])</code></li><li><strong>应用实例</strong>：<ul><li><a href="#416%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86">416.分割等和子集</a>：判断背包能否“刚好装满”。<code>dp</code> 数组存最大价值，最后判断 <code>dp[sum / 2] == sum / 2</code>。</li><li><a href="#1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F">1049.最后一块石头的重量</a>：目标是让两堆石头重量最接近 <code>sum / 2</code>。<code>dp</code> 数组存容量为 <code>j</code> 时能装的最大重量，结果为 <code>abs(sum - 2 * dp.back())</code>。</li></ul></li></ul><h5 id="2-2-求方法总数（组合问题）"><a href="#2-2-求方法总数（组合问题）" class="headerlink" title="2.2 求方法总数（组合问题）"></a>2.2 求方法总数（组合问题）</h5><p><code>dp</code> 数组的含义变为“装满容量 <code>j</code> 有多少种方法”。</p><ul><li><strong>转移方程</strong>：<code>dp[j] += dp[j - w[i]]</code> (累加方法数)</li><li><strong>应用实例</strong>：<ul><li><a href="#494%E7%9B%AE%E6%A0%87%E5%92%8C">494.目标和</a>：01背包求组合数。通过数学转换为“装满 <code>(sum + target) / 2</code> 容量”的方法数。注意初始化 <code>dp[0]</code> 和处理 <code>nums[i] == 0</code> 的情况。</li><li><a href="#518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2">518.零钱兑换</a>：完全背包求组合数。</li></ul></li></ul><h5 id="2-3-求最小-最大数量（最值问题）"><a href="#2-3-求最小-最大数量（最值问题）" class="headerlink" title="2.3 求最小&#x2F;最大数量（最值问题）"></a>2.3 求最小&#x2F;最大数量（最值问题）</h5><p><code>dp</code> 数组的含义变为“装满容量 <code>j</code> 所需的最小&#x2F;最大物品数量”。</p><ul><li><strong>转移方程</strong>：<code>dp[j] = min(dp[j], dp[j - w[i]] + 1)</code></li><li><strong>初始化</strong>：求最小值时，通常将 <code>dp[0]</code> 初始化为0，其余初始化为-1或一个极大值。</li><li><strong>应用实例</strong>：<ul><li><a href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2">322. 零钱兑换</a>：完全背包求装满 <code>amount</code> 的<strong>最少硬币个数</strong>。</li><li><a href="#474-%E4%B8%80%E5%92%8C%E9%9B%B6">474. 一和零</a>：01背包求<strong>最大子集长度</strong>。这是一个多维背包，<code>dp[i][j]</code> 含义是 <code>i</code> 个0和 <code>j</code> 个1能构成的最大子集长度，转移方程为 <code>dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)</code>。</li></ul></li></ul><hr><h4 id="3-组合与排列问题：循环顺序的微妙之处"><a href="#3-组合与排列问题：循环顺序的微妙之处" class="headerlink" title="3. 组合与排列问题：循环顺序的微妙之处"></a>3. 组合与排列问题：循环顺序的微妙之处</h4><p>在求方法总数的完全背包问题中，内外层循环的顺序决定了求的是“组合”还是“排列”。</p><ul><li><p><strong>求组合数：<a href="#518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2">518.零钱兑换</a></strong></p><ul><li><strong>循环顺序</strong>：<strong>外层遍历物品</strong>，<strong>内层遍历背包</strong>。</li><li><strong>代码</strong>：<code>for (item : items) { for (j = w[i]; j &lt;= V; j++) { ... } }</code></li><li><strong>含义</strong>：<code>dp[j]</code> 考虑了用<em>前 <code>i</code> 种物品</em>凑成 <code>j</code> 的方法数，不考虑物品的添加顺序。</li></ul></li><li><p><strong>求排列数：<a href="#377-%E7%BB%84%E5%90%88%E6%80%BB%E6%95%B0">377. 组合总数</a></strong></p><ul><li><strong>循环顺序</strong>：<strong>外层遍历背包</strong>，<strong>内层遍历物品</strong>。</li><li><strong>代码</strong>：<code>for (j = 0; j &lt;= V; j++) { for (item : items) { ... } }</code></li><li><strong>含义</strong>：<code>dp[j]</code> 变成了“容量为 <code>j</code> 的所有排列数”。在固定容量 <code>j</code> 时，遍历所有物品，找出了所有以 <code>nums[i]</code> <em>结尾</em>的排列。</li><li><a href="#139%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86">139单词拆分</a> 也是一个排列问题，因为单词的顺序至关重要。</li></ul></li></ul><hr><h4 id="4-常见问题转化"><a href="#4-常见问题转化" class="headerlink" title="4. 常见问题转化"></a>4. 常见问题转化</h4><p>很多问题需要先“翻译”成背包模型才能求解。</p><ul><li><p><strong><a href="#416%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86">416.分割等和子集</a></strong></p><ul><li><strong>转化</strong>：是否可以从 <code>nums</code> 中选取若干数，使其和<strong>恰好</strong>为 <code>sum / 2</code>。</li><li><strong>模型</strong>：01背包，容量 <code>V = sum / 2</code>，物品 <code>i</code> 的重量 <code>w[i] = nums[i]</code>，价值 <code>v[i] = nums[i]</code>。</li></ul></li><li><p><strong><a href="#1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F">1049.最后一块石头的重量</a></strong></p><ul><li><strong>转化</strong>：将石头分为两堆，使其重量差 <code>abs(sumA - sumB)</code> 最小。即 <code>abs(sum - 2 * sumB)</code> 最小。</li><li><strong>模型</strong>：01背包，容量 <code>V = sum / 2</code>，物品 <code>i</code> 的重量 <code>w[i] = stones[i]</code>，价值 <code>v[i] = stones[i]</code>。目标是求 <code>dp[V]</code> 的最大值（最接近 <code>V</code> 的值），最终结果为 <code>abs(sum - 2 * dp[V])</code>。</li></ul></li><li><p><strong><a href="#494%E7%9B%AE%E6%A0%87%E5%92%8C">494.目标和</a></strong></p><ul><li><strong>转化</strong>：设加 <code>+</code> 的为一堆 <code>P</code>，加 <code>-</code> 的为一堆 <code>N</code>。<code>sum(P) - sum(N) = target</code>。又 <code>sum(P) + sum(N) = sum</code>。两式相加得 <code>2 * sum(P) = sum + target</code>。</li><li><strong>模型</strong>：01背包求组合数，容量 <code>V = (sum + target) / 2</code>。目标是求装满 <code>V</code> 有多少种方法。</li></ul></li><li><p><strong><a href="#474-%E4%B8%80%E5%92%8C%E9%9B%B6">474. 一和零</a></strong></p><ul><li><strong>转化</strong>：物品是字符串，背包有两个维度的容量：<code>m</code> 个0和 <code>n</code> 个1。</li><li><strong>模型</strong>：多维01背包。<code>dp[i][j]</code> 表示 <code>i</code> 个0和 <code>j</code> 个1容量下的最大子集长度。</li></ul></li></ul><h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a>198.打家劫舍</h3><p><a href="https://leetcode.cn/problems/house-robber/description/">原题链接</a></p><p>由于约束不能取相邻的房屋，所以要偷取最大金额的话偷取间隔只能是1或2，也就是偷完编号为i的房屋之后只能偷i+2或i+3。这样将dp[i]定义为第i个房屋处的最大收益，就可以通过两个或三个之前的房屋的收益加上当前房屋的金额，取较大值就可以了。最终结果也在后两个值中取较大值（对应抢或不抢最后一家）。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">2</span>] = nums[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">3</span>] + nums[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[nums.<span class="hljs-built_in">size</span>()], dp[nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>转移方程是 <code>dp[i] = max(dp[i - 2] + nums[i - 1], dp[i - 3] + nums[i - 1]);</code><br><strong>当前状态和前面状态会有一种依赖关系，那么这种依赖关系都是动规的递推公式。</strong></p><p>下面是标准解法，dp[i]的定义是考虑前i个房子，打劫得的最大总金额。跟我们上面的解法的最大区别是<strong>标准解法并不一定打劫i号房子</strong>。那么新的转移逻辑就是dp[i]取打劫上一个房屋且不打劫当前房屋，和打劫上上个房屋以及当前房屋所得金额的较大值。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>转移公式是<code>dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])</code></p><h3 id="LCR-090-打家劫舍II"><a href="#LCR-090-打家劫舍II" class="headerlink" title="LCR 090.打家劫舍II"></a>LCR 090.打家劫舍II</h3><p><a href="https://leetcode.cn/problems/PzWKhm/description/">原题链接</a></p><p>在<a href="#198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D">198</a>的基础上变成了环形，意味着第一个和最后一个房屋不能同时选。可以把问题拆分成两个，即去掉第一个房屋后的所有房屋正常打劫和去掉最后一个房屋后的所有房屋正常打劫，两个结果取较大值。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob_func</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vector1</span><span class="hljs-params">(nums.begin(), nums.end() - <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vector2</span><span class="hljs-params">(nums.begin() + <span class="hljs-number">1</span>, nums.end())</span></span>;<br>        <span class="hljs-type">int</span> result1 = <span class="hljs-built_in">rob_func</span>(vector1);<br>        <span class="hljs-type">int</span> result2 = <span class="hljs-built_in">rob_func</span>(vector2);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(result1, result2);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="337-打家劫舍III"><a href="#337-打家劫舍III" class="headerlink" title="337. 打家劫舍III"></a>337. 打家劫舍III</h3><p><a href="https://leetcode.cn/problems/house-robber-iii/">原题链接</a></p><p>在二叉树上进行打劫。根节点的最大打劫金额跟左右孩子有关，打劫根节点就不能打劫左右孩子，不打劫根节点既可以打劫孩子又可以不打，取较大值。所以需要后序遍历。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result = <span class="hljs-built_in">robTree</span>(root);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(result[<span class="hljs-number">0</span>], result[<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-comment">// 长度为2的数组，0：不偷，1：偷</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">robTree</span><span class="hljs-params">(TreeNode* cur)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        vector&lt;<span class="hljs-type">int</span>&gt; left = <span class="hljs-built_in">robTree</span>(cur-&gt;left);<br>        vector&lt;<span class="hljs-type">int</span>&gt; right = <span class="hljs-built_in">robTree</span>(cur-&gt;right);<br>        <span class="hljs-comment">// 偷cur，那么就不能偷左右节点。</span><br>        <span class="hljs-type">int</span> val1 = cur-&gt;val + left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况</span><br>        <span class="hljs-type">int</span> val2 = <span class="hljs-built_in">max</span>(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>]) + <span class="hljs-built_in">max</span>(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> &#123;val2, val1&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>正如代码中的备注，使用一对值来描述偷与不偷当前节点。特别注意这里的不偷cur，不偷cur并不意味着一定要偷左右孩子，这时候要先分别比较左孩子偷与不偷的收益，右孩子偷与不偷的收益。</p><h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">原题链接</a></p><p>dp数组的含义是dp[i][0]表示第i天不持有股票的现金,dp[i][1]表示第i填持有股票的现金。则转移过程为dp[i][0]可以是昨天也不持有的现金和昨天持有，今天卖出的较大值，dp[i][1]为昨天也持有的现金和昨天不持有，今天买入的现金的较大值。由于只能买卖一次，那么买入股票前的现金一定是0(因为这时不会有收益)。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">1</span> - (i % <span class="hljs-number">2</span>)][<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span> - (i % <span class="hljs-number">2</span>)][<span class="hljs-number">1</span>] + prices[i]);<br>            dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(- prices[i], dp[<span class="hljs-number">1</span> - (i % <span class="hljs-number">2</span>)][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[(prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// return dp[3][0];</span><br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>实现中因为当天的状态更新只与前一天有关，所以利用滚动数组减少空间占用。</p><p>状态转移公式为<code>dp[i % 2][0] = max(dp[1 - (i % 2)][0], dp[1 - (i % 2)][1] + prices[i])</code>和<code>dp[i % 2][1] = max(- prices[i], dp[1 - (i % 2)][1])</code>，这里<code>dp[i % 2][1]是从- prices[i]</code>和<code>dp[1 - (i % 2)][1]</code>取较大值，前者意味着0-prices[0]，对应买股票之前的现金一定是0。</p><h3 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122 买卖股票的最佳时机 II"></a>122 买卖股票的最佳时机 II</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">原题链接</a></p><p>相较于<a href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA">上一题</a>，II不限次数买卖股票。其实跟I只有一点不同，即本题要考虑在买股票之前的现金，不一定为0了。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">1</span> - i % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>], prices[i] + dp[<span class="hljs-number">1</span> - i % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>]);<br>            dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">1</span> - i % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] - prices[i], dp[<span class="hljs-number">1</span> - i % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[((prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>)][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看出只有一点不同，即<code>dp[i % 2][1] = max(dp[1 - i % 2][0] - prices[i], dp[1 - i % 2][1]);</code>max中的第一项要考虑前一天不持有股票的现金，即<code>dp[1 - i % 2][0]</code>。</p><h3 id="123-买卖股票的最佳时机III"><a href="#123-买卖股票的最佳时机III" class="headerlink" title="123. 买卖股票的最佳时机III"></a>123. 买卖股票的最佳时机III</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">原题链接</a></p><p>现在限制最多只能完成两笔交易，那就要把状态分清楚。比如第一次买入，第一次卖出，第二次买入，第二次卖出。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">1</span> - i % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>], -prices[i]);<br>            dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">1</span> - i % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>], dp[<span class="hljs-number">1</span> - i % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] + prices[i]);<br>            dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">1</span> - i % <span class="hljs-number">2</span>][<span class="hljs-number">2</span>], dp[<span class="hljs-number">1</span> - i % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] - prices[i]);<br>            dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">1</span> - i % <span class="hljs-number">2</span>][<span class="hljs-number">3</span>], dp[<span class="hljs-number">1</span> - i % <span class="hljs-number">2</span>][<span class="hljs-number">2</span>] + prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[(prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">3</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当天第一次买入之前现金都是0，所以第一次买入后的现金取<code>dp[1 - i % 2][0]</code>和<code>-prices[i]</code>的较小值，和<a href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA">最佳时机I</a>是类似的。此后的状态更新都与上一层有关，现金状态都是继承的上一层。所以可以推广到买卖k次，也就是下一题。</p><h3 id="188-买卖股票的最佳时机IV"><a href="#188-买卖股票的最佳时机IV" class="headerlink" title="188. 买卖股票的最佳时机IV"></a>188. 买卖股票的最佳时机IV</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">原题链接</a></p><p>现在要求最多买卖k次，由<a href="#123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAiii">买卖股票III</a>可知，第i次交易的现金仅取决于第i-1次交易。所以可以使用两层循环，外层循环遍历日期，内层循环遍历交易次数。也就是先交易完第j天的所有k次交易，再进入第二天。这样一来dp数组的定义如下：dp[i][0]表示当前是第i次交易，0代表持有股票；dp[i][1]表示当前是第i次交易,1代表不持有股票。初始化时将dp[0][0]设为购买第一天的股票之后的现金。这样一来第j天的所有交易结束后，<strong>第二天时会在原地覆盖dp数组。</strong></p><p>我一开始有疑问，为什么可以这样覆盖？第二天的第一次交易的dp数组不应该根据第一天第一次交易的dp数组来推导吗？<br>实际上，当递推到第二天，要决策今天第i笔交易时，按照<a href="#123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAiii">123</a>的经验,我们确实要依赖第一天的第i笔交易的结果。可是昨天第i笔交易对应的dp数组的含义是<strong>前i笔交易</strong>的最优解，是持有现金的最大值。<strong>如果在第i笔交易中，我们依照的昨天的dp[i]不是最优解，那么使用这个次优解算出来的结果一定会被之后第i + n笔交易中，由昨天的dp[i + n]算出来的今天的dp[i + n]所超越。</strong> 现在的算法（把一天中迭代k次得到的最优解传递到下一天）实际上相当于省略了用次优解迭代的过程。</p><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(k + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= k; i ++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; prices.<span class="hljs-built_in">size</span>(); j ++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i ++)&#123;<br>                dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[j]);<br>                dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i][<span class="hljs-number">1</span>], dp[i][<span class="hljs-number">0</span>] + prices[j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>实现上dp数组多了一个维度存储最开始的状态，将所有持有股票的状态都设为<code>-prices[0]</code>。循环从j &#x3D; 1, i &#x3D; 1开始，也就是第二天和第1次交易。递推公式跟之前的没有区别。</p><h3 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a>309. 最佳买卖股票时机含冷冻期</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">原题链接</a></p><p>相比于<a href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii">122</a>，新增了卖出后第三天才能买的限制。只要把更新当天买入的dp数组的逻辑改成判断昨天的买入和前天卖出今天买入的最大值就可以了。记得处理一下第二天的边界条件。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = - prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>)&#123;<br>                dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], - prices[<span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] - prices[i]);<br>            &#125;<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714.买卖股票的最佳时机含手续费"></a>714.买卖股票的最佳时机含手续费</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">原题链接</a></p><p>在<a href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii">122</a>的基础上，每次交易加上手续费就好。买入时加上和卖出时加上都可以。差别只在持股状态的现金。买入时-fee得到的持股现金是扣过费的，空仓状态下的现金是完全一样的。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices, <span class="hljs-type">int</span> fee)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = - prices[<span class="hljs-number">0</span>] - fee;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i] - fee);<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300.最长递增子序列"></a>300.最长递增子序列</h3><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">原题链接</a></p><p>dp[i]的含义是以nums[i]结尾的递增子序列长度。这样我们一项一项更新dp[i]就可以得到最长的了。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j])dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>            result = <span class="hljs-built_in">max</span>(result, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>更新dp[i]的逻辑是从0到i搜索比nums[i]更小的nums[j],找到了就说明当前的nums[i]可以接在nums[j]的后面。那么以nums[i]结尾的递增子序列长度就要取没接之前的长度(dp[i])和接了之后的长度(dp[j] + 1)的较大值。</p><h3 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718.最长重复子数组"></a>718.最长重复子数组</h3><p><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">原题链接</a></p><p>dp数组为dp[i][j]，含义是以nums2[i]结尾和nums1[j]结尾的子数组长度。那么dp[i][j]的值取决于dp[i - 1][j - 1]的值。如果nums2[i]和nums1[j]相等，则dp[i][j] &#x3D; dp[i - 1][j - 1] + 1。否则为0。由于要用到i - 1和j - 1，所以要初始化i &#x3D; 0和j &#x3D; 0的所有值。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(nums<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>(); i ++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = nums2[i] == nums1[<span class="hljs-number">0</span>];<br>            result = <span class="hljs-built_in">max</span>(result, dp[i][<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(); j ++)&#123;<br>            dp[<span class="hljs-number">0</span>][j] = nums1[j] == nums2[<span class="hljs-number">0</span>];<br>            result = <span class="hljs-built_in">max</span>(result, dp[<span class="hljs-number">0</span>][j]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; nums<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(); j ++)&#123;<br>                <span class="hljs-keyword">if</span>(nums1[j] == nums2[i])&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>                result = <span class="hljs-built_in">max</span>(result, dp[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果一开始定义数组时多定义一格，即<code>vector&lt;vector&lt;int&gt;&gt; dp(nums2.size() + 1, vector&lt;int&gt;(nums1.size() + 1, 0));</code>那么初始化第一行第一列的过程就可以同样放在循环内执行。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(nums<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= nums<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= nums<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(); j ++)&#123;<br>                <span class="hljs-keyword">if</span>(nums1[j - <span class="hljs-number">1</span>] == nums2[i - <span class="hljs-number">1</span>])&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>                result = <span class="hljs-built_in">max</span>(result, dp[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意到<code>dp[i][j]</code>的更新只与左上角有关，可以优化成滚动数组。代码如下 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums<span class="hljs-number">1.</span>size() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>(); j ++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = nums<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(); i &gt;= <span class="hljs-number">1</span>; i --)&#123;<br>                <span class="hljs-keyword">if</span>(nums1[i - <span class="hljs-number">1</span>] == nums2[j])&#123;<br>                    dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                    result = <span class="hljs-built_in">max</span>(dp[i], result);<br>                &#125;<br>                <span class="hljs-keyword">else</span> dp[i] = <span class="hljs-number">0</span>;               <br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>跟背包问题数组降维类似，这里dp[i]的更新依赖于更新前的dp[i - 1]，所以第二层循环从右往左遍历。此外，不需要额外的初始化循环。因为一开始dp数组就是全0的，第一次循环的逻辑并没有什么特别的地方。</p><h3 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143.最长公共子序列"></a>1143.最长公共子序列</h3><p><a href="https://leetcode.cn/problems/longest-common-subsequence/description/">原题链接</a></p><p>dp数组的含义是dp[i][j]表示text2的前i - 1长度和text1的前j - 1长度子序列的最大公共长度。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(text<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(text<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= text<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>(); i ++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= text<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(); j ++)&#123;<br>                    <span class="hljs-keyword">if</span>(text2[i - <span class="hljs-number">1</span>] == text1[j - <span class="hljs-number">1</span>])dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">back</span>();<br>    &#125;   <br>&#125;;<br></code></pre></td></tr></table></figure><p>转移过程是<br><code>dp[i][j] = dp[i - 1][j - 1] + 1;</code>和<code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);</code><br>当<code>text2[i - 1] == text1[j - 1]</code>时说明当前字符匹配上了，公共子序列的长度在左上角<code>dp[i - 1][j - 1]</code>的基础上+1。否则取上面<code>dp[i - 1][j]</code>和下面<code>dp[i][j - 1]</code>的较大值。</p><h3 id="1035-不相交的线"><a href="#1035-不相交的线" class="headerlink" title="1035. 不相交的线"></a>1035. 不相交的线</h3><p><a href="https://leetcode.cn/problems/uncrossed-lines/description/">原题链接</a></p><p>跟<a href="#1143%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97">1143.最长公共子序列</a>是一模一样的。</p><h3 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115. 不同的子序列"></a>115. 不同的子序列</h3><p><a href="https://leetcode.cn/problems/distinct-subsequences/description/">原题链接</a></p><p>dp数组的含义是dp[i][j]表示t的前i个字符组成的子串和s的前j个子串匹配，t的子串出现的次数。状态转移考虑当前字符匹配上和不匹配上两种情况。如果匹配上，又可以分出两种情况。第一种末尾选择t[i - 1]，可以看作是<em>t的前i-1个字符的子串</em>在<em>s的前j-1个字符的子串</em>中出现次数的延申，另一种情况末尾不选择t[i - 1]，退化成t的前i个字符在s的前j-1个字符中出现的情况。这两种情况加起来就是匹配上的转移过程。如果匹配不上就跟dp[i][j-1]一样了。</p><p>初始化时要把i &#x3D; 0的情况全赋为1，除了i &#x3D; 0以外的第一列(j &#x3D; 0)都赋为0.因为i &#x3D; 0的情况本质上是空字符串与s的匹配数量，肯定是1.代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">uint64_t</span>&gt;&gt; <span class="hljs-built_in">dp</span>(t.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= s.<span class="hljs-built_in">size</span>(); j ++)dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= t.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt;= s.<span class="hljs-built_in">size</span>(); j ++)&#123;<br>                <span class="hljs-keyword">if</span>(t[i - <span class="hljs-number">1</span>] == s[j - <span class="hljs-number">1</span>])dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i][j - <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[t.<span class="hljs-built_in">size</span>()][s.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;; <br></code></pre></td></tr></table></figure><p>匹配上的状态转移为<code>dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1]</code>,匹配不上为<code>dp[i][j] = dp[i][j - 1]</code>。</p><h3 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583.两个字符串的删除操作"></a>583.两个字符串的删除操作</h3><p><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/description/">原题链接</a></p><p>题目要求删除最少的字符数，使两个字符串相等。可以转换成求两个字符串的最大相等子串长度，即<a href="#1143%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97">1143题</a>。最后对结果处理一下就可以了。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(word<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (word<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= word<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= word<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(); j++)&#123;<br>                <span class="hljs-keyword">if</span>(word2[i - <span class="hljs-number">1</span>] == word1[j - <span class="hljs-number">1</span>])&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> word<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() + word<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span> * dp[word<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>()][word<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h3><p><a href="https://leetcode.cn/problems/edit-distance/description/">原题链接</a></p><p>dp数组的含义是dp[i][j]代表word2的前i项，word1的前j项的最小编辑距离。状态更新中，dp[i][j]有两种情况，取决于word2[i-1]和word1[j-1]的相等情况。</p><ol><li>如果相等，那么当前等价于word2和word1都舍去尾部相等的这个元素，退化成<code>dp[i-1][j-1]</code>。</li><li>如果不等，我们可以通过<em>删除word1的一个元素</em>、<em>删除word2的一个元素</em>和<em>改变一个元素</em>这三种方法将目前状态转换成我们已经推导出来的状态。上述三种操作分别对应得到<code>dp[i][j - 1]</code>、<code>dp[i - 1][j]</code>、<code>dp[i - 1][j - 1]</code>，并且加上我们的一次操作数。取这三种操作的最小值就是不相等情况的转移方程了。(题目还支持插入字符，但是其实对word1插入一个字符跟删除word2的一个字符是等效的)</li></ol><p>至于初始化，要从定义出发。比如dp[0][j]的含义是word1是空字符串，转换成word1的操作数自然就是word1的长度j了。</p><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(word<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(word<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= word<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>(); i ++)dp[i][<span class="hljs-number">0</span>] = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= word<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(); j ++)dp[<span class="hljs-number">0</span>][j] = j;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= word<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= word<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(); j ++)&#123;<br>                <span class="hljs-keyword">if</span>(word2[i - <span class="hljs-number">1</span>] == word1[j - <span class="hljs-number">1</span>])dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>, dp[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[word<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>()][word<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>()];<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>编辑距离问题，乃至涉及两个字符串、序列的各种操作比较，dp数组的定义都是从分割出来的子序列着手。由相不相等进一步推导出转移方程。</p><h3 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647.回文子串"></a>647.回文子串</h3><p><a href="https://leetcode.cn/problems/palindromic-substrings/description/">原题链接</a></p><p>dp数组的含义是dp[i][j]表示从i到j的子串是不是回文子串。更新dp数组的过程中，如果s[i] &#x3D;&#x3D; s[j]，那么dp[i][j]就依赖于在此基础上去头去尾的子串是不是回文串，即dp[i + 1][j - 1]。由于要用到i + 1的dp值，这里i要反向遍历。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>));<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt; s.<span class="hljs-built_in">size</span>(); j ++)&#123;<br>                <span class="hljs-keyword">if</span>(s[i] == s[j])&#123;<br>                    <span class="hljs-keyword">if</span> (j - i &lt; <span class="hljs-number">2</span>)dp[i][j] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">else</span> dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">if</span>(dp[i][j])result ++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>除了要注意反向遍历i<code>for(int i = s.size() - 1; i &gt;= 0; i --)</code>，还要单独考虑s[i] &#x3D;&#x3D; s[j]时子串长度小于等于2的情况。即<code>if (j - i &lt; 2)dp[i][j] = true</code></p><h3 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a>516. 最长回文子序列</h3><p><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/description/">原题链接</a></p><p>dp[i][j]代表给定字符串从i到j的最长回文子序列长度。跟<a href="#647%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2">647题</a>类似，如果s[i] &#x3D;&#x3D; s[j]，那么当前子串是不是回文串取决于s[i + 1]到s[j - 1]的子串是不是回文串。即dp[i + 1][j - 1]。在此基础上加二作为新增的首尾就行。如果s[i] !&#x3D; s[j]，那么当前子串的最长回文子序列长度是s[i + 1]到s[j]和s[i]到s[j - 1]的较大值。为什么？因为既然首位不相等，那么s[i]和s[j]绝对不能作为一个回文串的两端。那么包含s[i]和s[j]的最长回文串，要么不包含s[i]，要么不包含s[j]。取这两种情况的最大值，即dp[i + 1][j]和dp[i][j - 1]的较大值。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>                dp[i][i] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; s.<span class="hljs-built_in">size</span>(); j ++)&#123;<br>                    <span class="hljs-keyword">if</span>(s[i] == s[j])dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>                    <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j - <span class="hljs-number">1</span>], dp[i + <span class="hljs-number">1</span>][j]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>dynamic-programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你好，世界</title>
    <link href="/2026/01/16/hello-world/"/>
    <url>/2026/01/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>欢迎使用 <a href="https://hexo.io/zh-cn/">Hexo</a>！这是你的第一篇文章。</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&quot;我的新文章&quot;</span><br></code></pre></td></tr></table></figure><h3 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo server<br></code></pre></td></tr></table></figure><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
