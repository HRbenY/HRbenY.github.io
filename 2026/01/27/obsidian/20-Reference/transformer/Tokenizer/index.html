<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Tokenizer | Spa-Master 的博客</title><meta name="author" content="HRbenY"><meta name="copyright" content="HRbenY"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 什么是分词器 (Tokenizer)？ 模型无法直接理解人类的文本（字符串），它只能处理数字。分词器的作用就是将文本转换成模型可以理解的数字序列。   流程：输入文本                    #mjx-e0c443e{         display:contents;         mjx-assistive-mml {           user-select: tex">
<meta property="og:type" content="article">
<meta property="og:title" content="Tokenizer">
<meta property="og:url" content="https://hrbeny.github.io/2026/01/27/obsidian/20-Reference/transformer/Tokenizer/index.html">
<meta property="og:site_name" content="Spa-Master 的博客">
<meta property="og:description" content="1. 什么是分词器 (Tokenizer)？ 模型无法直接理解人类的文本（字符串），它只能处理数字。分词器的作用就是将文本转换成模型可以理解的数字序列。   流程：输入文本                    #mjx-e0c443e{         display:contents;         mjx-assistive-mml {           user-select: tex">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hrbeny.github.io/img/mai.png">
<meta property="article:published_time" content="2026-01-27T07:02:17.620Z">
<meta property="article:modified_time" content="2026-01-27T07:02:17.620Z">
<meta property="article:author" content="HRbenY">
<meta property="article:tag" content="topic&#x2F;transformer">
<meta property="article:tag" content="type&#x2F;note">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hrbeny.github.io/img/mai.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Tokenizer",
  "url": "https://hrbeny.github.io/2026/01/27/obsidian/20-Reference/transformer/Tokenizer/",
  "image": "https://hrbeny.github.io/img/mai.png",
  "datePublished": "2026-01-27T07:02:17.620Z",
  "dateModified": "2026-01-27T07:02:17.620Z",
  "author": [
    {
      "@type": "Person",
      "name": "HRbenY",
      "url": "https://hrbeny.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://hrbeny.github.io/2026/01/27/obsidian/20-Reference/transformer/Tokenizer/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4-b1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Tokenizer',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Spa-Master 的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">Tokenizer</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Tokenizer</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-01-27T07:02:17.620Z" title="发表于 2026-01-27 15:02:17">2026-01-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-27T07:02:17.620Z" title="更新于 2026-01-27 15:02:17">2026-01-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="1-什么是分词器-Tokenizer-？">1. 什么是分词器 (Tokenizer)？</h2>
<p>模型无法直接理解人类的文本（字符串），它只能处理数字。分词器的作用就是将文本转换成模型可以理解的数字序列。</p>
<ul>
<li>
<p><strong>流程</strong>：输入文本 
    <span id="mjx-e0c443e">
      <style>
      #mjx-e0c443e{
        display:contents;
        mjx-assistive-mml {
          user-select: text !important;
          clip: auto !important;
          color: rgba(0,0,0,0);
        }
        
mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
  min-height: 1px;
  min-width: 1px;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-assistive-mml {
  position: absolute !important;
  top: 0px;
  left: 0px;
  clip: rect(1px, 1px, 1px, 1px);
  padding: 1px 0px 0px 0px !important;
  border: 0px !important;
  display: block !important;
  width: auto !important;
  overflow: hidden !important;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

mjx-assistive-mml[display="block"] {
  width: 100% !important;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][display="true"][width="full"] {
  display: flex;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line], svg[data-table] > g > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame], svg[data-table] > g > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed, svg[data-table] > g > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted, svg[data-table] > g > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > g > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

mjx-container[jax="SVG"] path[data-c], mjx-container[jax="SVG"] use[data-c] {
  stroke-width: 3;
}

g[data-mml-node="xypic"] path {
  stroke-width: inherit;
}

.MathJax g[data-mml-node="xypic"] path {
  stroke-width: inherit;
}

      }
      </style>
      <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.181ex" role="img" focusable="false" viewBox="0 -511 1000 522" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">→</mo></math></mjx-assistive-mml></mjx-container>
    </span>
   切分成 Token (词元) 
    <span id="mjx-207eb1e">
      <style>
      #mjx-207eb1e{
        display:contents;
        mjx-assistive-mml {
          user-select: text !important;
          clip: auto !important;
          color: rgba(0,0,0,0);
        }
        
mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
  min-height: 1px;
  min-width: 1px;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-assistive-mml {
  position: absolute !important;
  top: 0px;
  left: 0px;
  clip: rect(1px, 1px, 1px, 1px);
  padding: 1px 0px 0px 0px !important;
  border: 0px !important;
  display: block !important;
  width: auto !important;
  overflow: hidden !important;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

mjx-assistive-mml[display="block"] {
  width: 100% !important;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][display="true"][width="full"] {
  display: flex;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line], svg[data-table] > g > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame], svg[data-table] > g > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed, svg[data-table] > g > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted, svg[data-table] > g > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > g > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

mjx-container[jax="SVG"] path[data-c], mjx-container[jax="SVG"] use[data-c] {
  stroke-width: 3;
}

g[data-mml-node="xypic"] path {
  stroke-width: inherit;
}

.MathJax g[data-mml-node="xypic"] path {
  stroke-width: inherit;
}

      }
      </style>
      <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.181ex" role="img" focusable="false" viewBox="0 -511 1000 522" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">→</mo></math></mjx-assistive-mml></mjx-container>
    </span>
   映射为 ID (索引数字) 
    <span id="mjx-2784906">
      <style>
      #mjx-2784906{
        display:contents;
        mjx-assistive-mml {
          user-select: text !important;
          clip: auto !important;
          color: rgba(0,0,0,0);
        }
        
mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
  min-height: 1px;
  min-width: 1px;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-assistive-mml {
  position: absolute !important;
  top: 0px;
  left: 0px;
  clip: rect(1px, 1px, 1px, 1px);
  padding: 1px 0px 0px 0px !important;
  border: 0px !important;
  display: block !important;
  width: auto !important;
  overflow: hidden !important;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

mjx-assistive-mml[display="block"] {
  width: 100% !important;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][display="true"][width="full"] {
  display: flex;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line], svg[data-table] > g > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame], svg[data-table] > g > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed, svg[data-table] > g > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted, svg[data-table] > g > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > g > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

mjx-container[jax="SVG"] path[data-c], mjx-container[jax="SVG"] use[data-c] {
  stroke-width: 3;
}

g[data-mml-node="xypic"] path {
  stroke-width: inherit;
}

.MathJax g[data-mml-node="xypic"] path {
  stroke-width: inherit;
}

      }
      </style>
      <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.181ex" role="img" focusable="false" viewBox="0 -511 1000 522" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">→</mo></math></mjx-assistive-mml></mjx-container>
    </span>
   输入模型。</p>
</li>
<li>
<p><strong>Token 是什么</strong>：Token 可以是一个完整的单词（如 <code>is</code>），一个单词的一部分（如 <code>ization</code>），甚至是一个字符或空格。</p>
</li>
<li>
<p><strong>主流算法</strong>：GPT 系列主要使用的是 <strong>BPE (Byte Pair Encoding)</strong> 算法，旨在通过合并高频出现的字符组合来压缩文本，提高效率。</p>
</li>
</ul>
<hr>
<h2 id="2-截图场景解析与局限性-Limitations">2. 截图场景解析与局限性 (Limitations)</h2>
<p>截图中的不同色块代表了分词器将文本切分后的不同 Token。我们可以从图中展示的四个特定场景，分析 LLM 在分词层面遇到的“怪异现象”和限制：
<img src="https://cdn.jsdelivr.net/gh/HRbenY/blog-assets@master//img/20260117145252696.png" alt="Pasted image 20251228171806"></p>
<h3 id="场景一：算术与数字处理-Arithmetic">场景一：算术与数字处理 (Arithmetic)</h3>
<blockquote>
<p>截图内容：127 + 677 = 804</p>
<p>现象：数字通常不会被识别为一个整体，而是被切碎。</p>
</blockquote>
<ul>
<li>
<p><strong>局限性</strong>：<strong>破坏了数值的位值概念。</strong></p>
<ul>
<li>
<p>在 GPT-2（以及许多早期模型）的分词器中，数字往往被切分成不符合直觉的片段。例如，<code>1275</code> 可能被切分为 <code>12</code> 和 <code>75</code>，或者 <code>1</code>、<code>2</code>、<code>7</code>、<code>5</code>。</p>
</li>
<li>
<p><strong>后果</strong>：模型很难学会“进位”等数学逻辑，因为对它来说，这更像是文本拼接预测，而不是数值计算。这就是为什么 LLM 做加减法经常一本正经胡说八道的原因之一。</p>
</li>
<li>
<p><strong>改进</strong>：较新的模型（如 LLaMA 或 GPT-4）尝试将数字按每一位单独分词，以提高数学能力。</p>
</li>
</ul>
</li>
</ul>
<h3 id="场景二：大小写敏感-Case-Sensitivity">场景二：大小写敏感 (Case Sensitivity)</h3>
<blockquote>
<p>截图内容：Egg, I have an Egg, egg, EGG</p>
<p>现象：Egg (首字母大写)、egg (全小写)、EGG (全大写) 被赋予了不同的颜色，意味着它们是完全不同的 Token。</p>
</blockquote>
<ul>
<li>
<p><strong>局限性</strong>：<strong>词表浪费与语义分散。</strong></p>
<ul>
<li>
<p>虽然这三个词语义相同，但在模型眼里它们是三个完全不同的 ID。模型必须分别学习这三个 Token 的含义。</p>
</li>
<li>
<p><strong>后果</strong>：这浪费了宝贵的词表空间（Vocabulary Size），并且如果某个变体（如全大写 <code>EGG</code>）在训练数据中出现很少，模型对它的理解就会比 <code>egg</code> 差。</p>
</li>
</ul>
</li>
</ul>
<h3 id="场景三：非英语-多语言支持-Non-English-Multilingual">场景三：非英语/多语言支持 (Non-English / Multilingual)</h3>
<blockquote>
<p>截图内容：韩语段落 만나서 반갑습니다…</p>
<p>现象：韩语文本的色块非常细碎，几乎每个字甚至每个字的部件都被切成了不同的 Token。</p>
</blockquote>
<ul>
<li>
<p><strong>局限性</strong>：<strong>信息密度低，上下文窗口利用率差。</strong></p>
<ul>
<li>
<p>GPT-2 的词表主要是针对英语优化的。对于韩语、中文等非拉丁语系，分词器往往找不到对应的“整词”，只能回退到按字节或字符切分。</p>
</li>
<li>
<p><strong>后果</strong>：</p>
<ol>
<li>
<p><strong>更贵</strong>：同样的句子，中文或韩语消耗的 Token 数量远多于英语（在 GPT-2/3 时代尤其明显），调用 API 时成本更高。</p>
</li>
<li>
<p><strong>更“短”</strong>：因为 Token 数量多，同样的上下文窗口（Context Window）能容纳的非英语内容就变少了。</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="场景四：代码与格式-Code-Formatting">场景四：代码与格式 (Code &amp; Formatting)</h3>
<blockquote>
<p>截图内容：Python 代码 for i in range(1, 101):</p>
<p>现象：缩进（空格）、关键词（for, in）、标点符号都被切分。</p>
</blockquote>
<ul>
<li>
<p><strong>局限性</strong>：<strong>对格式极其敏感。</strong></p>
<ul>
<li>
<p>Python 强依赖缩进。如果分词器将 (4个空格) 识别为一个 Token，而将 (2个空格) 识别为另一个，模型就需要精确预测使用哪个 Token 来保证代码运行。</p>
</li>
<li>
<p>像 <code>FizzBuzz</code> 这样的变量名，因为不是通用单词，会被拆解为 <code>Fizz</code> + <code>Buzz</code>。如果代码中有很多生僻变量名，会显著增加 Token 消耗。</p>
</li>
</ul>
</li>
</ul>
<h3 id="对比分析：GPT-2-gpt2-vs-GPT-4-cl100k-base">对比分析：GPT-2 (<code>gpt2</code>) vs GPT-4 (<code>cl100k_base</code>)</h3>
<p>OpenAI 的模型经历了从 <code>gpt2</code> (用于 GPT-2 和 GPT-3) 到 <code>cl100k_base</code> (用于 GPT-3.5-Turbo 和 GPT-4) 的升级。这次分词器的升级对性能和成本有直接影响。
<img src="https://cdn.jsdelivr.net/gh/HRbenY/blog-assets@master//img/20260117145252697.png" alt="Pasted image 20251228172350"></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>GPT-2 Tokenizer (gpt2 / r50k_base)</strong></th>
<th><strong>GPT-4 Tokenizer (cl100k_base)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>词表大小</strong></td>
<td><strong>约 50,000 个</strong></td>
<td><strong>约 100,000 个</strong></td>
</tr>
<tr>
<td><strong>中文支持</strong></td>
<td><strong>较差</strong>。一个汉字通常被切分为 2-3 个 Token（甚至更多字节级碎片）。</td>
<td><strong>优秀</strong>。词表更大，包含了更多常用汉字。许多常见汉字现在是一个单独的 Token。</td>
</tr>
<tr>
<td><strong>代码处理</strong></td>
<td><strong>一般</strong>。对空格、缩进和常见代码关键字的优化不足。</td>
<td><strong>大幅优化</strong>。针对代码中的常见模式（如连续空格、特定函数名）进行了专门优化，压缩率更高。</td>
</tr>
<tr>
<td><strong>压缩效率</strong></td>
<td>较低。同样的文本需要更多的 Token 来表示。</td>
<td><strong>较高</strong>。同样的文本，Token 数量平均减少 <strong>15% - 20%</strong>（英文），中文减少幅度更大。</td>
</tr>
<tr>
<td><strong>数字处理</strong></td>
<td>经常将数字切碎且不规律（如 <code>1275</code> -&gt; <code>12</code>, <code>75</code>）。</td>
<td>稍微一致一些，但依然不是完美的按位切分（这主要还是 BPE 的通病）。</td>
</tr>
</tbody>
</table>
<h3 id="核心差异总结：">核心差异总结：</h3>
<ol>
<li>
<p><strong>省钱 &amp; 扩容</strong>：<code>cl100k_base</code> 最直接的好处是<strong>更省 Token</strong>。因为它的词表更大（100k），它能“一口吃下”更复杂的词，而不需要切得那么碎。这意味着对于同样的 prompt，使用 GPT-4 往往比 GPT-3 花费的 Token 更少，且能塞进上下文窗口的内容更多。</p>
</li>
<li>
<p><strong>多语言与代码能力增强</strong>：由于在训练分词器时加入了更多代码和多语言语料，<code>cl100k_base</code> 不再像 GPT-2 那样“歧视”非英语内容，这对中文开发者和程序员非常友好。</p>
</li>
</ol>
<h2 id="3-主流的分词器类型-Tokenizer-Types">3. 主流的分词器类型 (Tokenizer Types)</h2>
<p>虽然目前 GPT 系列主要使用 BPE，但在 NLP 领域主要有三种主流的分词算法，它们的核心目标都是<strong>平衡词表大小（Vocabulary Size）与文本覆盖率</strong>，尽量避免出现“未知词（[UNK]）”。</p>
<h3 id="3-1-BPE-Byte-Pair-Encoding">3.1 BPE (Byte Pair Encoding)</h3>
<ul>
<li>
<p><strong>代表模型</strong>：<strong>GPT 系列 (GPT-2, GPT-3, GPT-4)</strong>, RoBERTa, LLaMA。</p>
</li>
<li>
<p><strong>原理</strong>：统计语料中字符组合出现的频率。从单个字符开始，不断<strong>合并出现频率最高</strong>的相邻字符对，直到词表达到预设大小。</p>
</li>
<li>
<p><strong>特点</strong>：</p>
<ul>
<li>
<p>能很好地处理生僻词（通过拆解为子词）。</p>
</li>
<li>
<p>GPT 使用的是 <strong>Byte-level BPE</strong>（基于字节而非字符），这意味着它可以处理任何 Unicode 字符串（包括 emoji 和各种奇怪符号），不会出现 [UNK]。</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-2-WordPiece">3.2 WordPiece</h3>
<ul>
<li>
<p><strong>代表模型</strong>：<strong>BERT</strong>, DistilBERT。</p>
</li>
<li>
<p><strong>原理</strong>：与 BPE 类似，也是合并子词。但它在选择合并哪两个子词时，不是看频率最高，而是看<strong>合并后能最大程度增加训练数据语言模型的似然概率 (Likelihood)</strong>。</p>
</li>
<li>
<p><strong>特点</strong>：通常比 BPE 稍微紧凑一些，但计算量稍大。</p>
</li>
</ul>
<h3 id="3-3-Unigram-Language-Model">3.3 Unigram Language Model</h3>
<ul>
<li>
<p><strong>代表模型</strong>：<strong>T5</strong>, ALBERT, XLNet (使用 SentencePiece 库)。</p>
</li>
<li>
<p><strong>原理</strong>：思路与 BPE 相反。BPE 是“从下往上”合并，Unigram 是“从上往下”剪枝。它先初始化一个巨大的词表，然后计算丢弃某些词对整体损失函数的影响，<strong>保留概率最高</strong>的子词，剔除贡献小的，直到达到预设词表大小。</p>
</li>
<li>
<p><strong>特点</strong>：它是基于概率的模型，对于同一个句子可以产生多种分词可能（Subword Regularization），这在训练时有时能增加模型的鲁棒性。</p>
</li>
</ul>
<hr>
<h2 id="4-相关资料">4 相关资料</h2>
<p><a target="_blank" rel="noopener" href="https://www.reedbeta.com/blog/programmers-intro-to-unicode/">Programmer’s intro to unicode</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://hrbeny.github.io">HRbenY</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://hrbeny.github.io/2026/01/27/obsidian/20-Reference/transformer/Tokenizer/">https://hrbeny.github.io/2026/01/27/obsidian/20-Reference/transformer/Tokenizer/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://hrbeny.github.io" target="_blank">Spa-Master 的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/type-note/">type/note</a><a class="post-meta__tags" href="/tags/topic-transformer/">topic/transformer</a></div><div class="post-share"><div class="social-share" data-image="/img/mai.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2026/01/27/obsidian/20-Reference/transformer/%E4%BD%8D%E7%BD%AE%E6%8E%A9%E7%A0%81/" title="位置掩码"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">位置掩码</div></div><div class="info-2"><div class="info-item-1">对于语言模型，我们需要在训练时赋予因果遮蔽，避免模型使用未来的token训练。所以对时间序列维度要进行位置掩码。 串行做法 123456789xbow = torch.zeros((B, T, C))for b in range(B):    for t in range(T):        x_prev = x[b, :t + 1]        xbow[b, t] = torch.mean(x_prev, 0) 这里是一个很简单的token交互，取平均值。可以看到在每个batch维度独立地对时间序列进行遮蔽。对于第t组数据（B, 1, C），我们只让他看到过去的0~t时刻的token内容，即x[b, :t + 1] 。 串行实现逻辑很简单，但是对于GPU不友好。我们可以引入一个数学技巧来处理时间遮蔽。 矩阵做法 12345678910111213torch.manual_seed(1337)B, T, C = 4, 8, 32x = torch.randn(B, T, C)tril = torch.tril(torch.ones(T, T))wei = wei.maske...</div></div></div></a><a class="pagination-related" href="/2026/01/27/obsidian/20-Reference/transformer/Self-Attention%E6%9C%BA%E5%88%B6(Q,K,V)/" title="Self-Attention机制(Q,K,V)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Self-Attention机制(Q,K,V)</div></div><div class="info-2"><div class="info-item-1">                   #mjx-b6ed40e{         display:contents;         mjx-assistive-mml {           user-select: text !important;           clip: auto !important;           color: rgba(0,0,0,0);         }          mjx-container[jax="SVG"] {   direction: ltr; }  mjx-container[jax="SVG"] > svg {   overflow: visible;   min-height: 1px;   min-width: 1px; }  mjx-container[jax="SVG"] > svg a {   fill: blue;   stroke: blue; }  mjx-assistive-mml {   position: absolute !important;   top: 0px;   left: 0px...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2026/01/27/obsidian/20-Reference/transformer/Self-Attention%E6%9C%BA%E5%88%B6(Q,K,V)/" title="Self-Attention机制(Q,K,V)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-27</div><div class="info-item-2">Self-Attention机制(Q,K,V)</div></div><div class="info-2"><div class="info-item-1">                   #mjx-b6ed40e{         display:contents;         mjx-assistive-mml {           user-select: text !important;           clip: auto !important;           color: rgba(0,0,0,0);         }          mjx-container[jax="SVG"] {   direction: ltr; }  mjx-container[jax="SVG"] > svg {   overflow: visible;   min-height: 1px;   min-width: 1px; }  mjx-container[jax="SVG"] > svg a {   fill: blue;   stroke: blue; }  mjx-assistive-mml {   position: absolute !important;   top: 0px;   left: 0px...</div></div></div></a><a class="pagination-related" href="/2026/01/27/obsidian/20-Reference/transformer/LayerNorm/" title="LayerNorm"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-27</div><div class="info-item-2">LayerNorm</div></div><div class="info-2"><div class="info-item-1"> 并不是BatchNorm简单的交换N和D。  前向传播 在前向传播中，LayerNorm的公式就是BatchNorm交换N和D维度。LayerNorm在每个批次内部进行Normalization，而BatchNorm是跨Batch的Norm。导致mean和std_dev稍有不同。 (1) 均值                    #mjx-62ffcf5{         display:contents;         mjx-assistive-mml {           user-select: text !important;           clip: auto !important;           color: rgba(0,0,0,0);         }          mjx-container[jax="SVG"] {   direction: ltr; }  mjx-container[jax="SVG"] > svg {   overflow: visible;   min-height: 1px;   min-width: 1px...</div></div></div></a><a class="pagination-related" href="/2026/01/27/obsidian/20-Reference/transformer/Adamw/" title="Adamw"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-27</div><div class="info-item-2">Adamw</div></div><div class="info-2"><div class="info-item-1">从SGD到Adamw，所有优化器的形式都类似                    #mjx-96c09f6{         display:contents;         mjx-assistive-mml {           user-select: text !important;           clip: auto !important;           color: rgba(0,0,0,0);         }          mjx-container[jax="SVG"] {   direction: ltr; }  mjx-container[jax="SVG"] > svg {   overflow: visible;   min-height: 1px;   min-width: 1px; }  mjx-container[jax="SVG"] > svg a {   fill: blue;   stroke: blue; }  mjx-assistive-mml {   position: absolute !important; ...</div></div></div></a><a class="pagination-related" href="/2026/01/27/obsidian/20-Reference/transformer/L2%20Regularization/" title="L2 Regularization"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-27</div><div class="info-item-2">L2 Regularization</div></div><div class="info-2"><div class="info-item-1">L2正则化的目的是权重衰减，让Loss和权重的L2范数正相关。在SGD和Momentum中不需多余处理就能达到这样的效果。但是Adagrad和Adam由于对梯度做了预处理，不能直接应用公式。（见 [[Adamw]]） 作用 防止模型过拟合 (Overfitting)。通过限制参数（权重                    #mjx-a7ae304{         display:contents;         mjx-assistive-mml {           user-select: text !important;           clip: auto !important;           color: rgba(0,0,0,0);         }          mjx-container[jax="SVG"] {   direction: ltr; }  mjx-container[jax="SVG"] > svg {   overflow: visible;   min-height: 1px;   min-width: 1px; }  ...</div></div></div></a><a class="pagination-related" href="/2026/01/27/obsidian/20-Reference/transformer/%E4%BD%8D%E7%BD%AE%E6%8E%A9%E7%A0%81/" title="位置掩码"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-27</div><div class="info-item-2">位置掩码</div></div><div class="info-2"><div class="info-item-1">对于语言模型，我们需要在训练时赋予因果遮蔽，避免模型使用未来的token训练。所以对时间序列维度要进行位置掩码。 串行做法 123456789xbow = torch.zeros((B, T, C))for b in range(B):    for t in range(T):        x_prev = x[b, :t + 1]        xbow[b, t] = torch.mean(x_prev, 0) 这里是一个很简单的token交互，取平均值。可以看到在每个batch维度独立地对时间序列进行遮蔽。对于第t组数据（B, 1, C），我们只让他看到过去的0~t时刻的token内容，即x[b, :t + 1] 。 串行实现逻辑很简单，但是对于GPU不友好。我们可以引入一个数学技巧来处理时间遮蔽。 矩阵做法 12345678910111213torch.manual_seed(1337)B, T, C = 4, 8, 32x = torch.randn(B, T, C)tril = torch.tril(torch.ones(T, T))wei = wei.maske...</div></div></div></a><a class="pagination-related" href="/2026/01/27/obsidian/00-Inbox/Hexo%E6%B8%B2%E6%9F%93%E6%B5%8B%E8%AF%95/" title="Hexo渲染测试"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-27</div><div class="info-item-2">Hexo渲染测试</div></div><div class="info-2"><div class="info-item-1">简介 文章使用方法 这原本是一篇 Typora 下使用 Markdown 语法的案例实践分享，最早创建于 2021 年 11 月之前，于 2023 年 6 月大改。本篇文章使用 Markdown 标记语法编写而成，汇聚了常用 Markdown 语法标注。对于不同目标人群有不同的作用：  对于 Markdown 学习者。可以获取文章源码（Github 仓库地址在下面），并使用你的本地编辑器打开。通过对比标记语言与渲染结果直接学习。如果你不喜欢这种 MarkDown 学习方式，你可以参考 GitHub 学习相关 Markdown 规范：基本撰写和格式语法 - GitHub 文档 对于其他人。这篇文章包含不同标准 Markdown 语法，你可以在任何 Markdown 编辑器打开以测试其渲染效果。  比如说——你。你使用什么方式看到这篇文章，就了解到你所用的软件对 Markdown 语言的支持情况。如果你通过我的博客打开，那么你看到的就是 Hexo 渲染后的结果（至少目前时是这样）。 比如说——我，笔记重度依赖。我需要对比本地编辑器的渲染器与 Hexo 各类渲染器和插件对 Markdo...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/mai.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">HRbenY</div><div class="author-info-description">个人技术博客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hrbeny"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/hrbeny" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:hrcharck@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E8%AF%8D%E5%99%A8-Tokenizer-%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">1. 什么是分词器 (Tokenizer)？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%88%AA%E5%9B%BE%E5%9C%BA%E6%99%AF%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%B1%80%E9%99%90%E6%80%A7-Limitations"><span class="toc-number">2.</span> <span class="toc-text">2. 截图场景解析与局限性 (Limitations)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%80%EF%BC%9A%E7%AE%97%E6%9C%AF%E4%B8%8E%E6%95%B0%E5%AD%97%E5%A4%84%E7%90%86-Arithmetic"><span class="toc-number">2.1.</span> <span class="toc-text">场景一：算术与数字处理 (Arithmetic)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%BA%8C%EF%BC%9A%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F-Case-Sensitivity"><span class="toc-number">2.2.</span> <span class="toc-text">场景二：大小写敏感 (Case Sensitivity)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%89%EF%BC%9A%E9%9D%9E%E8%8B%B1%E8%AF%AD-%E5%A4%9A%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81-Non-English-Multilingual"><span class="toc-number">2.3.</span> <span class="toc-text">场景三：非英语&#x2F;多语言支持 (Non-English &#x2F; Multilingual)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E5%9B%9B%EF%BC%9A%E4%BB%A3%E7%A0%81%E4%B8%8E%E6%A0%BC%E5%BC%8F-Code-Formatting"><span class="toc-number">2.4.</span> <span class="toc-text">场景四：代码与格式 (Code &amp; Formatting)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90%EF%BC%9AGPT-2-gpt2-vs-GPT-4-cl100k-base"><span class="toc-number">2.5.</span> <span class="toc-text">对比分析：GPT-2 (gpt2) vs GPT-4 (cl100k_base)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%B7%AE%E5%BC%82%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">2.6.</span> <span class="toc-text">核心差异总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%B8%BB%E6%B5%81%E7%9A%84%E5%88%86%E8%AF%8D%E5%99%A8%E7%B1%BB%E5%9E%8B-Tokenizer-Types"><span class="toc-number">3.</span> <span class="toc-text">3. 主流的分词器类型 (Tokenizer Types)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-BPE-Byte-Pair-Encoding"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 BPE (Byte Pair Encoding)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-WordPiece"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 WordPiece</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Unigram-Language-Model"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 Unigram Language Model</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99"><span class="toc-number">4.</span> <span class="toc-text">4 相关资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/27/obsidian/20-Reference/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%AE%B5%E6%A0%91/" title="线段树">线段树</a><time datetime="2026-01-27T07:02:17.622Z" title="发表于 2026-01-27 15:02:17">2026-01-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/27/obsidian/20-Reference/%E7%AE%97%E6%B3%95/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/" title="编辑距离">编辑距离</a><time datetime="2026-01-27T07:02:17.622Z" title="发表于 2026-01-27 15:02:17">2026-01-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/27/obsidian/20-Reference/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/12.graph/%E5%9B%BE/" title="图">图</a><time datetime="2026-01-27T07:02:17.621Z" title="发表于 2026-01-27 15:02:17">2026-01-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/27/obsidian/20-Reference/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/2.ListNode/%E9%93%BE%E8%A1%A8/" title="链表">链表</a><time datetime="2026-01-27T07:02:17.621Z" title="发表于 2026-01-27 15:02:17">2026-01-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/27/obsidian/20-Reference/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/3.Hash%20table/%E5%93%88%E5%B8%8C%E8%A1%A8/" title="哈希表">哈希表</a><time datetime="2026-01-27T07:02:17.621Z" title="发表于 2026-01-27 15:02:17">2026-01-27</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By HRbenY</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4-b1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4-b1"></script><script src="/js/main.js?v=5.5.4-b1"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@4.0.0/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>