<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数组 | Spa-Master 的博客</title><meta name="author" content="HRbenY"><meta name="copyright" content="HRbenY"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数组 数组是存放在连续内存空间上的相同类型数据的集合。 正因为如此，可以方便地通过下标索引的方式（地址）获取到下标对应的数据。 由于内存空间是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。  数组的元素是不能删的，只能覆盖。 C++的话，要注意vector 和 array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。 成员函数 成员函数（">
<meta property="og:type" content="article">
<meta property="og:title" content="数组">
<meta property="og:url" content="https://hrbeny.github.io/2026/01/27/obsidian/20-Reference/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/1.Array/%E6%95%B0%E7%BB%84/index.html">
<meta property="og:site_name" content="Spa-Master 的博客">
<meta property="og:description" content="数组 数组是存放在连续内存空间上的相同类型数据的集合。 正因为如此，可以方便地通过下标索引的方式（地址）获取到下标对应的数据。 由于内存空间是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。  数组的元素是不能删的，只能覆盖。 C++的话，要注意vector 和 array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。 成员函数 成员函数（">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hrbeny.github.io/img/mai.png">
<meta property="article:published_time" content="2026-01-27T02:22:50.339Z">
<meta property="article:modified_time" content="2026-01-27T02:22:50.339Z">
<meta property="article:author" content="HRbenY">
<meta property="article:tag" content="lang&#x2F;cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hrbeny.github.io/img/mai.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "数组",
  "url": "https://hrbeny.github.io/2026/01/27/obsidian/20-Reference/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/1.Array/%E6%95%B0%E7%BB%84/",
  "image": "https://hrbeny.github.io/img/mai.png",
  "datePublished": "2026-01-27T02:22:50.339Z",
  "dateModified": "2026-01-27T02:22:50.339Z",
  "author": [
    {
      "@type": "Person",
      "name": "HRbenY",
      "url": "https://hrbeny.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://hrbeny.github.io/2026/01/27/obsidian/20-Reference/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/1.Array/%E6%95%B0%E7%BB%84/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4-b1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数组',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Spa-Master 的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">数组</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">数组</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-01-27T02:22:50.339Z" title="发表于 2026-01-27 10:22:50">2026-01-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-27T02:22:50.339Z" title="更新于 2026-01-27 10:22:50">2026-01-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>数组</h1>
<p>数组是存放在<strong>连续内存空间</strong>上的<strong>相同类型数据</strong>的集合。<br>
正因为如此，可以方便地通过下标索引的方式（地址）获取到下标对应的数据。</p>
<p>由于内存空间是连续的，所以我们在删除或者增添元素的时候，就难免要<strong>移动其他元素的地址</strong>。
<img src="image.png" alt="删除数组元素"></p>
<p>数组的元素是不能删的，<strong>只能覆盖</strong>。</p>
<p>C++的话，要注意vector 和 array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。</p>
<h2 id="成员函数">成员函数</h2>
<p>成员函数（Member Function）是属于一个类（Class）的函数。可以把它想象成是这个类所拥有的行为或能力。C++ 标准库中的容器，如 <code>vector</code>, <code>string</code>, <code>set</code>, <code>map</code> 等，都有一套非常丰富且通用的成员函数</p>
<h3 id="I-容量与大小-Capacity-Size">I. 容量与大小 (Capacity &amp; Size)</h3>
<p>这些函数用于查询和管理容器的元素数量和内存空间。</p>
<ul>
<li>
<p><strong><code>.empty()</code></strong></p>
<ul>
<li><strong>作用</strong>：检查容器是否为空。</li>
<li><strong>返回值</strong>：如果容器没有元素，返回 <code>true</code>。这是一个高效的 
    <span id="mjx-39c5fc1">
      <style>
      #mjx-39c5fc1{
        display:contents;
        mjx-assistive-mml {
          user-select: text !important;
          clip: auto !important;
          color: rgba(0,0,0,0);
        }
        
mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
  min-height: 1px;
  min-width: 1px;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-assistive-mml {
  position: absolute !important;
  top: 0px;
  left: 0px;
  clip: rect(1px, 1px, 1px, 1px);
  padding: 1px 0px 0px 0px !important;
  border: 0px !important;
  display: block !important;
  width: auto !important;
  overflow: hidden !important;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

mjx-assistive-mml[display="block"] {
  width: 100% !important;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][display="true"][width="full"] {
  display: flex;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line], svg[data-table] > g > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame], svg[data-table] > g > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed, svg[data-table] > g > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted, svg[data-table] > g > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > g > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

mjx-container[jax="SVG"] path[data-c], mjx-container[jax="SVG"] use[data-c] {
  stroke-width: 3;
}

g[data-mml-node="xypic"] path {
  stroke-width: inherit;
}

.MathJax g[data-mml-node="xypic"] path {
  stroke-width: inherit;
}

      }
      </style>
      <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container>
    </span>
   操作。</li>
<li><strong>适用容器</strong>：所有标准容器。</li>
</ul>
</li>
<li>
<p><strong><code>.size()</code></strong></p>
<ul>
<li><strong>作用</strong>：返回容器中元素的数量。</li>
<li><strong>返回值</strong>：一个无符号整数类型（<code>size_t</code>）。</li>
<li><strong>适用容器</strong>：所有标准容器。</li>
</ul>
</li>
<li>
<p><strong><code>.max_size()</code></strong></p>
<ul>
<li><strong>作用</strong>：返回容器能容纳的最大元素数量。</li>
<li><strong>返回值</strong>：<code>size_t</code> 类型。</li>
<li><strong>适用容器</strong>：所有标准容器。</li>
</ul>
</li>
<li>
<p><strong><code>.reserve()</code></strong></p>
<ul>
<li><strong>作用</strong>：请求容器为至少指定数量的元素预留内存，通常用于 <code>vector</code> 和 <code>string</code> 以避免多次重新分配内存。</li>
<li><strong>适用容器</strong>：<code>vector</code>, <code>string</code>。</li>
</ul>
</li>
<li>
<p><strong><code>.shrink_to_fit()</code></strong></p>
<ul>
<li><strong>作用</strong>：释放容器中多余的内存空间，使其容量与当前元素数量相匹配。</li>
<li><strong>适用容器</strong>：<code>vector</code>, <code>string</code>, <code>deque</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="II-迭代器-Iterators">II. 迭代器 (Iterators)</h3>
<p>这些函数返回迭代器，用于遍历容器。</p>
<ul>
<li>
<p><strong><code>.begin()</code> / <code>.end()</code></strong></p>
<ul>
<li><strong>作用</strong>：返回指向容器<strong>首个元素</strong>和<strong>末尾虚位</strong>的迭代器。</li>
<li><strong>用途</strong>：用于正向遍历容器，如 <code>for (auto it = c.begin(); it != c.end(); ++it)</code>.</li>
<li><strong>适用容器</strong>：所有标准容器。</li>
</ul>
</li>
<li>
<p><strong><code>.cbegin()</code> / <code>.cend()</code></strong></p>
<ul>
<li><strong>作用</strong>：返回<strong>常量迭代器</strong>，用法和 <code>begin()</code> / <code>end()</code> 相同，但不能通过它们修改元素。</li>
<li><strong>用途</strong>：只读遍历，能提升代码安全性和可读性。</li>
<li><strong>适用容器</strong>：所有标准容器。</li>
</ul>
</li>
<li>
<p><strong><code>.rbegin()</code> / <code>.rend()</code></strong></p>
<ul>
<li><strong>作用</strong>：返回<strong>反向迭代器</strong>，分别指向容器的最后一个元素和第一个元素的前一个虚位。</li>
<li><strong>用途</strong>：用于从后往前反向遍历。</li>
<li><strong>适用容器</strong>：支持反向迭代器的容器，如 <code>vector</code>, <code>string</code>, <code>list</code>, <code>deque</code>。</li>
</ul>
</li>
<li>
<p><strong><code>.crbegin()</code> / <code>.crend()</code></strong></p>
<ul>
<li><strong>作用</strong>：返回<strong>常量反向迭代器</strong>，用于从后往后只读遍历。</li>
<li><strong>适用容器</strong>：支持反向迭代器的容器。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="III-元素访问-Element-Access">III. 元素访问 (Element Access)</h3>
<p>这些函数用于直接访问容器中的特定元素，通常返回对元素的引用。</p>
<ul>
<li>
<p><strong><code>[ ]</code> 操作符</strong></p>
<ul>
<li><strong>作用</strong>：通过索引（<code>vector</code>）或键（<code>map</code>）来访问元素。</li>
<li><strong>注意</strong>：不进行边界检查。如果索引或键不存在，可能导致未定义行为。</li>
<li><strong>适用容器</strong>：<code>vector</code>, <code>deque</code>, <code>string</code>, <code>map</code>, <code>unordered_map</code>。</li>
</ul>
</li>
<li>
<p><strong><code>.at()</code></strong></p>
<ul>
<li><strong>作用</strong>：通过索引或键来访问元素，<strong>会进行边界检查</strong>。</li>
<li><strong>注意</strong>：如果索引或键不存在，会抛出 <code>std::out_of_range</code> 异常。</li>
<li><strong>适用容器</strong>：<code>vector</code>, <code>deque</code>, <code>string</code>, <code>map</code>, <code>unordered_map</code>。</li>
</ul>
</li>
<li>
<p><strong><code>.front()</code> / <code>.back()</code></strong></p>
<ul>
<li><strong>作用</strong>：分别返回对容器<strong>第一个</strong>和<strong>最后一个</strong>元素的引用。</li>
<li><strong>适用容器</strong>：<code>vector</code>, <code>string</code>, <code>list</code>, <code>deque</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="IV-查找与统计-Lookup-Statistics">IV. 查找与统计 (Lookup &amp; Statistics)</h3>
<p>这些函数用于高效地在容器中查找元素或统计数量。</p>
<ul>
<li>
<p><strong><code>.find()</code></strong></p>
<ul>
<li><strong>作用</strong>：在容器中查找指定元素（或键）。</li>
<li><strong>返回值</strong>：如果找到，返回指向该元素的<strong>迭代器</strong>；如果找不到，返回 <code>container.end()</code>。</li>
<li><strong>适用容器</strong>：<code>set</code>, <code>map</code>, <code>unordered_set</code>, <code>unordered_map</code>。</li>
</ul>
</li>
<li>
<p><strong><code>.count()</code></strong></p>
<ul>
<li><strong>作用</strong>：检查容器中是否存在某个元素（或键），或统计其出现次数。</li>
<li><strong>返回值</strong>：对于 <code>set</code>/<code>map</code>，返回 <code>1</code> 或 <code>0</code>。对于 <code>multiset</code>/<code>multimap</code>，返回元素出现的次数。</li>
<li><strong>适用容器</strong>：<code>set</code>, <code>map</code>, <code>multiset</code>, <code>multimap</code>, <code>unordered_set</code>, <code>unordered_map</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="V-修改器-Modifiers">V. 修改器 (Modifiers)</h3>
<p>这些函数用于添加、删除或修改容器的元素。</p>
<ul>
<li>
<p><strong><code>.insert()</code></strong></p>
<ul>
<li><strong>作用</strong>：插入一个或多个元素。对于 <code>set</code>/<code>map</code>，会自动找到正确位置。</li>
<li><strong>适用容器</strong>：所有标准容器。</li>
<li>insert(iterator, val)或insert(val)</li>
</ul>
</li>
<li>
<p><strong><code>.erase()</code></strong></p>
<ul>
<li><strong>作用</strong>：删除一个或多个元素。可以接受一个值、一个迭代器或一个迭代器范围。</li>
<li><strong>适用容器</strong>：所有标准容器。</li>
</ul>
</li>
<li>
<p><strong><code>.clear()</code></strong></p>
<ul>
<li><strong>作用</strong>：删除容器中的<strong>所有</strong>元素，使其变为空。</li>
<li><strong>适用容器</strong>：所有标准容器。</li>
</ul>
</li>
<li>
<p><strong><code>.push_back()</code> / <code>.pop_back()</code></strong></p>
<ul>
<li><strong>作用</strong>：在容器<strong>末尾</strong>添加或删除一个元素。</li>
<li><strong>适用容器</strong>：<code>vector</code>, <code>string</code>, <code>list</code>, <code>deque</code>。</li>
</ul>
</li>
<li>
<p><strong><code>.emplace()</code> / <code>.emplace_back()</code></strong></p>
<ul>
<li><strong>作用</strong>：在容器中直接构造新元素，而不是先构造再拷贝或移动。通常比 <code>insert()</code> 或 <code>push_back()</code> 更高效。</li>
<li><strong>适用容器</strong>：所有标准容器（<code>emplace</code>），<code>vector</code> 等支持 <code>push_back</code> 的容器（<code>emplace_back</code>）。</li>
</ul>
</li>
<li>
<p><strong><code>.swap()</code></strong></p>
<ul>
<li><strong>作用</strong>：与另一个同类型容器交换所有元素，这是一个非常高效的操作，通常为常数时间 
    <span id="mjx-fa7f00f">
      <style>
      #mjx-fa7f00f{
        display:contents;
        mjx-assistive-mml {
          user-select: text !important;
          clip: auto !important;
          color: rgba(0,0,0,0);
        }
        
mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
  min-height: 1px;
  min-width: 1px;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-assistive-mml {
  position: absolute !important;
  top: 0px;
  left: 0px;
  clip: rect(1px, 1px, 1px, 1px);
  padding: 1px 0px 0px 0px !important;
  border: 0px !important;
  display: block !important;
  width: auto !important;
  overflow: hidden !important;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

mjx-assistive-mml[display="block"] {
  width: 100% !important;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][display="true"][width="full"] {
  display: flex;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line], svg[data-table] > g > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame], svg[data-table] > g > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed, svg[data-table] > g > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted, svg[data-table] > g > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > g > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

mjx-container[jax="SVG"] path[data-c], mjx-container[jax="SVG"] use[data-c] {
  stroke-width: 3;
}

g[data-mml-node="xypic"] path {
  stroke-width: inherit;
}

.MathJax g[data-mml-node="xypic"] path {
  stroke-width: inherit;
}

      }
      </style>
      <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container>
    </span>
  。</li>
<li><strong>适用容器</strong>：所有标准容器。</li>
</ul>
</li>
</ul>
<h2 id="题目">题目</h2>
<h3 id="704-二分查找">704. 二分查找</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">原题链接</a></p>
<p>二分法注意区间开闭，这类问题一定要考虑好边界问题。</p>
<h3 id="27-移除元素">27. 移除元素</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/description/">原题链接</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> fastIndex = <span class="number">0</span>; fastIndex &lt; nums.<span class="built_in">size</span>(); fastIndex++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val != nums[fastIndex]) &#123;</span><br><span class="line">        nums[slowIndex++] = nums[fastIndex];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>快慢指针，这里注意用快指针做循环。</p>
<h3 id="977-有序数组的平方">977. 有序数组的平方</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">原题链接</a></p>
<p>双指针</p>
<h3 id="209-长度最小的子数组">209. 长度最小的子数组</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">原题链接</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">           sum += nums[j];</span><br><span class="line">           <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">               subLength = (j - i + <span class="number">1</span>);</span><br><span class="line">               result = result &lt; subLength ? result : subLength;</span><br><span class="line">               sum -= nums[i++];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>滑动窗口，这里用右端点做for循环，<strong>while循环判断窗口数值之和是否大于给定值</strong>。一旦大于就开始移动左端点。</p>
<h3 id="59-螺旋矩阵">59. 螺旋矩阵</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/submissions/661551259/">原题链接</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrix</span>(n, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>注意这里定义二维数组的方式，用<strong>两个vector嵌套</strong>。</p>
<p><code>std::vector&lt;int&gt;</code>声明这个vector的所有元素都是int类型。
<code>std::vector&lt;std::vector&lt;int&gt;&gt;</code>声明外侧vector的所有元素都是<code>std::vector&lt;int&gt;</code>类型。</p>
<p><code>std::vector&lt;int&gt;(n, 0)</code>是vector的构造函数，创建一个长度为n的向量，并初始化为零。
<code>std::vector&lt;std::vector&lt;int&gt;&gt; matrix(n, std::vector&lt;int&gt;(n, 0))</code>外侧vector创建了一个长度为n的向量，并将所有元素初始化为<code>std::vector&lt;int&gt;(n, 0)</code></p>
<p>如果要创建一个<strong>m行n列</strong>的二维数组，应写成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrix</span>(m, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>因为本质是用<strong>m个有n个元素的行向量</strong>拼成的。</p>
<h3 id="卡码58-区间和">卡码58. 区间和</h3>
<p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1070">原题链接</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cin &gt;&gt; a &gt;&gt; b)&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>)&#123;</span><br><span class="line">        result = psum[b];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        result = psum[b] - psum[a<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前缀和。避免每次计算新区间都重新循环累加。先计算下标0~n的元素和，再根据输入的a和b用前b项减去前a-1项:<code>psum[b] - psum[a-1]</code></p>
<p>使用<code>while(cin &gt;&gt; a &gt;&gt; b)</code>监听输入。</p>
<p>注意当a=1时要单独考虑</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://hrbeny.github.io">HRbenY</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://hrbeny.github.io/2026/01/27/obsidian/20-Reference/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/1.Array/%E6%95%B0%E7%BB%84/">https://hrbeny.github.io/2026/01/27/obsidian/20-Reference/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/1.Array/%E6%95%B0%E7%BB%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://hrbeny.github.io" target="_blank">Spa-Master 的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/lang-cpp/">lang/cpp</a></div><div class="post-share"><div class="social-share" data-image="/img/mai.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2026/01/27/obsidian/20-Reference/transformer/%E4%BD%8D%E7%BD%AE%E6%8E%A9%E7%A0%81/" title="位置掩码"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">位置掩码</div></div><div class="info-2"><div class="info-item-1">对于语言模型，我们需要在训练时赋予因果遮蔽，避免模型使用未来的token训练。所以对时间序列维度要进行位置掩码。 串行做法 123456789xbow = torch.zeros((B, T, C))for b in range(B):    for t in range(T):        x_prev = x[b, :t + 1]        xbow[b, t] = torch.mean(x_prev, 0) 这里是一个很简单的token交互，取平均值。可以看到在每个batch维度独立地对时间序列进行遮蔽。对于第t组数据（B, 1, C），我们只让他看到过去的0~t时刻的token内容，即x[b, :t + 1] 。 串行实现逻辑很简单，但是对于GPU不友好。我们可以引入一个数学技巧来处理时间遮蔽。 矩阵做法 12345678910111213torch.manual_seed(1337)B, T, C = 4, 8, 32x = torch.randn(B, T, C)tril = torch.tril(torch.ones(T, T))wei = wei.maske...</div></div></div></a><a class="pagination-related" href="/2026/01/27/obsidian/20-Reference/GPU/leetGPU/Matrix%20Transpose/" title="Matrix Transpose"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Matrix Transpose</div></div><div class="info-2"><div class="info-item-1">假设要实现                   #mjx-9f01f23{         display:contents;         mjx-assistive-mml {           user-select: text !important;           clip: auto !important;           color: rgba(0,0,0,0);         }          mjx-container[jax="SVG"] {   direction: ltr; }  mjx-container[jax="SVG"] > svg {   overflow: visible;   min-height: 1px;   min-width: 1px; }  mjx-container[jax="SVG"] > svg a {   fill: blue;   stroke: blue; }  mjx-assistive-mml {   position: absolute !important;   top: 0px;   left...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2026/01/27/obsidian/20-Reference/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" title="多线程编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-27</div><div class="info-item-2">多线程编程</div></div><div class="info-2"><div class="info-item-1">创建一个线程 使用C++11引入的thread头文件创建线程。 1234567void thread_fun(int repeat, int threadId)&#123;    while(repeat --)&#123;        cout &lt;&lt; &quot;thread-&quot; &lt;&lt; threadId &lt;&lt; endl;    &#125;&#125;//注意要先声明线程执行的函数thread myThread0(thread_fun, 5, 0); 传参方式如代码中所示，myThread0(thread_fun, 5, 0)而不是myThread0(thread_fun(5, 0)) 互斥锁 假如我们声明了两个线程，如下 12345thread myThread0(thread_fun, 5, 0);thread myThread1(thread_fun, 5, 1);cout &lt;&lt; &quot;我是主线程，我也在跑！&quot; &lt;&lt; endl;myThread0.join();myThread1.jo...</div></div></div></a><a class="pagination-related" href="/2026/01/27/obsidian/20-Reference/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/2.ListNode/%E9%93%BE%E8%A1%A8/" title="链表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-27</div><div class="info-item-2">链表</div></div><div class="info-2"><div class="info-item-1">链表 链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。 链表的入口节点称为链表的头结点也就是head。  在此基础上，每个节点新增一个指针域，一个指向下一个节点，一个指向上一个节点，就形成了双链表。  将单链表首尾相连，就是循环链表  链表的操作 定义 123456// 单链表struct ListNode &#123;    int val;  // 节点上存储的元素    ListNode* next;  // 指向下一个节点的指针    ListNode(int x) : val(x), next(NULL) &#123;&#125;  // 节点的构造函数&#125;; ListNode(int x)函数的名字与结构名完全相同，这告诉编译器他是一个构造函数。(int x)是传参列表 val(x) next(NULL)是初始化列表，C++独特的初始化成员变量的方式。这种赋值方式发生在函数体{}(这里为空)执行之前。 注意结构定义后要加分号。 值得注意的是，...</div></div></div></a><a class="pagination-related" href="/2026/01/27/obsidian/20-Reference/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/6.StackandQueue/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" title="栈和队列"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-27</div><div class="info-item-2">栈和队列</div></div><div class="info-2"><div class="info-item-1">栈和队列  STL概念 STL (Standard Template Library, 标准模板库) 是 C++ 标准库的核心部分，它提供了一套功能强大的通用数据结构和算法。STL 基于泛型编程 (Generic Programming) 的思想，通过模板实现了代码的高度可重用性。 STL 四大核心组件   容器 (Containers)  作用：用于存储和管理数据的类模板，即各种数据结构。 分类：  序列容器 (vector, deque, list)：按线性顺序存储元素。 关联容器 (set, map)：根据键值自动排序元素，查找速度快。 无序关联容器 (unordered_set, unordered_map)：基于哈希表，提供更快的平均查找速度。 容器适配器 (stack, queue, priority_queue)：在现有容器基础上提供特定接口。      算法 (Algorithms)  作用：一系列用于处理容器中元素的函数模板，如排序、搜索、复制等。 特点：算法独立于任何特定容器，通过迭代器与数据进行交互。例如 sort(), find(), copy()。   ...</div></div></div></a><a class="pagination-related" href="/2026/01/27/obsidian/20-Reference/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/10.dp/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-27</div><div class="info-item-2">动态规划</div></div><div class="info-2"><div class="info-item-1">343.整数拆分 原题链接 这里dp[i]代表把i拆分之后乘积的最大值。那么递推过程可以是dp[i]从dp[i], j * (i - j), j * dp[i - j]中选一个最大的。其中j从1到i/2遍历。代码如下 1234567891011121314class Solution &#123;public:    int integerBreak(int n) &#123;        vector&lt;int&gt; dp(n + 1, 1);        dp[2] = 1;        for(int i = 3; i &lt;= n; i ++)&#123;            for(int j = 1; j &lt;= i / 2; j ++)&#123;                dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));            &#125;        &#125;        return dp[n];    &#125;&#125;; 为什么dp[i]要从dp[...</div></div></div></a><a class="pagination-related" href="/2026/01/27/obsidian/20-Reference/%E7%AE%97%E6%B3%95/Floyd%E5%88%A4%E5%9C%88%E6%B3%95(%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0)/" title="Floyd判圈法(寻找重复数)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-27</div><div class="info-item-2">Floyd判圈法(寻找重复数)</div></div><div class="info-2"><div class="info-item-1">类似lc142环形链表。 1. 核心思维转换 将数组抽象为链表（图）：   节点：数组下标 i。   指针：数组的值 nums[i]。   规则：i 指向 nums[i]。   结论：因为有重复数，意味着有两个不同的下标指向同一个值，这在图中形成了一个环。且这个被多次指向的值，就是环的入口。   2. 算法流程 (双指针法) 该算法分为两个明确的阶段： Phase 1：快慢指针找相遇点   操作：slow 走 1 步，fast 走 2 步。   目的：确认环的存在，并让双指针在环内相遇。   终止条件：slow == fast。   Phase 2：同步指针找入口 (Answer)   操作：   slow 重置回起点 0。   fast 保持在刚才的相遇点不变。   两个指针每次都走 1 步。     目的：找到环的入口节点。   终止条件：slow == fast (再次相遇的位置即为重复数)。   3. 为什么 Phase 2 能找到入口？(数学原理) 假设：   起点到环入口距离为                    #mjx-e3a1893{         disp...</div></div></div></a><a class="pagination-related" href="/2026/01/27/obsidian/20-Reference/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/3.Hash%20table/%E5%93%88%E5%B8%8C%E8%A1%A8/" title="哈希表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-27</div><div class="info-item-2">哈希表</div></div><div class="info-2"><div class="info-item-1">哈希表 什么时候使用哈希法？ 当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。 概述和初始化   std::unordered_map (哈希映射): 存储唯一的键值对（key-value pairs）。键用于快速查找和访问，值可以重复。适合需要通过键来获取关联值的场景。  初始化：std::unordered_map&lt;KeyType, ValueType&gt; myMap = &#123;&#123;key1, val1&#125;, &#123;key2, val2&#125;&#125;; 示例：std::unordered_map&lt;std::string, int&gt; ages = &#123;&#123;&quot;Alice&quot;, 25&#125;, &#123;&quot;Bob&quot;, 30&#125;&#125;;    std::unordered_set (哈希集合): 存储唯一的元素（unique keys）。它只关心元素本身，不存储额外的值。适合需要快速判断一个元素是否存在的场景。...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/mai.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">HRbenY</div><div class="author-info-description">个人技术博客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hrbeny"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/hrbeny" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:hrcharck@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-%E5%AE%B9%E9%87%8F%E4%B8%8E%E5%A4%A7%E5%B0%8F-Capacity-Size"><span class="toc-number">1.1.1.</span> <span class="toc-text">I. 容量与大小 (Capacity &amp; Size)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#II-%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterators"><span class="toc-number">1.1.2.</span> <span class="toc-text">II. 迭代器 (Iterators)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#III-%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE-Element-Access"><span class="toc-number">1.1.3.</span> <span class="toc-text">III. 元素访问 (Element Access)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IV-%E6%9F%A5%E6%89%BE%E4%B8%8E%E7%BB%9F%E8%AE%A1-Lookup-Statistics"><span class="toc-number">1.1.4.</span> <span class="toc-text">IV. 查找与统计 (Lookup &amp; Statistics)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#V-%E4%BF%AE%E6%94%B9%E5%99%A8-Modifiers"><span class="toc-number">1.1.5.</span> <span class="toc-text">V. 修改器 (Modifiers)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-number">1.2.</span> <span class="toc-text">题目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.2.1.</span> <span class="toc-text">704. 二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.2.</span> <span class="toc-text">27. 移除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="toc-number">1.2.3.</span> <span class="toc-text">977. 有序数组的平方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.4.</span> <span class="toc-text">209. 长度最小的子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="toc-number">1.2.5.</span> <span class="toc-text">59. 螺旋矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%A1%E7%A0%8158-%E5%8C%BA%E9%97%B4%E5%92%8C"><span class="toc-number">1.2.6.</span> <span class="toc-text">卡码58. 区间和</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/27/obsidian/20-Reference/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%AE%B5%E6%A0%91/" title="线段树">线段树</a><time datetime="2026-01-27T02:22:50.341Z" title="发表于 2026-01-27 10:22:50">2026-01-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/27/obsidian/20-Reference/%E7%AE%97%E6%B3%95/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/" title="编辑距离">编辑距离</a><time datetime="2026-01-27T02:22:50.341Z" title="发表于 2026-01-27 10:22:50">2026-01-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/27/obsidian/20-Reference/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/9.greedy%20algorithm/%E8%B4%AA%E5%BF%83/" title="贪心">贪心</a><time datetime="2026-01-27T02:22:50.341Z" title="发表于 2026-01-27 10:22:50">2026-01-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/27/obsidian/20-Reference/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/10.dp/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划">动态规划</a><time datetime="2026-01-27T02:22:50.340Z" title="发表于 2026-01-27 10:22:50">2026-01-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/27/obsidian/20-Reference/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/2.ListNode/%E9%93%BE%E8%A1%A8/" title="链表">链表</a><time datetime="2026-01-27T02:22:50.340Z" title="发表于 2026-01-27 10:22:50">2026-01-27</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By HRbenY</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4-b1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4-b1"></script><script src="/js/main.js?v=5.5.4-b1"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@4.0.0/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>