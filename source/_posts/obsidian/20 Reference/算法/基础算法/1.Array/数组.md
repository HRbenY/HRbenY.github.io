---
Author: Spa-Master
日期: 2026年1月17日
tags:
- lang/cpp
title: 数组
slug: 数组
---

# 数组

数组是存放在**连续内存空间**上的**相同类型数据**的集合。  
正因为如此，可以方便地通过下标索引的方式（地址）获取到下标对应的数据。  

由于内存空间是连续的，所以我们在删除或者增添元素的时候，就难免要**移动其他元素的地址**。
![删除数组元素](20%20Reference/算法/基础算法/1.Array/image.png)

数组的元素是不能删的，**只能覆盖**。

C++的话，要注意vector 和 array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。

## 成员函数

成员函数（Member Function）是属于一个类（Class）的函数。可以把它想象成是这个类所拥有的行为或能力。C++ 标准库中的容器，如 ``vector``, ``string``, ``set``, ``map`` 等，都有一套非常丰富且通用的成员函数

### I. 容量与大小 (Capacity & Size)

这些函数用于查询和管理容器的元素数量和内存空间。

* **`.empty()`**
    * **作用**：检查容器是否为空。
    * **返回值**：如果容器没有元素，返回 `true`。这是一个高效的 $O(1)$ 操作。
    * **适用容器**：所有标准容器。

* **`.size()`**
    * **作用**：返回容器中元素的数量。
    * **返回值**：一个无符号整数类型（`size_t`）。
    * **适用容器**：所有标准容器。

* **`.max_size()`**
    * **作用**：返回容器能容纳的最大元素数量。
    * **返回值**：`size_t` 类型。
    * **适用容器**：所有标准容器。

* **`.reserve()`**
    * **作用**：请求容器为至少指定数量的元素预留内存，通常用于 `vector` 和 `string` 以避免多次重新分配内存。
    * **适用容器**：`vector`, `string`。

* **`.shrink_to_fit()`**
    * **作用**：释放容器中多余的内存空间，使其容量与当前元素数量相匹配。
    * **适用容器**：`vector`, `string`, `deque`。

---

### II. 迭代器 (Iterators)

这些函数返回迭代器，用于遍历容器。

* **`.begin()` / `.end()`**
    * **作用**：返回指向容器**首个元素**和**末尾虚位**的迭代器。
    * **用途**：用于正向遍历容器，如 `for (auto it = c.begin(); it != c.end(); ++it)`.
    * **适用容器**：所有标准容器。

* **`.cbegin()` / `.cend()`**
    * **作用**：返回**常量迭代器**，用法和 `begin()` / `end()` 相同，但不能通过它们修改元素。
    * **用途**：只读遍历，能提升代码安全性和可读性。
    * **适用容器**：所有标准容器。

* **`.rbegin()` / `.rend()`**
    * **作用**：返回**反向迭代器**，分别指向容器的最后一个元素和第一个元素的前一个虚位。
    * **用途**：用于从后往前反向遍历。
    * **适用容器**：支持反向迭代器的容器，如 `vector`, `string`, `list`, `deque`。

* **`.crbegin()` / `.crend()`**
    * **作用**：返回**常量反向迭代器**，用于从后往后只读遍历。
    * **适用容器**：支持反向迭代器的容器。

---

### III. 元素访问 (Element Access)

这些函数用于直接访问容器中的特定元素，通常返回对元素的引用。

* **`[ ]` 操作符**
    * **作用**：通过索引（`vector`）或键（`map`）来访问元素。
    * **注意**：不进行边界检查。如果索引或键不存在，可能导致未定义行为。
    * **适用容器**：`vector`, `deque`, `string`, `map`, `unordered_map`。

* **`.at()`**
    * **作用**：通过索引或键来访问元素，**会进行边界检查**。
    * **注意**：如果索引或键不存在，会抛出 `std::out_of_range` 异常。
    * **适用容器**：`vector`, `deque`, `string`, `map`, `unordered_map`。

* **`.front()` / `.back()`**
    * **作用**：分别返回对容器**第一个**和**最后一个**元素的引用。
    * **适用容器**：`vector`, `string`, `list`, `deque`。

---

### IV. 查找与统计 (Lookup & Statistics)

这些函数用于高效地在容器中查找元素或统计数量。

* **`.find()`**
    * **作用**：在容器中查找指定元素（或键）。
    * **返回值**：如果找到，返回指向该元素的**迭代器**；如果找不到，返回 `container.end()`。
    * **适用容器**：`set`, `map`, `unordered_set`, `unordered_map`。

* **`.count()`**
    * **作用**：检查容器中是否存在某个元素（或键），或统计其出现次数。
    * **返回值**：对于 `set`/`map`，返回 `1` 或 `0`。对于 `multiset`/`multimap`，返回元素出现的次数。
    * **适用容器**：`set`, `map`, `multiset`, `multimap`, `unordered_set`, `unordered_map`。

---

### V. 修改器 (Modifiers)

这些函数用于添加、删除或修改容器的元素。

* **`.insert()`**
    * **作用**：插入一个或多个元素。对于 `set`/`map`，会自动找到正确位置。
    * **适用容器**：所有标准容器。
    * insert(iterator, val)或insert(val)

* **`.erase()`**
    * **作用**：删除一个或多个元素。可以接受一个值、一个迭代器或一个迭代器范围。
    * **适用容器**：所有标准容器。

* **`.clear()`**
    * **作用**：删除容器中的**所有**元素，使其变为空。
    * **适用容器**：所有标准容器。

* **`.push_back()` / `.pop_back()`**
    * **作用**：在容器**末尾**添加或删除一个元素。
    * **适用容器**：`vector`, `string`, `list`, `deque`。

* **`.emplace()` / `.emplace_back()`**
    * **作用**：在容器中直接构造新元素，而不是先构造再拷贝或移动。通常比 `insert()` 或 `push_back()` 更高效。
    * **适用容器**：所有标准容器（`emplace`），`vector` 等支持 `push_back` 的容器（`emplace_back`）。

* **`.swap()`**
    * **作用**：与另一个同类型容器交换所有元素，这是一个非常高效的操作，通常为常数时间 $O(1)$。
    * **适用容器**：所有标准容器。


## 题目

### 704. 二分查找
[原题链接](https://leetcode.cn/problems/binary-search/)

二分法注意区间开闭，这类问题一定要考虑好边界问题。

### 27. 移除元素
[原题链接](https://leetcode.cn/problems/remove-element/description/)

```c++
for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
    if (val != nums[fastIndex]) {
        nums[slowIndex++] = nums[fastIndex];
        }
    }
```

快慢指针，这里注意用快指针做循环。

### 977. 有序数组的平方
[原题链接](https://leetcode.cn/problems/squares-of-a-sorted-array/)

双指针

### 209. 长度最小的子数组
[原题链接](https://leetcode.cn/problems/minimum-size-subarray-sum/)

```c++
 for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            while (sum >= s) {
                subLength = (j - i + 1);
                result = result < subLength ? result : subLength;
                sum -= nums[i++];
            }
        }
```

滑动窗口，这里用右端点做for循环，**while循环判断窗口数值之和是否大于给定值**。一旦大于就开始移动左端点。

### 59. 螺旋矩阵
[原题链接](https://leetcode.cn/problems/spiral-matrix-ii/submissions/661551259/)
```cpp
std::vector<std::vector<int>> matrix(n, std::vector<int>(n, 0));
```
注意这里定义二维数组的方式，用**两个vector嵌套**。

``std::vector<int>``声明这个vector的所有元素都是int类型。
``std::vector<std::vector<int>>``声明外侧vector的所有元素都是``std::vector<int>``类型。


``std::vector<int>(n, 0)``是vector的构造函数，创建一个长度为n的向量，并初始化为零。
``std::vector<std::vector<int>> matrix(n, std::vector<int>(n, 0))``外侧vector创建了一个长度为n的向量，并将所有元素初始化为``std::vector<int>(n, 0)``

如果要创建一个**m行n列**的二维数组，应写成：

```c++
std::vector<std::vector<int>> matrix(m, std::vector<int>(n, 0));
```
因为本质是用**m个有n个元素的行向量**拼成的。

### 卡码58. 区间和
[原题链接](https://kamacoder.com/problempage.php?pid=1070)

```c++
while(cin >> a >> b){
    int result = 0;

    if (a == 0){
        result = psum[b];
    }
    else{
        result = psum[b] - psum[a-1];
    }

    cout << result << endl;
}
```

前缀和。避免每次计算新区间都重新循环累加。先计算下标0~n的元素和，再根据输入的a和b用前b项减去前a-1项:``psum[b] - psum[a-1]``  

使用``while(cin >> a >> b)``监听输入。

注意当a=1时要单独考虑
