---
Author: Spa-Master
日期: 2026年1月17日
tags:
- lang/cpp
title: 动态规划
slug: 动态规划
---

### 343.整数拆分

[原题链接](https://leetcode.cn/problems/integer-break/)

这里dp[i]代表把i拆分之后乘积的最大值。那么递推过程可以是dp[i]从dp[i], j * (i - j), j * dp[i - j]中选一个最大的。其中j从1到i/2遍历。代码如下

```c++
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n + 1, 1);
        dp[2] = 1;

        for(int i = 3; i <= n; i ++){
            for(int j = 1; j <= i / 2; j ++){
                dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));
            }
        }
        return dp[n];
    }
};
```
为什么dp[i]要从dp[i], j * (i - j), j * dp[i - j]中选一个最大的？因为当前的dp[i]在j的循环中会被多次赋值，每个循环中都会计算出一个不同的分割方式下的dp[i]，所以要取这些dp[i]的最大值。  
另外，这里是三个值求取max。用两个max嵌套。

### 96.不同的二叉搜索树

[原题链接](https://leetcode.cn/problems/unique-binary-search-trees/)

这题的dp[i]的含义是，以i为根的二叉搜索树的数量。i的左子树有i - 1个值，右子树有n - i个值，且左右子树内数值都是连续的，使得存在如下关系。比如当右子树为4、5这两个值（对应5个数选取3做根），形成的二叉搜索树的数量跟用1、2为值是一样的。各自组成二叉搜索树，就形成了递推关系。代码如下

```c++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2; i <= n; i ++){
            int tmp_sum = 0;
            for(int j = 1; j <= i; j ++){
                tmp_sum += dp[j - 1] * dp[i - j];
            }
            dp[i] = tmp_sum;
        }
        return dp[n];
    }
};
```

### 01背包

[携带材料](https://kamacoder.com/problempage.php?pid=1046)

这里要使用二维数组，一维遍历容量，一维遍历物品id。

首先初始化第一排，只选择物品0时当背包空间逐渐增大，算出价值。  
由于每个物品只有选和不选两种状态，所以第二排可以利用第一排推导的结果：当空间不够放下物品1时，跟上一排的对应位置是一样的。即`dp[i][j] = dp[i - 1][j]`当足够放下物品1，则当前的最大价值则是物品1的价值`doc[1][1]`和剩余空间放物品0的价值 `dp[0][j - doc[1][0]]`和只放物品0 `dp[0][j]`的较大值。这样就形成了递推，可以一步步算出最终的结果。

比如下面这个图，要计算4格容量下可以放物品0和1（重量分别为1、3，价值分别为15、20）时的最大价值，就是比较四格容量下只放物品0的价值（15）和预留一个物品1的空间，剩下的空间退化到上一行（一格容量放物品0）的价值。

![01背包](https://cdn.jsdelivr.net/gh/HRbenY/blog-assets@master//img/20260117145644484.png)

代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, bagweight;// bagweight代表行李箱空间

    cin >> n >> bagweight;

    vector<int> weight(n, 0); // 存储每件物品所占空间
    vector<int> value(n, 0);  // 存储每件物品价值

    for(int i = 0; i < n; ++i) {
        cin >> weight[i];
    }
    for(int j = 0; j < n; ++j) {
        cin >> value[j];
    }
    // dp数组, dp[i][j]代表行李箱空间为j的情况下,从下标为[0, i]的物品里面任意取,能达到的最大价值
    vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));

    // 初始化, 因为需要用到dp[i - 1]的值
    // j < weight[0]已在上方被初始化为0
    // j >= weight[0]的值就初始化为value[0]
    for (int j = weight[0]; j <= bagweight; j++) {
        dp[0][j] = value[0];
    }

    for(int i = 1; i < weight.size(); i++) { // 遍历科研物品
        for(int j = 0; j <= bagweight; j++) { // 遍历行李箱容量
            if (j < weight[i]) dp[i][j] = dp[i - 1][j]; // 如果装不下这个物品,那么就继承dp[i - 1][j]的值
            else {
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
            }
        }
    }
    cout << dp[n - 1][bagweight] << endl;

    return 0;
}
```

注意遍历容量时是从0遍历到bagweight，是可以取到右端点的。

另外，可以只使用一维dp数组滚动存储。代码如下：

```c++
# include <vector>
# include <iostream>

using namespace std;

int main(){
  int m, n;
  cin >> m;
  cin >> n;
  vector<int> weight(m, 0);
  vector<int> value (m, 0);

  for(int i = 0; i < m; i ++){
    cin >> weight[i];
  }
  for(int i = 0; i < m; i ++){
    cin >> value[i];
  }

  vector<int> dp(n + 1, 0);

  for (int i = 0; i < m; i ++){
    for (int j = n; j >= 0; j --){
      if(j >= weight[i])
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
  }

  cout << dp[n];
  return 0;

}
```

需要注意的是，这里**对dp数组进行遍历时要从右到左。**即代码中的`for (int j = n; j >= 0; j --)`原因是当前dp[j]的值只与左边的有关。如果从左边遍历会出现更新dp[j]时用到已经更新过的某个值，而导致某件物品被重复计算。从右边开始更新则没有这个问题。

### 416.分割等和子集

[原题链接](https://leetcode.cn/problems/partition-equal-subset-sum/submissions/672958262/)

01背包问题。集合中每个元素只能取一次。这里由于元素是数字，其重量和价值都是自己本身。返回true的条件是大小为sum / 2的背包能刚好被装满。代码如下

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for(int i = 0; i < nums.size(); i ++){
            sum += nums[i];
        }
        if(sum % 2)return false;
        vector<int> dp(sum / 2 + 1, 0);
        for(int i = 0; i < nums.size(); i ++){
            for (int j = sum / 2; j >= nums[i]; j --){//注意j的取值下限
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }

        if(dp[sum / 2] == sum / 2)return true;
        return false;
    }
};
```
注释部分因为`j<nums[i]`意味着放不下新的元素`nums[i]`,所以也不会更新`dp[j]`。

### 1049 最后一块石头的重量

[原题链接](https://leetcode.cn/problems/last-stone-weight-ii/description/)

思路还是选取两堆石头，使其和都接近所有石头总重的一半。返回两堆的差。本质上跟上一题区别不大。代码如下

```c++
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum = 0;
        for (int i = 0; i < stones.size(); i++){
            sum += stones[i];
        }
        vector<int> dp(sum / 2 + 1, 0);
        for(int i = 0; i < stones.size(); i ++){
            for (int j = sum / 2; j >= stones[i]; j --){
                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }

        return abs(sum - 2 * dp.back());
    }
};
```

### 494.目标和

[原题链接](https://leetcode.cn/problems/target-sum/)

看似跟前两题差不多，实际这里的dp数组的含义有比较大的不同。首先确定dp表格横向肯定是所有数字，纵向是数字的和。纵向遍历的最大值是`sum + target / 2`。

`dp[i][j]`的值代表可以选择数字i，和为j时的方法数量。在这个场景下`dp[i][j]`，即可以选择数字i，和为j的方法数等于可以选择数字i - 1，和为j的方法数加上可以选择数字i - 1，和为j - 数字i的方法数,即`dp[i - 1][j] + dp[i - 1][j - nums[i]]`。
代码如下：

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for(int i = 0; i < nums.size(); i ++){
            sum += nums[i];
        }
        if (abs(target) > sum)return 0;
        if((sum + target) % 2)return 0;
        int tar = (sum + target) / 2;//因为这里必须是一个整数，所以上一步中(sum + target) % 2就必须是0.
        vector<vector<int>>dp(nums.size(), vector<int>(tar + 1, 0));
        if(nums[0] <= tar + 1)dp[0][nums[0]] = 1;//注意这里的判断条件
        int numZero = 0;
        for(int i = 0; i < nums.size(); i++){//注意排除数字为0的情况。这种情况下结果为0的组合数量不止1
            if(nums[i] == 0)numZero ++;
            dp[i][0] = (int) pow(2.0, numZero);
        }
        for(int i = 1; i < nums.size(); i ++){
            for(int j = 1; j <= tar; j ++){
                dp[i][j] = dp[i - 1][j];
                if(j >= nums[i]) dp[i][j] += dp[i - 1][j - nums[i]];
            }
        }
        return dp[nums.size() - 1][tar];

    }
};
```
要注意代码中的注释部分。

第2个注释 `if(nums[0] <= tar + 1)`是为了防止第一个数字太大，超过了`sum + target / 2`的最大限制。比如一个数组中有元素1000 -1000， target为0时，不加判断第一个元素就越界了。

第3个注释是为了排除数组中存在零元素的情况。当有零时，和为0的组合数就不只是1了，而是这些0的全组合。比如，有俩个0时就是01, 02, 01 + 02, null。有一个就是0, null.没有就是null。即2^n。

### 474. 一和零

[原题链接](https://leetcode.cn/problems/ones-and-zeroes/description/)

注意题目要求的是**不大于**m个0和n个1的最大子集长度。将二进制字符串作为待选物品，0和1的个数作为质量的两个维度。实际上是一个经典的01背包。在不大于给定质量的条件下求最大价值，这里的价值就是子集长度。dp[i][j]的含义是不大于i个0和j个1的条件下的最大子集长度。实际上这里的dp数组维度经过了压缩，遍历字符串的维度直接在上一层的基础上更新，所以要将i和j都反向遍历。代码如下：

```c++
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        vector<vector<int>> binNum(strs.size(), vector<int>(2, 0));
        for(int i = 0; i < strs.size(); i ++){
            for(auto j : strs[i]){
                if(j == '0')binNum[i][0]++;
            }
            binNum[i][1] = strs[i].size() - binNum[i][0];
        }
        for(int index = 0; index < binNum.size(); index ++){
            if(binNum[index][0] > m || binNum[index][1] > n)continue;
            for(int i = m; i >= binNum[index][0]; i --){
                for(int j = n; j >=binNum[index][1]; j --){
                    dp[i][j] = max(dp[i][j], dp[i - binNum[index][0]][j - binNum[index][1]] + 1);
                }
            }
        }
        return dp[m][n];
    }
};
```

dp数组的转移方程是`dp[i][j] = max(dp[i][j], dp[i - binNum[index][0]][j - binNum[index][1]] + 1)`。含义是不选当前字符串的子集长度和选了当前字符串后的子集长度的较大值。

**不要搞错**成`dp[i][j] = dp[i][j] + dp[i - binNum[index][0]][j - binNum[index][1]]`，后者的含义是凑成恰好 i 个 '0' 和 j 个 '1' 的方法总数，是[494题](#494目标和)的方法。

### 完全背包

[原题链接](https://kamacoder.com/problempage.php?pid=1052)

相比01背包最大的区别是元素可重复选取。带来的影响是dp数组的递推中，最大价值是不选该元素和选该元素的价值最大值。这里选该元素的价值最大值也是在第i行查找，而非01背包的i-1行。示意图如下![完全背包](https://cdn.jsdelivr.net/gh/HRbenY/blog-assets@master//img/20260117145644485.png)

对比[01背包的示意图](#01背包)更加清楚。

本题代码如下

```c++
#include <iostream>
#include <vector>

using namespace std;
int main() {
  int n, v;
  cin >> n;
  cin >> v;
  vector<vector<int>> pack(n, vector<int>(2, 0));
  for (auto &i : pack) {
    cin >> i[0]; //重量
    cin >> i[1]; //价值
  }
  vector<vector<int>> dp(n, vector<int>(v + 1, 0));

  for (int j = pack[0][0]; j <= v; j++) {
    dp[0][j] = dp[0][j - pack[0][0]] + pack[0][1];
  }

  for (int i = 1; i < n; i++) {
    for (int j = 0; j <= v; j++) {
      if (j < pack[i][0])
        dp[i][j] = dp[i - 1][j];
      else {
        dp[i][j] = max(dp[i - 1][j], dp[i][j - pack[i][0]] + pack[i][1]);
      }
    }
  }
  cout << dp[n - 1][v];
  return 0;
}
```

几点细节：

* 初始化时初始化第一行。因为dp数组递推中会用到上一行的结果。注意这里的初始化方式。
* 递推公式为`dp[i][j] = max(dp[i - 1][j], dp[i][j - pack[i][0]] + pack[i][1]);`

### 518 零钱兑换

[原题链接](https://leetcode.cn/problems/coin-change-ii/description/)

完全背包问题求组合数。代码如下

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<vector<int>> dp(coins.size(), vector<int>(amount + 1, 0));

        for(int j = 0; j <= amount; j ++){
            if(j % coins[0] == 0)dp[0][j] = 1;
        }

        for(int i = 1; i < coins.size(); i ++){
            for (int j = 0; j <= amount; j ++){
                if(j < coins[i])dp[i][j] = dp[i - 1][j];
                else dp[i][j] = (long) dp[i - 1][j] + dp[i][j - coins[i]];
            }
        }

        return dp[coins.size() - 1][amount];
    }
};
```

跟[494.目标和](#494目标和)类似，都是求组合数。完全背包的递推公式有所不同，`dp[i][j] = (long) dp[i - 1][j] + dp[i][j - coins[i]]`是不选新元素的组合数加选新元素的组合数，选新元素的组合数从同行取，从左往右自然算出了多个新元素的情况。01背包的对应项则是从上一行取。这点区别也在[完全背包](#完全背包)介绍了。

再就是**注意第二层for循环的起点位置**。`for (int j = 0; j <= amount; j ++)`这里要从0开始循环。有些情况直接从coins[i]开始就好，主要是看coins[i]左侧的格子要不要更新。这里我经常写错，要注意。

**初始化第一行第一列**。这里没有显示初始化，但是`if(j < coins[i])dp[i][j] = dp[i - 1][j];`保证了每行第一列都是1。

下面是一维压缩dp数组的实现。

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<uint64_t> dp(amount + 1, 0);

        for (int j = 0; j <= amount; j++){
            if (j % coins[0] == 0)dp[j] = 1;
        }

        for(int i = 1; i < coins.size(); i ++){
            for (int j = coins[i]; j <= amount; j ++){
                dp[j] += dp[j - coins[i]];
            }
        }

        return dp.back();
    }
};
```

跟01背包的一维压缩非常类似，递推也是`dp[j] += dp[j - coins[i]]`，只是遍历顺序有变化。**完全背包的第二层遍历是正序**的，这是因为完全背包较高重量的结果跟同一层较低质量的有关，所以**依赖更新后的dp数组**。而01背包依赖的都是上一层的结果，所以要避免在使用前就被更新，所以要倒序遍历。

这里第二层for循环`for (int j = coins[i]; j <= amount; j ++)`就改变了遍历起始点，呼应了之前所说的。

### 377. 组合总数

在[518.零钱兑换](#518-零钱兑换)的一维dp数组的基础上，交换for循环的顺序就是计算排列数了。代码如下：

```c++
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<uint64_t> dp(target + 1, 0);
        dp[0] = 1;
        for (int j = 0; j <= target; j ++){
            for(int i = 0; i < nums.size(); i ++){
                if(j < nums[i])continue;
                dp[j] += dp[j - nums[i]];
            }
        }
        return dp.back();
    }
};
```

为什么？交换顺序后，循环的含义变成了在给定的容量内遍历所有值，凑出给定的容量。在固定容量为j(dp[j])的情况下，遍历所有值nums[i]，意味着找出了所有以nums[i]为结尾的组合。在循环中将这些组合数都加起来了(`dp[j] += dp[j - nums[i]]`)，最终就能得到容量为j下的排列数。即**`dp[j]`的含义是容量为j的所有排列数**。从左往右遍历到target，就能得到结果。

此外，求排列时**dp数组初始化应该是`dp[0]`为1，其余都是0。**dp数组的大小跟求组合数时相同。

### 322. 零钱兑换

[原题链接](https://leetcode.cn/problems/coin-change/description/)

完全背包问题，dp数组的含义是刚好凑成目标金额的最少硬币个数。代码如下

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, -1);
        for(int j = 0; j <= amount; j ++){
            if(j % coins[0] == 0)dp[j] = j / coins[0];
        }
        for(int i = 1; i < coins.size(); i ++){
            for(int j = coins[i]; j <= amount; j ++){
                if(dp[j] != -1 && dp[j - coins[i]] != -1)dp[j] = min(dp[j], dp[j - coins[i]] + 1);
                else if(dp[j - coins[i]] != -1)dp[j] = dp[j - coins[i]] + 1;
            }
        }
        return dp.back();
    }
};
```

转移方程是`dp[j] = min(dp[j], dp[j - coins[i]] + 1)`不取新硬币的硬币总数和取新硬币的硬币总数取较小值。for循环中的`if(dp[j] != -1 && dp[j - coins[i]] != -1)`和`else if(dp[j - coins[i]] != -1)`是针对-1的处理。

### 139单词拆分

隐式的完全背包，排列问题。要移动字符串的分割点，与字典比对来判断是否能匹配上。dp数组dp[i]的含义是字符串s的前i个字符可以被完全表示。代码如下：

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        vector<string> word_set;
        for (const auto& word : wordDict) {
            word_set.push_back(word);
        }
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        int startIndex = 0;
        for (int j = 0; j <= s.size(); j++) {
            for (int i = 0; i < word_set.size(); i++) {
                if (j >= word_set[i].size()) {
                    startIndex = j - word_set[i].size();
                    if (word_set[i] ==
                        s.substr(startIndex, word_set[i].size())) {
                        dp[j] = dp[j] || dp[j - word_set[i].size()];
                    }
                }
            }
        }
        return dp.back();
    }
};
```

自己最初写的版本。之所以说是排列问题，是因为字符串匹配有顺序差别。比如s="aaaaaaa"，用"aaa"和"aaaa"匹配，当组合算的话就会输出false。我们的dp数组要把所有可以被完全表示的分割点位置都列举出来，这个例子的dp数组就应该是{1,0,0,1,1,0,1,1}。表示s的子序列长度从0到7的表示情况。  
上面的代码思路比较简单，两层for循环，外层`for (int j = 0; j <= s.size(); j++)`遍历子序列长度，内层`for (int i = 0; i < word_set.size(); i++)`遍历字典内容。比对内容是当前位置(j)往前推一个当前字典元素长度`word_set[i].size()`。用的vector做比对，时间复杂度比较高。常用的是下面的版本：
使用哈希表的优化版本

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet;
        for(const auto &word : wordDict){
            wordSet.insert(word);
        }
        vector<bool>dp(s.size() + 1, false);
        dp[0] = true;

        for(int j = 0; j <= s.size(); j++){
            for(int i = 0; i < j; i ++){
                string tmp = s.substr(i, j - i);
                if(wordSet.count(tmp) && dp[i])dp[j] = true;
            }
        }
        return dp.back();
    }
};
```

使用unordered_set，使查找的时间复杂度变为o(1)。此外，dp数组的含义没变 ，但是循环的含义变了。外层循环`for(int j = 0; j <= s.size(); j++)`依旧是遍历子串长度(j是子串截止位置)，内层循环`for(int i = 0; i < j; i ++)`遍历子串起始位置i。取出的子串是`s.substr(i, j - i)`。只有当取出的子串匹配上字典，而且子串开头位置是能被完全表示(`dp[i] == true`, 对应代码中的`if(wordSet.count(tmp) && dp[i])`)才认为当前的分割点j分割出的前j个字符组成的字符串是能被完全表示的，`dp[j] = true`。

### 背包问题学习总结

这份总结归纳了从 [01背包](#01背包) 到 [完全背包](#完全背包) 及其常见变体的核心思想和解题范式。

---

#### 1. 两大核心模型对比：01背包 vs 完全背包

背包问题的核心区别在于“物品是否可以重复选取”。

| 特性 | [01背包](#01背包) | [完全背包](#完全背包) |
| :--- | :--- | :--- |
| **物品限制** | 每件物品**只有1个** | 每件物品有**无限个** |
| **二维状态转移** | `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i])` | `dp[i][j] = max(dp[i - 1][j], dp[i][j - w[i]] + v[i])` |
| **核心差异** | 决策“放”物品时，依赖**上一行** `dp[i-1]` 的状态 | 决策“放”物品时，依赖**当前行** `dp[i]` 的状态 |
| **一维优化（滚动数组）**| **倒序**遍历背包容量 (`j` 从 `n` 到 `0`) | **正序**遍历背包容量 (`j` 从 `0` 到 `n`) |
| **一维优化原因**| 倒序是为了保证 `dp[j - w[i]]` 存储的是**上一行** (`i-1`) 的结果，防止物品被重复计算。 | 正序是为了保证 `dp[j - w[i]]` 存储的是**当前行** (`i`) 已更新的结果，从而实现物品的重复选取。 |

---

#### 2. 背包问题的目标变体

根据 `dp` 数组含义和状态转移方程的不同，背包问题可以解决不同目标。

##### 2.1 求最大价值 / 重量（最值问题）

这是最经典的形式，`dp[j]` 含义是容量为 `j` 时能装的最大价值。

* **转移方程**：`dp[j] = max(dp[j], dp[j - w[i]] + v[i])`
* **应用实例**：
    * [416.分割等和子集](#416分割等和子集)：判断背包能否“刚好装满”。`dp` 数组存最大价值，最后判断 `dp[sum / 2] == sum / 2`。
    * [1049.最后一块石头的重量](#1049-最后一块石头的重量)：目标是让两堆石头重量最接近 `sum / 2`。`dp` 数组存容量为 `j` 时能装的最大重量，结果为 `abs(sum - 2 * dp.back())`。

##### 2.2 求方法总数（组合问题）

`dp` 数组的含义变为“装满容量 `j` 有多少种方法”。

* **转移方程**：`dp[j] += dp[j - w[i]]` (累加方法数)
* **应用实例**：
    * [494.目标和](#494目标和)：01背包求组合数。通过数学转换为“装满 `(sum + target) / 2` 容量”的方法数。注意初始化 `dp[0]` 和处理 `nums[i] == 0` 的情况。
    * [518.零钱兑换](#518-零钱兑换)：完全背包求组合数。

##### 2.3 求最小/最大数量（最值问题）

`dp` 数组的含义变为“装满容量 `j` 所需的最小/最大物品数量”。

* **转移方程**：`dp[j] = min(dp[j], dp[j - w[i]] + 1)`
* **初始化**：求最小值时，通常将 `dp[0]` 初始化为0，其余初始化为-1或一个极大值。
* **应用实例**：
    * [322. 零钱兑换](#322-零钱兑换)：完全背包求装满 `amount` 的**最少硬币个数**。
    * [474. 一和零](#474-一和零)：01背包求**最大子集长度**。这是一个多维背包，`dp[i][j]` 含义是 `i` 个0和 `j` 个1能构成的最大子集长度，转移方程为 `dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)`。

---

#### 3. 组合与排列问题：循环顺序的微妙之处

在求方法总数的完全背包问题中，内外层循环的顺序决定了求的是“组合”还是“排列”。

* **求组合数：[518.零钱兑换](#518-零钱兑换)**
    * **循环顺序**：**外层遍历物品**，**内层遍历背包**。
    * **代码**：`for (item : items) { for (j = w[i]; j <= V; j++) { ... } }`
    * **含义**：`dp[j]` 考虑了用*前 `i` 种物品*凑成 `j` 的方法数，不考虑物品的添加顺序。

* **求排列数：[377. 组合总数](#377-组合总数)**
    * **循环顺序**：**外层遍历背包**，**内层遍历物品**。
    * **代码**：`for (j = 0; j <= V; j++) { for (item : items) { ... } }`
    * **含义**：`dp[j]` 变成了“容量为 `j` 的所有排列数”。在固定容量 `j` 时，遍历所有物品，找出了所有以 `nums[i]` *结尾*的排列。
    * [139单词拆分](#139单词拆分) 也是一个排列问题，因为单词的顺序至关重要。

---

#### 4. 常见问题转化

很多问题需要先“翻译”成背包模型才能求解。

* **[416.分割等和子集](#416分割等和子集)**
    * **转化**：是否可以从 `nums` 中选取若干数，使其和**恰好**为 `sum / 2`。
    * **模型**：01背包，容量 `V = sum / 2`，物品 `i` 的重量 `w[i] = nums[i]`，价值 `v[i] = nums[i]`。

* **[1049.最后一块石头的重量](#1049-最后一块石头的重量)**
    * **转化**：将石头分为两堆，使其重量差 `abs(sumA - sumB)` 最小。即 `abs(sum - 2 * sumB)` 最小。
    * **模型**：01背包，容量 `V = sum / 2`，物品 `i` 的重量 `w[i] = stones[i]`，价值 `v[i] = stones[i]`。目标是求 `dp[V]` 的最大值（最接近 `V` 的值），最终结果为 `abs(sum - 2 * dp[V])`。

* **[494.目标和](#494目标和)**
    * **转化**：设加 `+` 的为一堆 `P`，加 `-` 的为一堆 `N`。`sum(P) - sum(N) = target`。又 `sum(P) + sum(N) = sum`。两式相加得 `2 * sum(P) = sum + target`。
    * **模型**：01背包求组合数，容量 `V = (sum + target) / 2`。目标是求装满 `V` 有多少种方法。

* **[474. 一和零](#474-一和零)**
    * **转化**：物品是字符串，背包有两个维度的容量：`m` 个0和 `n` 个1。
    * **模型**：多维01背包。`dp[i][j]` 表示 `i` 个0和 `j` 个1容量下的最大子集长度。

### 198.打家劫舍

[原题链接](https://leetcode.cn/problems/house-robber/description/)

由于约束不能取相邻的房屋，所以要偷取最大金额的话偷取间隔只能是1或2，也就是偷完编号为i的房屋之后只能偷i+2或i+3。这样将dp[i]定义为第i个房屋处的最大收益，就可以通过两个或三个之前的房屋的收益加上当前房屋的金额，取较大值就可以了。最终结果也在后两个值中取较大值（对应抢或不抢最后一家）。代码如下

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size() == 1)return nums[0];
        if(nums.size() == 2)return max(nums[0], nums[1]);
        vector<int> dp(nums.size() + 1, 0);
        dp[0] = 0;
        dp[1] = nums[0];
        dp[2] = nums[1];
        for(int i = 3; i <= nums.size(); i ++){
            dp[i] = max(dp[i - 2] + nums[i - 1], dp[i - 3] + nums[i - 1]);
        }
        return max(dp[nums.size()], dp[nums.size() - 1]);
    }
};
```

转移方程是 `dp[i] = max(dp[i - 2] + nums[i - 1], dp[i - 3] + nums[i - 1]);`  
**当前状态和前面状态会有一种依赖关系，那么这种依赖关系都是动规的递推公式。**

下面是标准解法，dp[i]的定义是考虑前i个房子，打劫得的最大总金额。跟我们上面的解法的最大区别是**标准解法并不一定打劫i号房子**。那么新的转移逻辑就是dp[i]取打劫上一个房屋且不打劫当前房屋，和打劫上上个房屋以及当前房屋所得金额的较大值。代码如下：

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size() == 1)return nums[0];
        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for(int i = 2; i < nums.size(); i ++){
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp.back();
    }
};
```

转移公式是`dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])`

### LCR 090.打家劫舍II

[原题链接](https://leetcode.cn/problems/PzWKhm/description/)

在[198](#198打家劫舍)的基础上变成了环形，意味着第一个和最后一个房屋不能同时选。可以把问题拆分成两个，即去掉第一个房屋后的所有房屋正常打劫和去掉最后一个房屋后的所有房屋正常打劫，两个结果取较大值。代码如下

```c++
class Solution {
public:
    int rob_func(vector<int>& nums) {
        if (nums.size() == 1)
            return nums[0];
        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i < nums.size(); i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp.back();
    }
    int rob(vector<int>& nums) {
        if(nums.size() == 1)return nums[0];
        vector<int> vector1(nums.begin(), nums.end() - 1);
        vector<int> vector2(nums.begin() + 1, nums.end());
        int result1 = rob_func(vector1);
        int result2 = rob_func(vector2);
        return max(result1, result2);
    }
};
```

### 337. 打家劫舍III

[原题链接](https://leetcode.cn/problems/house-robber-iii/)

在二叉树上进行打劫。根节点的最大打劫金额跟左右孩子有关，打劫根节点就不能打劫左右孩子，不打劫根节点既可以打劫孩子又可以不打，取较大值。所以需要后序遍历。代码如下

```c++
class Solution {
public:
    int rob(TreeNode* root) {
        vector<int> result = robTree(root);
        return max(result[0], result[1]);
    }
    // 长度为2的数组，0：不偷，1：偷
    vector<int> robTree(TreeNode* cur) {
        if (cur == NULL) return vector<int>{0, 0};
        vector<int> left = robTree(cur->left);
        vector<int> right = robTree(cur->right);
        // 偷cur，那么就不能偷左右节点。
        int val1 = cur->val + left[0] + right[0];
        // 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况
        int val2 = max(left[0], left[1]) + max(right[0], right[1]);
        return {val2, val1};
    }
};
```

正如代码中的备注，使用一对值来描述偷与不偷当前节点。特别注意这里的不偷cur，不偷cur并不意味着一定要偷左右孩子，这时候要先分别比较左孩子偷与不偷的收益，右孩子偷与不偷的收益。

### 121. 买卖股票的最佳时机

[原题链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

dp数组的含义是dp[i][0]表示第i天不持有股票的现金,dp[i][1]表示第i填持有股票的现金。则转移过程为dp[i][0]可以是昨天也不持有的现金和昨天持有，今天卖出的较大值，dp[i][1]为昨天也持有的现金和昨天不持有，今天买入的现金的较大值。由于只能买卖一次，那么买入股票前的现金一定是0(因为这时不会有收益)。代码如下

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(2, vector<int>(2, 0));
        dp[0][0] = 0; dp[0][1] = -prices[0];
        for(int i = 1; i < prices.size(); i ++){
            dp[i % 2][0] = max(dp[1 - (i % 2)][0], dp[1 - (i % 2)][1] + prices[i]);
            dp[i % 2][1] = max(- prices[i], dp[1 - (i % 2)][1]);
        }
        return dp[(prices.size() - 1) % 2][0];
        // return dp[3][0];

    }
};
```
实现中因为当天的状态更新只与前一天有关，所以利用滚动数组减少空间占用。

状态转移公式为`dp[i % 2][0] = max(dp[1 - (i % 2)][0], dp[1 - (i % 2)][1] + prices[i])`和`dp[i % 2][1] = max(- prices[i], dp[1 - (i % 2)][1])`，这里`dp[i % 2][1]是从- prices[i]`和`dp[1 - (i % 2)][1]`取较大值，前者意味着0-prices[0]，对应买股票之前的现金一定是0。

### 122 买卖股票的最佳时机 II

[原题链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)

相较于[上一题](#121-买卖股票的最佳时机)，II不限次数买卖股票。其实跟I只有一点不同，即本题要考虑在买股票之前的现金，不一定为0了。代码如下

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(2, vector<int>(2, 0));
        dp[0][0] = 0; dp[0][1] = -prices[0];
        for(int i = 1; i < prices.size(); i ++){
            dp[i % 2][0] = max(dp[1 - i % 2][0], prices[i] + dp[1 - i % 2][1]);
            dp[i % 2][1] = max(dp[1 - i % 2][0] - prices[i], dp[1 - i % 2][1]);
        }
        return dp[((prices.size() - 1) % 2)][0];
    }
};
```
可以看出只有一点不同，即`dp[i % 2][1] = max(dp[1 - i % 2][0] - prices[i], dp[1 - i % 2][1]);`max中的第一项要考虑前一天不持有股票的现金，即`dp[1 - i % 2][0]`。

### 123. 买卖股票的最佳时机III

[原题链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

现在限制最多只能完成两笔交易，那就要把状态分清楚。比如第一次买入，第一次卖出，第二次买入，第二次卖出。代码如下

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(2, vector<int>(4, 0));
        dp[0][0] = -prices[0];
        dp[0][2] = -prices[0];
        for(int i = 1; i < prices.size(); i ++){
            dp[i % 2][0] = max(dp[1 - i % 2][0], -prices[i]);
            dp[i % 2][1] = max(dp[1 - i % 2][1], dp[1 - i % 2][0] + prices[i]);
            dp[i % 2][2] = max(dp[1 - i % 2][2], dp[1 - i % 2][1] - prices[i]);
            dp[i % 2][3] = max(dp[1 - i % 2][3], dp[1 - i % 2][2] + prices[i]);
        }
        return dp[(prices.size() - 1) % 2][3];
    }
};
```

当天第一次买入之前现金都是0，所以第一次买入后的现金取`dp[1 - i % 2][0]`和`-prices[i]`的较小值，和[最佳时机I](#121-买卖股票的最佳时机)是类似的。此后的状态更新都与上一层有关，现金状态都是继承的上一层。所以可以推广到买卖k次，也就是下一题。

### 188. 买卖股票的最佳时机IV

[原题链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

现在要求最多买卖k次，由[买卖股票III](#123-买卖股票的最佳时机iii)可知，第i次交易的现金仅取决于第i-1次交易。所以可以使用两层循环，外层循环遍历日期，内层循环遍历交易次数。也就是先交易完第j天的所有k次交易，再进入第二天。这样一来dp数组的定义如下：dp[i][0]表示当前是第i次交易，0代表持有股票；dp[i][1]表示当前是第i次交易,1代表不持有股票。初始化时将dp[0][0]设为购买第一天的股票之后的现金。这样一来第j天的所有交易结束后，**第二天时会在原地覆盖dp数组。**

我一开始有疑问，为什么可以这样覆盖？第二天的第一次交易的dp数组不应该根据第一天第一次交易的dp数组来推导吗？  
实际上，当递推到第二天，要决策今天第i笔交易时，按照[123](#123-买卖股票的最佳时机iii)的经验,我们确实要依赖第一天的第i笔交易的结果。可是昨天第i笔交易对应的dp数组的含义是**前i笔交易**的最优解，是持有现金的最大值。**如果在第i笔交易中，我们依照的昨天的dp[i]不是最优解，那么使用这个次优解算出来的结果一定会被之后第i + n笔交易中，由昨天的dp[i + n]算出来的今天的dp[i + n]所超越。** 现在的算法（把一天中迭代k次得到的最优解传递到下一天）实际上相当于省略了用次优解迭代的过程。

代码如下

```c++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        vector<vector<int>> dp(k + 1, vector<int>(2, 0));
        for(int i = 0; i <= k; i ++){
            dp[i][0] = -prices[0];
        }
        for(int j = 1; j < prices.size(); j ++){
            for(int i = 1; i <= k; i ++){
                dp[i][0] = max(dp[i][0], dp[i - 1][1] - prices[j]);
                dp[i][1] = max(dp[i][1], dp[i][0] + prices[j]);
            }
        }
        return dp.back()[1];
    }
};
```

实现上dp数组多了一个维度存储最开始的状态，将所有持有股票的状态都设为`-prices[0]`。循环从j = 1, i = 1开始，也就是第二天和第1次交易。递推公式跟之前的没有区别。

### 309. 最佳买卖股票时机含冷冻期

[原题链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)

相比于[122](#122-买卖股票的最佳时机-ii)，新增了卖出后第三天才能买的限制。只要把更新当天买入的dp数组的逻辑改成判断昨天的买入和前天卖出今天买入的最大值就可以了。记得处理一下第二天的边界条件。代码如下

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        dp[0][0] = - prices[0];
        for(int i = 1; i < prices.size(); i ++){
            if(i == 1){
                dp[i][0] = max(dp[i - 1][0], - prices[1]);
            }
            else{
                dp[i][0] = max(dp[i - 1][0], dp[i - 2][1] - prices[i]);
            }
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp.back()[1];
    }
};
```

### 714.买卖股票的最佳时机含手续费

[原题链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

在[122](#122-买卖股票的最佳时机-ii)的基础上，每次交易加上手续费就好。买入时加上和卖出时加上都可以。差别只在持股状态的现金。买入时-fee得到的持股现金是扣过费的，空仓状态下的现金是完全一样的。代码如下

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        dp[0][0] = - prices[0] - fee;
        for(int i = 1; i < prices.size(); i ++){
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i] - fee);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp.back()[1];
    }
};
```

### 300.最长递增子序列

[原题链接](https://leetcode.cn/problems/longest-increasing-subsequence/description/)

dp[i]的含义是以nums[i]结尾的递增子序列长度。这样我们一项一项更新dp[i]就可以得到最长的了。代码如下

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> dp(nums.size(), 1);
        int result = 0;
        for(int i = 0; i < nums.size(); i ++){
            for(int j = 0; j < i; j ++){
                if(nums[i] > nums[j])dp[i] = max(dp[i], dp[j] + 1);
            }
            result = max(result, dp[i]);
        }
        return result;
    }
};
```

更新dp[i]的逻辑是从0到i搜索比nums[i]更小的nums[j],找到了就说明当前的nums[i]可以接在nums[j]的后面。那么以nums[i]结尾的递增子序列长度就要取没接之前的长度(dp[i])和接了之后的长度(dp[j] + 1)的较大值。

### 718.最长重复子数组

[原题链接](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

dp数组为dp[i][j]，含义是以nums2[i]结尾和nums1[j]结尾的子数组长度。那么dp[i][j]的值取决于dp[i - 1][j - 1]的值。如果nums2[i]和nums1[j]相等，则dp[i][j] = dp[i - 1][j - 1] + 1。否则为0。由于要用到i - 1和j - 1，所以要初始化i = 0和j = 0的所有值。代码如下

```c++
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int result = 0;
        vector<vector<int>> dp(nums2.size(), vector<int>(nums1.size(), 0));
        for(int i = 0; i < nums2.size(); i ++){
            dp[i][0] = nums2[i] == nums1[0];
            result = max(result, dp[i][0]);
        }
        for(int j = 0; j < nums1.size(); j ++){
            dp[0][j] = nums1[j] == nums2[0];
            result = max(result, dp[0][j]);
        }
        for(int i = 1; i < nums2.size(); i ++){
            for(int j = 1; j < nums1.size(); j ++){
                if(nums1[j] == nums2[i]){
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else{
                    dp[i][j] = 0;
                }
                result = max(result, dp[i][j]);
            }
        }
        return result;
    }
};
```

如果一开始定义数组时多定义一格，即`vector<vector<int>> dp(nums2.size() + 1, vector<int>(nums1.size() + 1, 0));`那么初始化第一行第一列的过程就可以同样放在循环内执行。代码如下

```c++
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int result = 0;
        vector<vector<int>> dp(nums2.size() + 1, vector<int>(nums1.size() + 1, 0));
        for(int i = 1; i <= nums2.size(); i ++){
            for(int j = 1; j <= nums1.size(); j ++){
                if(nums1[j - 1] == nums2[i - 1]){
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else{
                    dp[i][j] = 0;
                }
                result = max(result, dp[i][j]);
            }
        }
        return result;
    }
};
```

注意到`dp[i][j]`的更新只与左上角有关，可以优化成滚动数组。代码如下 

```c++
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        vector<int> dp(nums1.size() + 1, 0);
        int result = 0;
        for(int j = 0; j < nums2.size(); j ++){
            for(int i = nums1.size(); i >= 1; i --){
                if(nums1[i - 1] == nums2[j]){
                    dp[i] = dp[i - 1] + 1;
                    result = max(dp[i], result);
                }
                else dp[i] = 0;               
            }

        }
        return result;
    }
};
```

跟背包问题数组降维类似，这里dp[i]的更新依赖于更新前的dp[i - 1]，所以第二层循环从右往左遍历。此外，不需要额外的初始化循环。因为一开始dp数组就是全0的，第一次循环的逻辑并没有什么特别的地方。

### 1143.最长公共子序列 

[原题链接](https://leetcode.cn/problems/longest-common-subsequence/description/)

dp数组的含义是dp[i][j]表示text2的前i - 1长度和text1的前j - 1长度子序列的最大公共长度。代码如下：

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        vector<vector<int>>dp(text2.size() + 1, vector<int>(text1.size() + 1, 0));
            for(int i = 1; i <= text2.size(); i ++){
                for(int j = 1; j <= text1.size(); j ++){
                    if(text2[i - 1] == text1[j - 1])dp[i][j] = dp[i - 1][j - 1] + 1;
                    else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
            return dp.back().back();
    }   
};
```

转移过程是
`dp[i][j] = dp[i - 1][j - 1] + 1;`和`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);`
当`text2[i - 1] == text1[j - 1]`时说明当前字符匹配上了，公共子序列的长度在左上角`dp[i - 1][j - 1]`的基础上+1。否则取上面`dp[i - 1][j]`和下面`dp[i][j - 1]`的较大值。

### 1035. 不相交的线

[原题链接](https://leetcode.cn/problems/uncrossed-lines/description/)

跟[1143.最长公共子序列](#1143最长公共子序列)是一模一样的。

### 115. 不同的子序列

[原题链接](https://leetcode.cn/problems/distinct-subsequences/description/)

dp数组的含义是dp[i][j]表示t的前i个字符组成的子串和s的前j个子串匹配，t的子串出现的次数。状态转移考虑当前字符匹配上和不匹配上两种情况。如果匹配上，又可以分出两种情况。第一种末尾选择t[i - 1]，可以看作是*t的前i-1个字符的子串*在*s的前j-1个字符的子串*中出现次数的延申，另一种情况末尾不选择t[i - 1]，退化成t的前i个字符在s的前j-1个字符中出现的情况。这两种情况加起来就是匹配上的转移过程。如果匹配不上就跟dp[i][j-1]一样了。

初始化时要把i = 0的情况全赋为1，除了i = 0以外的第一列(j = 0)都赋为0.因为i = 0的情况本质上是空字符串与s的匹配数量，肯定是1.代码如下


```c++
class Solution {
public:
    int numDistinct(string s, string t) {
        vector<vector<uint64_t>> dp(t.size() + 1, vector<uint64_t>(s.size() + 1, 0));
        for(int j = 0; j <= s.size(); j ++)dp[0][j] = 1;
        for(int i = 1; i <= t.size(); i ++){
            for(int j = i; j <= s.size(); j ++){
                if(t[i - 1] == s[j - 1])dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1];
                else dp[i][j] = dp[i][j - 1];
            }
        }
        return dp[t.size()][s.size()];
    }
}; 
```


匹配上的状态转移为`dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1]`,匹配不上为`dp[i][j] = dp[i][j - 1]`。

### 583.两个字符串的删除操作

[原题链接](https://leetcode.cn/problems/delete-operation-for-two-strings/description/)

题目要求删除最少的字符数，使两个字符串相等。可以转换成求两个字符串的最大相等子串长度，即[1143题](#1143最长公共子序列)。最后对结果处理一下就可以了。代码如下

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word2.size() + 1, vector<int> (word1.size() + 1, 0));
        for(int i = 1; i <= word2.size(); i++){
            for(int j = 1; j <= word1.size(); j++){
                if(word2[i - 1] == word1[j - 1]){
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return word1.size() + word2.size() - 2 * dp[word2.size()][word1.size()];
    }
};
```

###  72. 编辑距离 

[原题链接](https://leetcode.cn/problems/edit-distance/description/)

dp数组的含义是dp[i][j]代表word2的前i项，word1的前j项的最小编辑距离。状态更新中，dp[i][j]有两种情况，取决于word2[i-1]和word1[j-1]的相等情况。

1. 如果相等，那么当前等价于word2和word1都舍去尾部相等的这个元素，退化成`dp[i-1][j-1]`。
2. 如果不等，我们可以通过*删除word1的一个元素*、*删除word2的一个元素*和*改变一个元素*这三种方法将目前状态转换成我们已经推导出来的状态。上述三种操作分别对应得到`dp[i][j - 1]`、`dp[i - 1][j]`、`dp[i - 1][j - 1]`，并且加上我们的一次操作数。取这三种操作的最小值就是不相等情况的转移方程了。(题目还支持插入字符，但是其实对word1插入一个字符跟删除word2的一个字符是等效的)

至于初始化，要从定义出发。比如dp[0][j]的含义是word1是空字符串，转换成word1的操作数自然就是word1的长度j了。

代码如下

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word2.size() + 1, vector<int>(word1.size() + 1, 0));
        for(int i = 0; i <= word2.size(); i ++)dp[i][0] = i;
        for(int j = 0; j <= word1.size(); j ++)dp[0][j] = j;
        for(int i = 1; i <= word2.size(); i ++){
            for(int j = 1; j <= word1.size(); j ++){
                if(word2[i - 1] == word1[j - 1])dp[i][j] = dp[i - 1][j - 1];
                else{
                    dp[i][j] = min(dp[i - 1][j - 1] + 1, min(dp[i - 1][j] + 1, dp[i][j - 1] + 1));
                }
            }
        }
        return dp[word2.size()][word1.size()];

    }
};
```
编辑距离问题，乃至涉及两个字符串、序列的各种操作比较，dp数组的定义都是从分割出来的子序列着手。由相不相等进一步推导出转移方程。

### 647.回文子串

[原题链接](https://leetcode.cn/problems/palindromic-substrings/description/)

dp数组的含义是dp[i][j]表示从i到j的子串是不是回文子串。更新dp数组的过程中，如果s[i] == s[j]，那么dp[i][j]就依赖于在此基础上去头去尾的子串是不是回文串，即dp[i + 1][j - 1]。由于要用到i + 1的dp值，这里i要反向遍历。代码如下

```c++
class Solution {
public:
    int countSubstrings(string s) {
        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), false));
        int result = 0;
        for(int i = s.size() - 1; i >= 0; i --){
            for(int j = i; j < s.size(); j ++){
                if(s[i] == s[j]){
                    if (j - i < 2)dp[i][j] = true;
                    else dp[i][j] = dp[i + 1][j - 1];
                }
                if(dp[i][j])result ++;
            }
        }
        return result;
    }
};
```

除了要注意反向遍历i`for(int i = s.size() - 1; i >= 0; i --)`，还要单独考虑s[i] == s[j]时子串长度小于等于2的情况。即`if (j - i < 2)dp[i][j] = true`

### 516. 最长回文子序列

[原题链接](https://leetcode.cn/problems/longest-palindromic-subsequence/description/)

dp[i][j]代表给定字符串从i到j的最长回文子序列长度。跟[647题](#647回文子串)类似，如果s[i] == s[j]，那么当前子串是不是回文串取决于s[i + 1]到s[j - 1]的子串是不是回文串。即dp[i + 1][j - 1]。在此基础上加二作为新增的首尾就行。如果s[i] != s[j]，那么当前子串的最长回文子序列长度是s[i + 1]到s[j]和s[i]到s[j - 1]的较大值。为什么？因为既然首位不相等，那么s[i]和s[j]绝对不能作为一个回文串的两端。那么包含s[i]和s[j]的最长回文串，要么不包含s[i]，要么不包含s[j]。取这两种情况的最大值，即dp[i + 1][j]和dp[i][j - 1]的较大值。代码如下

```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        vector<vector<int>>dp(s.size(), vector(s.size(), 0));
            for(int i = 0; i < s.size(); i ++){
                dp[i][i] = 1;
            }
            for(int i = s.size() - 1; i >= 0; i --){
                for(int j = i + 1; j < s.size(); j ++){
                    if(s[i] == s[j])dp[i][j] = dp[i + 1][j - 1] + 2;
                    else dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]);
                }
            }
            return dp[0][s.size() - 1];
    }
};
```
