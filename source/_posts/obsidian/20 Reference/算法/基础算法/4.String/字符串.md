---
Author: Spa-Master
日期: 2026年1月17日
tags:
- lang/cpp
title: 字符串
---

# 字符串
## 循环写法
| 循环写法                           | 含义                                     | 性能                               | 能否修改原始元素？ | 适用场景                               |
| :--------------------------------- | :--------------------------------------- | :--------------------------------- | :----------------- | :------------------------------------- |
| `for (string s : words)`           | **值拷贝 (Pass by Value)** | **慢** (每次循环都复制整个字符串)  | **不能** | 很少使用，除非你需要在循环内修改副本且不影响原数据。 |
| `for (string& s : words)`          | **引用 (Pass by Reference)** | **快** (没有复制开销)              | **能** | 当你需要**遍历并修改**容器中的元素时。       |
| `for (const string& s : words)`    | **常量引用 (Pass by const Reference)** | **快** (没有复制开销)              | **不能** (只读)    | 当你只需要**遍历并读取**元素，不进行修改时。**（最佳实践）** |
| `for (const string s : words)`     | **常量值拷贝 (const Pass by Value)** | **慢** (依然有复制开销)            | **不能** | 几乎无用，结合了值拷贝的低效和 `const` 的只读，意义不大。 |

或者，使用auto关键字

| 使用 `auto` 的写法                 | 等价于                               | 解释                                                         |
| :--------------------------------- | :----------------------------------- | :----------------------------------------------------------- |
| `for (auto s : words)`             | `for (string s : words)`             | `auto` 被推断为 `string` 类型，进行**值拷贝**。**（慢）** |
| `for (auto& s : words)`            | `for (string& s : words)`            | `auto&` 被推断为 `string&` 类型，进行**引用**。**（快，可修改）** |
| `for (const auto& s : words)`      | `for (const string& s : words)`      | `const auto&` 被推断为 `const string&` 类型，进行**常量引用**。**（快，只读）** |

## 字符串操作

### 1. 容量和大小 (Capacity)
  
  * **`.size()` 和 `.length()`**: 功能相同，返回字符串中的字符数。
  * **`.capacity()`**: 返回在不重新分配内存的情况下，字符串可以容纳的字符数。
  * **`.empty()`**: 检查字符串是否为空 (`size() == 0`)。返回 `true` 或 `false`。
  * **`.reserve(n)`**: 请求为字符串预留至少 `n` 个字符的存储空间。
  * **`.shrink_to_fit()`**: (C++11) 请求减少容量以匹配其大小。
  * **`.resize(n, c)`**: 改变字符串的大小为 `n`。如果 `n` 更大，用字符 `c` 填充；如果更小，则截断。
  * **`.clear()`**: 清空字符串内容，使其变为空字符串。
  
  ### 2. 元素访问 (Element Access)
  
  * **`operator[]`**: 使用下标访问字符，例如 `str[i]`。不进行边界检查。
  * **`.at(i)`**: 与 `[]` 类似，但会进行边界检查，越界会抛出异常。
  * **`.front()`**: 返回第一个字符的引用。
  * **`.back()`**: 返回最后一个字符的引用。
  
  ### 3. 修改器 (Modifiers)
  
  * **`operator+=`**: 拼接（追加）另一个字符串、C风格字符串或单个字符。
  * **`.append(...)`**: 功能更丰富的追加操作。
  * **`.push_back(c)`**: 在字符串末尾追加一个字符 `c`。
  * **`.assign(...)`**: 赋新值，替换字符串原有内容。
  * **`.insert(pos, ...)`**: 在指定位置 `pos` 插入字符或字符串。
  * **`.erase(pos, count)`**: 删除从位置 `pos` 开始的 `count` 个字符。
  * **`.replace(pos, count, ...)`**: 替换字符串中的一部分内容。
  * **`.swap(other_str)`**: 与另一个 `std::string` 对象交换内容。
  * **`.pop_back()`**: (C++11) 删除字符串的最后一个字符。
  
  ### 4. 字符串操作 (String Operations)
  
  * **`.c_str()`**: 返回一个指向以空字符 `\0` 结尾的C风格字符串 (`const char*`)。
  * **`.data()`**: (C++11) 返回指向字符串内部数据数组的指针。
  * **`.find(substr, pos)`**: 从位置 `pos` 开始，查找 `substr` 第一次出现的位置。
  * **`.rfind(substr, pos)`**: 从位置 `pos` 开始，反向查找 `substr` 第一次出现的位置。
  * **`.find_first_of(chars, pos)`**: 查找 `chars` 中任意一个字符第一次出现的位置。
  * **`.find_last_of(chars, pos)`**: 查找 `chars` 中任意一个字符最后一次出现的位置。
  * **`.find_first_not_of(chars, pos)`**: 查找第一个不属于 `chars` 中任意一个字符的位置。
  * **`.find_last_not_of(chars, pos)`**: 查找最后一个不属于 `chars` 中任意一个字符的位置。
  * **`.substr(pos, count)`**: 提取从位置 `pos` 开始，长度为 `count` 的子字符串。
  * **`.compare(other_str)`**: 按字典序比较两个字符串。
  
  ### 5. 迭代器 (Iterators)
  
  * **`.begin()` / `.cbegin()`**: 返回指向字符串头部的迭代器。
  * **`.end()` / `.cend()`**: 返回指向字符串尾部之后位置的迭代器。
  * **`.rbegin()` / `.crbegin()`**: 返回指向字符串尾部的反向迭代器。
  * **`.rend()` / `.crend()`**: 返回指向字符串头部之前位置的反向迭代器。

[原题链接](https://kamacoder.com/problempage.php?pid=1064)

### 54. 替换数字（第八期模拟笔试）

替换数字，涉及到数组扩容，我们可以先扩容然后从后往前填充。这也是常用做法。具体是一个指针从原字符串末尾往左走，另一个字符串从扩容后的字符串末尾往左走。

```c++
while (cin >> s)
```

这里cin一次输入一个字符串（而不是一个字符），检测到空格停止输入。

```c++
s.resize(s.size() + 5 * count);
```

``.resize()``函数。

### 151. 反转字符串中的单词

[原题链接](https://leetcode.cn/problems/reverse-words-in-a-string/description/)

分三步，首先把字符串全部反转，再去除多余空格，最后把每个单词反转。这里去除空格的逻辑容易搞错。

```c++
void reverseString(string &s, int start, int end)
{
    while (start < end)
    {
        swap(s[start++], s[end--]);
    }
}
```

之前写过的反转字符串函数，可以接收输入反转的起点和终点，即将字符串的[start, end]闭区间反转。**不过后面不要求自己写的话可以直接调用algorithm中的reverse函数**，接受两个迭代器输入。

```c++
void deleteSpace(string &s)
{
    int slow = 0;
    for (int fast = 0; fast < s.size(); fast ++){
        if (s[fast] != ' '){ 
            if (slow != 0){ //排除开头第一个单词的情况
                s[slow++] = ' ';
            }
            while(fast < s.size() && s[fast] != ' '){
                s[slow++] = s[fast++];
            }
        }
    }
    s.resize(slow);
}
```

消除多余空格的函数，从三个角度考虑：消除开头的空格，消除单词间的空格，消除末尾的空格。  
``if (s[fast] != ' ')``当检查到字母再进行后续程序。当条件成立说明找到了单词，``slow``指针添加一个空格，再进入后续循环。  
特别要想清楚处理完成后字符串的长度是多少。因为slow指针在存放完最后一个单词的最后一个字母后又右移了一位，所以指向的是``s.size()``，所以``s.resize(slow)``

### 55. 右旋转字符串（卡玛）

[原题链接](https://kamacoder.com/problempage.php?pid=1065)

先整体反转，再分别反转。


KMP算法，要在文本串中查找特定的模式串。因为我们肯定是在文本串中顺序比对的，当匹配到一半发现有不一样的字符之后本来要重新从第二个字符开始匹配。显然会浪费大量时间。由于我们之前的匹配过程中已经得到了部分文本串的信息，比如要在"aabaabaafa"中查找“aabaaf”,文本串第六个字符处失配，对应模式串第六个字符。由于我们已经匹配了模式串的前五个字符了，为了避免再从头开始匹配模式串，可以比较一下模式串的前缀和后缀的区别。例如这里匹配上的前五个字符有相同前后缀“aa”，这意味着文本串匹配模式串第四五个字符的同时，也匹配了前两个字符。这样一来碰到第六个失配字符，可以移动到上一步匹配好的第四五个字符进行下一次迭代。即文本串的第四五个字符匹配上了模式串的第一二个字符，然后开始比对下一个字符。

![KMP算法](https://cdn.jsdelivr.net/gh/HRbenY/blog-assets@master//img/20260117145504169.png)

KMP算法中next数组是实现上述过程的重要变量。数组中存放着模式串各字符的最大相等前后缀 - 1，比如在这个例子中"aabaaf"的第六个元素next[5]=2-1,即最大相等前后缀2，减一代表对应的字符串索引。这样一来next[5]就告诉了程序当碰到第六个元素刚好失配时指针应该去哪里（第二个元素）。

```c++
next[0] = -1;
int j = -1;
for (int i = 1; i < s.size(); i++)
{
    while ((j != -1) && (s[i] != s[j + 1]))
    {
        j = next[j];
    }
    if (s[i] == s[j + 1])
    {
        j++;
    }
    next[i] = j;
}
```

这是计算next数组的函数，从s[1]开始计算依次next数组，next[0]赋值-1。while循环代表前后缀不匹配时的迭代过程。j = next[j]是最关键的步骤，意味着当前后缀在j+1处失配时，又调用了之前计算的部分next数组进行高效的回退。可以想象成这里吧某个长度的后缀当作文本串，相等长度的前缀当成模式串进行匹配。理所当然可以利用已经计算好的next数组。
