---
Author: Spa-Master
日期: 2026年1月17日
tags:
- '#lang/cpp'
- '#topic/algo'
- '#type/note'
title: 编辑距离
---

## 标准编辑距离

标准编辑距离不限制中间态。使用动态规划，`dp[i][j]`表示字符串1的前i前缀和字符串2的前j前缀的编辑距离。那么可以跟`dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]`形成递推关系。如下：

- 如果两个字符串的前缀的最后一个字母相同，那么退化成`dp[i - 1][j - 1]`的编辑距离。
- 否则，可以是字符串1删减一个`dp[i - 1][j]`；字符串2删减一个`dp[i][j - 1]`；或者进行一次修改让两字符串后缀相同，然后退化成`dp[i - 1][j - 1]`。取这三种情况的最小值，然后加上这次编辑新增的编辑距离（+1）。

需要初始化i、j为0的边界情况，根据定义`dp[0][j]`表示的意思是字符串2的前j前缀和零长度字符串的编辑距离，当然是j。同理对`dp[i][0]`初始化。

- 注意，要事先将dp数组初始化成`vector<vector<int>> dp(string1.size() + 1, vector<int>(string2).size() + 1, 0)`,多初始化一行列。

更难的是编辑距离的变种，限制中间态的情况。如[lc127](https://leetcode.cn/problems/word-ladder/description/)、[lc126](https://leetcode.cn/problems/word-ladder-ii/description/)。

## 变种

### 0. 两题本质差异（决定写法差异）

- **127（Word Ladder）**：只要最短长度  
    → BFS 访问到一个单词 **第一次** 就是最短，后续再到达没有意义  
    → “访问即删除/visited=true” 是最优策略
    
- **126（Word Ladder II）**：要输出**所有**最短路径  
    → 同一个单词在最短层级可能有**多个父节点**  
    → 不能“访问即删除”，否则会丢掉其它最短路径分支  
    → 必须 **BFS 建 parent 图 + DFS 回溯输出**
    

---

### 1. 我在 127 的核心困惑点复盘

#### Q1：是不是层序遍历？

- ✅ 是，本质就是 **隐式图的层序遍历**
    
- 每层代表“改变了几次字符”
    
- `step` 就是 BFS 层数（包含 begin/end）
    

#### Q2：为什么可以从 set/map 里删掉遍历过的单词？

- ✅ 因为 127 只求最短长度：  
    BFS 第一次到达节点 = 最短距离确定  
    再次到达只会更长，所以删掉等价于 `visited`
    

#### 我最终记住的 127 模板

- `unordered_set dict` 存词典
    
- `queue` BFS
    
- 生成邻居：枚举位置 * 26 字母
    
- **入队就 erase**，避免重复入队/爆队列
    

---

### 2. 我在 126 的关键疑惑点复盘

#### Q1：126 能不能用邻接表？为什么 127 你说“不需要”？

- ✅ 126 必须保存结构（边）才能输出路径：  
    不是“能不能”，而是“**必须**”
    
- 127 的邻接关系是一次性的（生成即用），存图浪费；  
    126 的邻接关系是答案的一部分（要回溯），必须存。
    

#### Q2：为什么 126 必须存 `child -> parents`（反向邻接表），而不是 `parent -> children`？

- ✅ 因为 DFS 回溯从 `endWord` 开始最自然
    
- 存 `child -> parents` 可以直接从终点一路回到起点
    
- 正向也能做，但会额外复杂（要记录层级/剪枝/保证最短）
    

---

### 3. 126 写代码时我踩过的典型坑（按出现顺序）

#### 错误 1：试图像 127 一样“边 BFS 边存路径”

**表现：**

- 用 `vector<vector<string>> path` / `p.push_back(word)` 之类存“每层”或“路径”
    
- 发现 `p.push_back(word)` 会重复（同一个 word 被 push 多次）
    

**原因本质：**

- 126 需要的是 **多父节点关系**，不是“层列表”
    
- “层”不等于“路径结构”
    
- 你那种存法无法表达：同一 child 来自多个 parent
    

**正确做法：**

- BFS 只做一件事：建立 `parent[child].push_back(parent)`
    
- BFS 完成后 DFS 回溯输出路径
    

---

#### 错误 2：不立刻 erase 时，队列会不会 push 重复单词？

**表现：**

- 担心一层里多个父节点生成同一个 next，会重复入队
    

**正确策略（两套 visited）：**

- `visited_level`：本层去重（避免重复入队）
    
- `dict/uset`：跨层去重（层末统一 erase）
    

**结论：**

- **同层：允许多父，但队列只入一次**
    
- `parent[next]` 可能加很多次（多父），`queue` 只 push 一次（去重）
    

---

#### 错误 3：visited_level 只 clear 不 erase

**表现：**

- 层末只有 `visited_level.clear()`
    
- 没有 `uset.erase(x)`  
    → 会导致下一层还能再次访问这些词，污染 parent 图，甚至爆搜索
    

**正确做法：**

```cpp
for (auto &w : visited_level) dict.erase(w);
visited_level.clear();
```

---

#### 错误 4：DFS 起点/方向错、空 path 调用 front/back

**表现：**

- `dfs(path, ...)` 时 `path` 为空
    
- `path.front()` / `path.back()` 直接 UB
    
- 或从 `beginWord` 开始 DFS，但 parent 图是反向的
    

**正确做法：**

- DFS 从 `endWord` 开始：
    

```cpp
path.push_back(endWord);
dfs(...);
```

- 终止条件是到达 `beginWord`
    

---

#### 错误 5：输出路径方向反了

**表现：**

- DFS 构造的 path 是 `[end ... begin]`
    
- 直接 `res.push_back(path)` 结果方向不对
    

**正确做法：**

- 终止时反转：
    

```cpp
vector<string> tmp = path;
reverse(tmp.begin(), tmp.end());
res.push_back(tmp);
```

---

#### 错误 6：BFS 中没有跳过 “替换成原字符”

**表现：**

- 生成邻居时可能得到 `w == word`
    
- 这会造成把自己当邻居，影响 visited/parent
    

**正确做法：**

```cpp
if (c == old) continue;
```

---

### 4. 我最终 AC 的 126 标准范式（可当模板背下来）

### 阶段 A：BFS（只建 parent 图）

- 输入：begin, end, dict
    
- 输出：`parent` + 是否 found（最短层到达 end）
    

关键点：

1. 每轮 while 是一层
    
2. `visited_level` 记录本层入队过的 next
    
3. `parent[next].push_back(cur)` 不去重（允许多个父）
    
4. 一旦 found，**当前层仍要跑完**，但不再进入下一层
    

### 阶段 B：DFS 回溯（枚举所有最短路径）

- 从 `endWord` 递归走 `parent[end]`
    
- 走到 `beginWord` 时反转入答案
    

---

## 5. 一句话记忆法

- **127：BFS 最短距离，入队即 visited（erase）**
    
- **126：BFS 建 parent（多父），层末 erase；DFS 从 end 回溯输出**
    

---

## 6. 我个人最容易再犯的点（自查清单）

-  BFS 队列是否 push 了 beginWord？
    
-  126 是否使用 `visited_level`（同层去重）？
    
-  126 是否层末 `erase(visited_level)`？
    
-  parent 的方向是否是 `child -> parents`？
    
-  DFS 是否从 endWord 开始？
    
-  到 beginWord 时是否 reverse 后加入 res？
    
-  替换字符时是否跳过原字符？
