---
Author: Spa-Master
日期: 2026年1月17日
tags:
- cpp
- segment-tree
title: 线段树
---

## 1. 核心概念

线段树是一种基于**分治思想**的二叉树结构，主要用于解决数组的**区间查询**和**单点/区间修改**问题。

- **本质**：将数组不断二分，每一个节点代表一个区间 `[start, end]`。
    
- **时间复杂度**：
    
    - 建树 (Build): $O(N)$
        
    - 单点修改 (Update): $O(\log N)$
        
    - 区间查询 (Query): $O(\log N)$
        
- **空间复杂度**：$O(4N)$ (需要开 4 倍数组空间以防越界)。
    

## 2. 存储方式 (数组模拟)

通常不使用指针建树，而是使用数组模拟堆结构。

假设根节点下标为 1 (根节点不能是0，否则乘法计算子节点会出错)：

- **父节点**：`node`
    
- **左孩子**：`2 * node` (或 `node << 1`)
    
- **右孩子**：`2 * node + 1` (或 `node << 1 | 1`)
    
- **中点**：`mid = start + (end - start) / 2`
    

## 3. 核心操作模板

### 3.1 节点定义 (Node Struct)

对于简单求和，只存 `val` 即可。对于复杂题 (如 LC 3165)，需要维护状态机。

C++

```
struct Node {
    long long val; 
    // LC 3165 特例：维护 l00, l01, l10, l11 四个状态
};
vector<Node> tree;
```

### 3.2 向上合并 (PushUp) - **最重要的函数**

线段树的灵魂。决定了父节点如何通过两个子节点计算出自己的值。

- **求和**：`tree[node] = left + right`
    
- **最大值**：`tree[node] = max(left, right)`
    
- **复杂合并 (LC 3165)**：也就是 DP 的状态转移过程。
    

C++

```
Node pushUp(const Node& l, const Node& r) {
    Node res;
    // 逻辑：父区间的状态 = max(左子区间组合 + 右子区间组合)
    // 关键点：注意连接处是否冲突
    return res;
}
```

### 3.3 建树 (Build)

自底向上构建。递归到叶子节点初始化，然后回溯 `pushUp`。

```c++
void build(int node, int start, int end, const vector<int>& nums) {
    if (start == end) {
		max(0LL, (long long)nums[start])
        return;
    }
    int mid = start + (end - start) / 2;
    build(node * 2, start, mid, nums);
    build(node * 2 + 1, mid + 1, end, nums);
    tree[node] = pushUp(tree[node * 2], tree[node * 2 + 1]);
}
```

### 3.4 单点更新 (Update)

类似二分查找，找到目标叶子并修改，**回溯时刷新路径上的所有父节点**。

```c++
    void update(int node, const vector<int> & nums, int start, int end, int idx){
        if(start == end){
            tree[node].l11 = max(nums[idx], 0);
            return;
        }
        int mid = start + (end - start) / 2;
        if(idx <= mid){
            update(node * 2, nums, start, mid, idx);
        } else {
            update(node * 2 + 1, nums, mid + 1, end, idx);
        }
        tree[node] = pushUp(tree[node * 2], tree[node * 2 + 1]);
    }
```

---

## 4. 实战避坑指南 (Lessons Learned from LC 3165)

细节：

1. **数据类型陷阱**：
    
    - ❌ **错误**：`unsigned int`。一旦遇到负数，强转 `unsigned` 会变成巨大正数，导致结果错误。
        
    - ✅ **正确**：统一使用 `long long`。既能处理负数，又能防止累加溢出。
        
2. **返回结果**：
    
    - 树根通常存储在 `tree[1]`，不要去读 `tree[0]`。
        
    - 如果有取模需求，注意累加过程中每一步都要防止溢出。
        
3. **数组大小**：
    
    - 线段树数组必须开 `4 * N` 大小。
        

---

## 5. 经典题目清单

建议按顺序练习，巩固模板：

1. **基础模板题**：
    
    - [307. 区域和检索 - 数组可修改](https://leetcode.cn/problems/range-sum-query-mutable/) (单点修改 + 区间求和)
        
2. **进阶应用 (维护最大值)**：
    
    - [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/) (虽然是 DP 题，但可以用线段树做，维护 `maxSub`, `lMax`, `rMax`, `sum`)
        
3. **复杂状态合并 (Hard)**：
    
    - [3165. 不包含相邻元素的子序列的最大和](https://leetcode.cn/problems/maximum-sum-of-subsequence-with-non-adjacent-elements/) (即本题)
        
    - [2213. 由单个字符重复的最长子字符串](https://leetcode.cn/problems/longest-substring-of-one-repeating-character/) (维护字符前缀、后缀、最长连续长度)
