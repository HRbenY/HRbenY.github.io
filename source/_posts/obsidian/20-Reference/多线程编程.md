---
Author: Spa-Master
日期: 2026-01-23
tags:
- lang/cpp
- type/note
- type/snippet
title: 多线程编程
---

## 创建一个线程

使用C++11引入的thread头文件创建线程。
```c++
void thread_fun(int repeat, int threadId){
    while(repeat --){
        cout << "thread-" << threadId << endl;
    }
}//注意要先声明线程执行的函数

thread myThread0(thread_fun, 5, 0);
```
传参方式如代码中所示，`myThread0(thread_fun, 5, 0)`而不是`myThread0(thread_fun(5, 0))`

## 互斥锁

假如我们声明了两个线程，如下

```C++
thread myThread0(thread_fun, 5, 0);
thread myThread1(thread_fun, 5, 1);
cout << "我是主线程，我也在跑！" << endl;
myThread0.join();
myThread1.join();
```

由于调用的`cout`是一个共享资源，主线程和两个子线程都往里塞字，多线程的输出会出现穿插现象。如下：

```txt
我是主线程，我也在跑！
thread-thread-0
thread-0
thread-0
thread-0
thread-0
1
thread-1
thread-1
thread-1
thread-1
```

虽然 `cout` 本身是线程安全的（不会崩溃），但 `<<` 操作符是分步执行的。`cout << "thread-" << threadId << endl;` 实际上被拆成了三次操作：输出字符串、输出ID、输出换行。线程A刚输出完 "thread-"，还没来得及输出 ID，就被线程B插队了。

要避免线程冲突（这也是多线程编程中最重要的议题），我们需要引入互斥锁Mutex。

具体的流程是定义一个全局互斥锁，再在线程函数中定义一个`lock_guard`管理互斥锁。`lock_guard`作用范围用大括号括起来，便于自动析构释放资源。

>[!note]
>`lock_guard`是为了替代手动`lock()`和`unlock()`。手动操作如果在解锁之前程序抛出异常，或者提前return，则线程占用的资源将永远无法解锁，后续的线程都会卡住，造成**死锁**现象

使用互斥锁后的代码如下：

```c++
mutex mtx;//定义全局线程锁
void thread_fun(int repeat, int threadId){
    while(repeat --){
        lock_guard<mutex> guard(mtx);//定义lock_guard管理线程锁
        cout << "thread-" << threadId << endl;
    }
}
int main(){
    thread myThread0(thread_fun, 5, 0);
    thread myThread1(thread_fun, 5, 1);
    {
        std::lock_guard<std::mutex> guard(mtx);//定义lock_guard管理线程
										       //锁，并使用大括号限定作用
										       //域便于自动析构
        cout << "我是主线程，我也在跑！" << endl;
    }
    myThread0.join();
    myThread1.join();
    return 0;
}
```


## `lock_guard`和`unique_guard`

在上一节配合互斥锁我们使用了lock_guard，这是一个互斥锁管理器。但是lock_guard有一些缺点，如下：

| **特性**             | **std::lock_guard** | **std::unique_lock** |
| ------------------ | ------------------- | -------------------- |
| **速度**             | 极快（零开销）             | 微慢（内部有个标志位）          |
| **RAII**           | 支持（出生锁，死亡解）         | 支持                   |
| **手动 Lock/Unlock** | ❌ 不行                | ✅ 可以                 |
| **中途想歇会**          | ❌ 必须锁到底             | ✅ 可以暂时 unlock        |
| **Try Lock (非阻塞)** | ❌ 只能死等              | ✅ 可以尝试锁              |
| **条件变量 (Wait)**    | ❌ 无法配合              | ✅ **必须用它**           |
| **作为返回值**          | ❌ 不行                | ✅ 可以                 |
### 暂时解锁

```c++
void heavy_work() {
std::unique_lock<std::mutex> lock(mtx);
do_something();//处理一些数据
lock.unlock(); // 手动解锁 （此时其他线程可以抢锁干活了） 
std::this_thread::sleep_for(std::chrono::seconds(2));
lock.lock(); // 手动上锁 
do_something();//处理一些数据
}//析构
```

如上，`unique_lock`支持暂时解锁。

### Try Lock

`try_lock()`是`unique_lock`的一个成员函数，返回`unique_lock`管理的`Motex`是否上锁，`bool`类型，是一种非阻塞的逻辑。如果没抢到锁当前线程可以执行else语句中的内容。`lock_guard`是阻塞逻辑，如果没有拿到锁就一直等待。

```c++
std::mutex mtx;
void try() {
    // std::defer_lock 的意思是：
    // "我就建个名叫 lock 的对象，先别急着去锁 mtx，我自己手动控制"
    std::unique_lock<std::mutex> lock(mtx, std::defer_lock);
    // 尝试锁一下（非阻塞）
    if (lock.try_lock()) {
        std::cout << "抢到锁了！" << std::endl;
        // 离开函数时，lock 会自动帮你 unlock，不用手动写
    } else {
        std::cout << "没抢到，我去干别的了。" << std::endl;
    }
}
```

>[!caution]
>注意如果要使用`try_lock()`，定义`unique_lock`的时候一定要传入`defer_lock`

### 作为返回值（转移所有权）

最典型的场景是：**我想在一个函数里上锁，但是想在另一个函数里解锁。** 如果使用 `lock_guard`，这是做不到的。因为它那是“死锁扣”，出了函数就自动弹开了。 只有 `unique_lock` 可以像接力棒一样传递。

```c++
std::unique_lock<std::mutex> get_protected_resource() { std::unique_lock<std::mutex> my_lock(mtx);//在这里上锁
return my_lock;//这里的 return 实际上发生了“移动语义 (Move)”，
			   //把所有权移交给了调用者 return my_lock; 
}
```

除了返回值传递，还有一种场景是在两个变量之间传递，使用`std::move`。
```c++
std::unique_lock<std::mutex> lock1(mtx); 
std::unique_lock<std::mutex> lock2 = std::move(lock1);
```

>[!caution]
>注意`std::unique_lock<std::mutex> lock2 = lock1;`是错误的，锁不能分身，所以禁止复制。

## 条件变量

假如一个老板雇佣了一个保安专门给老板开门，这个保安非常的愚蠢，每时每刻都要死死盯着大门看老板来了没有。保安的代码可能是这样的

```c++
void stupid_guard(){
while (boss_is_comming == false){
//do nothing
}
open_gate();
}
```

很显然这个线程一直没闲着，即使老板很久都可能不来，保安也会一直执行检查。在计算机中会导致CPU占用率居高不下，空耗算力。

一个更高明的机制是设置一个提醒机制，当老板来了之后Notify一下保安，执行开门。这就是条件变量的作用。

应用条件变量的场景底层就是这个生产者消费者场景。如下

```c++
std::mutex mtx;
std::condition_variable cv;
bool ready = false; // 具体的条件数据

void worker() {
    std::unique_lock<std::mutex> lock(mtx);
    while (!ready) {
        // 进入等待：解锁 -> 睡觉 -> (被唤醒) -> 抢锁
        cv.wait(lock); 
    }
    std::cout << "保安：老板来了，开门！" << std::endl;
}

void boss() {
    {
        std::lock_guard<std::mutex> lock(mtx);
        ready = true;
        std::cout << "老板：我到了。" << std::endl;
    } // 释放锁（最好在 notify 之前释放）

    cv.notify_one();//唤醒一个正在 wait 的线程
}
```

> [!note]
> 当保安执行`cv.wait(lock)`时，底层实际上发生了这三个连贯动作：
> 1. Unlock: 把锁解开，不然老板抢不到锁
> 2. Sleep: 进入休眠，不占用CPU
> 3. Lock: 被唤醒后立即尝试抢锁，只有抢到了才会从wait函数中退出
> 
> 由于中间需要[暂时解锁](#暂时解锁)，所以这里必须用`unique_lock`，而不是`lock_guard`。这也是`unique_lock`可以配合条件变量使用的原因。

> [!caution]
> 注意保安的代码中必须使用while，只有ready被置true才能退出循环，避免假唤醒。

上述代码是条件变量的一个常用模板。描述了**线程 A 等待某个条件成立，线程 B 改变这个条件并通知 A。** 基本上所有的多线程写作归根结底就是在讲这一件事。
