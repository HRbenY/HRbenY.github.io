---
Author: Spa-Master
日期: 2026年1月17日
tags:
- lang/cpp
title: 二叉树
slug: 二叉树
---

### 前中后序遍历
[前序](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)  
[中序](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)  
[后序](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)

#### 递归写法
递归写法的话，只有Traversal函数中的顺序不同。

```c++
res.push_back(cur->val);
Traversal (cur->left, res);
Traversal (cur->right, res);
```

这是前序的写法，是什么序就把push操作放在哪个位置。

```c++
void traversal(vector<string> &res, string path, TreeNode* Node){
    path += to_string(Node->val);
    if((Node->left == nullptr) && (Node->right == nullptr)){
        res.push_back(path);
    }
    if(Node->left){
        traversal(res, path + "->", Node->left);
    }
    if(Node->right){
        traversal(res, path + "->", Node->right);
    }
}
```

题257的简化递归写法，有两个细节：
* ``traversal``函数接收的``path``输入不带``&``，说明每次调用时都会创建一个新的``path``副本，事实上实现了``path``的回溯操作。因为当前traversal函数执行完毕回到上一层后path也回到上一层的值了。
* 调用``traversal``函数时``path + "->"``作为一整个参数传入。也是为了``path``的回溯，这样执行结束之后不影响上一层循环的``path``值。


> **递归三要素**  
> **1.确定递归函数的参数和返回值**： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
> 
> **2.确定终止条件**： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
> 
> **3.确定单层递归的逻辑**： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。
>

#### 迭代写法

普通的迭代写法三种都不一样，不过前序和后序写法比较类似。中序的普通迭代法比较难写出来。因为对于中序遍历来说，访问到了某一个节点并不一定要立刻处理，而是要先处理其所有左子树。所以需要一个标识来表示某节点的左子树全部处理完成了。这里用空指针表示下一个节点处理完成可以Push_back到结果数组中。  
空指针表示的迭代法对于前中后三种遍历方式的形式都是很相似的，所以称为统一迭代法。  

* **中序**
```c++
while(!st.empty()){
    cur = st.top();
    if (cur != nullptr){
        st.pop();
        if(cur->right)st.push(cur->right);
        st.push(cur);
        st.push(nullptr);
        if(cur->left)st.push(cur->left);
    }
    else{
        st.pop();
        res.push_back(st.top()->val);
        st.pop();
    }
}
```

上面是中序遍历的统一迭代法。要注意的是，叶子节点也是左子树全部处理完毕的节点，所以逻辑可以整合到一起。整个代码运行过程就像：如果当前节点不是空节点，就按照右中null左的顺序重新入栈。一旦访问到空指针，说明下一个节点处理完成，可以存入数组中。前序、中序和后序只在if中的语句顺序不同。

* **前序**
```c++
if(cur != nullptr){
    st.pop();
    if(cur->right)st.push(cur->right);
    if(cur->left)st.push(cur->left);
    st.push(cur);
    st.push(nullptr);
}
```

* **后序**
```c++
if(cur != nullptr){
    //st.pop();
    //st.push(cur);这两行抵消了。
    st.push(nullptr);
    if(cur->right)st.push(cur->right);
    if(cur->left)st.push(cur->left);
}
```

### 层序遍历

[102.二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)
[107.二叉树的层序遍历II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/)
[199.二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/description/)
[637.二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/)

层序遍历，即从上往下一层一层遍历。适合使用队列。具体操作是在对新的一层进行遍历之前，存储queue大小size，代表这层的节点数量。然后把这size个节点分别求左右孩子，插入到队列尾部。遍历完成后当前的queue就变成了下一层的节点了。

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        if (root == nullptr)
            return result;
        queue<TreeNode*> que;
        que.push(root);
        while (!que.empty()) {
            vector<int> row;
            int size = que.size();
            for (int i = 0; i < size; i++) {
                row.push_back(que.front()->val);
                if (que.front()->left)
                    que.push(que.front()->left);
                if (que.front()->right)
                    que.push(que.front()->right);
                que.pop();
            }
            result.push_back(row);
        }
        return result;
    }
};
```

### 101.对称二叉树

[原题链接](https://leetcode.cn/problems/symmetric-tree/description/)

不难发现，一颗二叉树为对称二叉树的判断条件是根节点的左右子树对称，而左右子树对称的判断条件是左子树的左子树与右子树的右子树对称，左子树的右子树与右子树的左子树对称。于是就发现了递归点：在想判断二叉树的对称条件时，与其子树的对称条件有关系。

### 222.完全二叉树的节点个数

[原题链接](https://leetcode.cn/problems/count-complete-tree-nodes/description/)

跟[对称二叉树](#101对称二叉树)一样，因为当前节点作为根的二叉树的节点个数与左右孩子的二叉树的节点个数有关，所以可以使用递归。  
层序遍历也可以。

### 110.平衡二叉树

[原题链接](https://leetcode.cn/problems/balanced-binary-tree/description/)

这里聊一下二叉树的高度和深度。leetcode和wiki并未达成共识，我们按照leet的标准，叶子节点的高度为1，根节点的高度取左右子树计算得高度的较大值。比如这里左侧2节点的高度应为3。计算高度时，因为遍历到当前节点时并不知道下面还有多少节点，所以适合采用后序遍历，从下往上计数。计算深度则前序或层序遍历，从上往下就行。
![平衡二叉树](https://cdn.jsdelivr.net/gh/HRbenY/blog-assets@master//img/20260117145547528.png)

### 257.二叉树的所有路径

[原题链接](https://leetcode.cn/problems/binary-tree-paths/description/)

初次接触回溯算法。

```c++
void traversal(vector<string> &result, vector<TreeNode*> &path, TreeNode* cur){
        path.push_back(cur);
        if((cur->left == nullptr) && (cur->right == nullptr)){
            string res;
            for(const auto & Node : path){
                res += to_string(Node->val);
                res += "->";
            }
            res.resize(res.size() - 2);
            result.push_back(res);
            return;
        }
        else{
            if(cur->left){
                traversal(result, path, cur->left);
                path.pop_back();
                
            }
            if(cur->right){
                traversal(result, path, cur->right);
                path.pop_back();
            }
        }

    }
```

### 617.合并二叉树

[原题链接](https://leetcode.cn/problems/merge-two-binary-trees/description/)

这几道题的递归方式都比较像。都是当前节点为空作为结束条件，递归体现在当前节点的左右孩子调用递归函数。

第一次写完这题报了个错，下面这两行

```c++
node->left = mt(root1->left, root2->left);
node->right = mt(root1->right, root2->right);
```

由于传入的root1和root2可能是空指针，这里可能出现访问空指针的错误。后来采用if分了三种情况。root1和root2有一个nullptr时，直接把另一个加入合并树就可以不用管了。

### 700.二叉搜索树中的搜索

[原题链接](https://leetcode.cn/problems/search-in-a-binary-search-tree/description/)

由于题目是二叉搜索树，而二叉搜索树有个特性是root的左孩子更小，右孩子更大。据此可以很简单地写出迭代逻辑。

```c++
if(cur->val > val)cur = cur->left;
else if(cur->val < val)cur = cur->right;
else return cur;
```

要注意，当当前节点``cur->val``比目标值大时要往左走。这里我写反过。

### 701. 二叉搜索树中的插入操作

[原题链接](https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/)

```c++
if(val > root->val)root->right = insertIntoBS(root->right, val);
if(val < root->val)root->left = insertIntoBS(root->left, val);
```

用了一个比较巧妙的方法，用递归函数返回值完成新加入节点的父子关系复制操作。**下一层将加入节点返回，本层用root->left或者root->right将其接住。**


### 405. 二叉搜索树的删除操作

[原题链接](https://leetcode.cn/problems/delete-node-in-a-bst/description/)

与上题类似，也可以用递归函数返回值处理。   
搜索树的删除操作，难点在当前节点左右子树都不为空的情况下。可以把左子树直接接到右子树最左节点的左边。这样跟原来的树是等价的，就把条件转换成了只有右子树的情况。

### 669. 修建二叉搜索树

[原题链接](https://leetcode.cn/problems/trim-a-binary-search-tree/description/)

简单的迭代，考虑清楚当前节点在范围外的情形就行。

今后注意如果使用迭代法，务必记住除了当前节点不存在可以返回``nullptr``，其他情况要谨慎``return``明确的值（比如``return root->left``）,大部分情况下都要``return(trimBST(root->left, low, high))`` 这样的迭代形式。

### 108.将有序数组转换为二叉搜索树

[原题链接](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/)

取中点作为新的根，其左孩子为vector左侧的中点，右孩子作为vector右侧的中点，递归就可以了。这里有几点语法要注意。

```c++
template <typename it>
TreeNode* sa2BST(it begin, it end){
    if(begin == end)return nullptr;
    it mid = begin + distance(begin, end)/2;
    TreeNode* Node = new TreeNode(*mid);
    Node->left = sa2BST(begin, mid);
    Node->right = sa2BST(mid + 1, end);
    return Node;
}
```

* 模版声明``template <typename it>``。  
如果不用模版声明，这个``sa2BST``函数的传入参数需要指定``iterator``的类型，比如``std::vector<int>``使得sa2BST无法接受其他的比如``std::vector<double>::iterator``的输入。比较死板。加上模版声明实际上是定义了一个类型占位符，名称叫``it``，意味着``sa2BST``函数实际上需要两个``it``类型的输入。当调用``sa2BST``的时候，编译器会自动将模版中定义的占位符``it``全部替换成具体的类型(这里是``std::vector<int>::iterator``)。使得函数可以兼容不同的`iterator`。
* 迭代器操作。  
要记住，迭代器本质上还是指针，访问值的时候需要解引用(*mid)。
