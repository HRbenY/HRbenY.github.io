---
Author: Spa-Master
日期: 2026年1月17日
tags:
- lang/cpp
title: 链表
slug: 链表
---

# 链表

链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。

链表的入口节点称为链表的头结点也就是head。

![链表结构](https://cdn.jsdelivr.net/gh/HRbenY/blog-assets@master//img/20260117145443363.png)

在此基础上，每个节点新增一个指针域，一个指向下一个节点，一个指向上一个节点，就形成了双链表。

![双链表](https://cdn.jsdelivr.net/gh/HRbenY/blog-assets@master//img/20260117145443364.png)

将单链表首尾相连，就是循环链表

![循环链表](https://cdn.jsdelivr.net/gh/HRbenY/blog-assets@master//img/20260117145443365.png)

## 链表的操作

### 定义

```c++
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode* next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
```

``ListNode(int x)``函数的名字与结构名完全相同，这告诉编译器他是一个构造函数。``(int x)``是传参列表

``val(x)`` ``next(NULL)``是初始化列表，C++独特的初始化成员变量的方式。这种赋值方式发生在函数体``{}``(这里为空)执行之前。

注意结构定义后要加分号。

值得注意的是，如果不定义构造函数，会生成一个默认构造函数，但是在初始化的时候不能给变量赋值。

### 调用

```c++
ListNode* node0 = new ListNode(10);
```

``ListNode* node0``创建了一个指向ListNode类型的指针node0；  
``new ListNode(10)``使用``new``关键字在内存中创建了一个ListNode节点，并使用构造函数赋值为10；  
``=``号将新创建的链表节点地址赋值给了node0。

实际上，创建指针和创建节点可以分开来做：
```c++
ListNode* node0 = NULL;
node0 = new ListNode(10);
```

当像这样分开写时，通常是因为在声明指针时，还不知道它要指向哪个对象。

* `ListNode* head;`: 这行代码只是在**栈区**（stack）声明了一个名为 `head` 的指针变量。此时，`head` 还没有被初始化，它里面存储的是一个不确定的、随机的内存地址（俗称“野指针”）。
* `head = new ListNode(10);`: 这行代码是在后续的某个时刻，才去动态地创建 `ListNode` 对象，并将它的地址赋给 `head`。

## leetcode

### 203. 移除链表元素

[原题链接](https://leetcode.cn/problems/remove-linked-list-elements/description/)

两种方法，把头节点单独分析或创建一个虚拟头节点，剩下的所有节点都用同一个逻辑。

#### 直接判断
```c++
while (head != NULL && head->val == val){
    ListNode* tmp = head;
    head = head->next;
    delete tmp;
}
```

一般都要在操作之前判断当前节点是否为空，保证有意义。

```c++
ListNode* cur = head; 
while(cur != NULL && cur->next != NULL){ 
    if (cur->next->val == val) { 
        ListNode* tmp = cur->next;
        cur->next = cur->next->next;
        delete tmp;
    } else {
        cur = cur->next;
    }
}
```

``ListNode* cur = head``创建了一个指向当前操作节点的指针。  
``if (cur->next->val == val)``注意这里是判断``cur->next``节点的值，因为对于单链表来说无法回溯到上一个节点，如果直接判断当前节点的值的话就不好更改上一个节点的指向了。

#### 虚拟头节点

```c++
ListNode* DummyNode = new ListNode(0);
DummyNode->next = head;
```

创建虚拟头节点``DummyNode``，next指向给定链表的实际头节点。这样整个链表都可以用同一个逻辑处理了。

### 707. 设计链表

题目要求实现的函数全部封装在一个class内。
```c++
MyLinkedList *obj = new MyLinkedList();
obj->deleteAtIndex(0);

delete obj;
obj = nullptr;
```

调用时使用``MyLinkedList *obj = new MyLinkedList()``是为了控制对象的生命周期。用指针形式使当前函数结束，这个对象也不会自动销毁，直到被手动释放。

创建``obj``对象后使用``->``访问其成员函数。  

obj使用完成后要完成两步删除，一是删除obj指向对象对应的内存空间，二是清除obj指针自身。因为delete不会清除指针本身。**为了避免悬空指针问题最好在指针不用之后手动delete并置nullptr**。

> 关于``->``和``.``操作符，前者用于通过指针操作一个对象，等效于``(*pointer).member``，即先解指针，得到它指向的对象，再用点操作符访问其成员。后者用于直接访问对象实例的成员。
> 
> 在C++中，对象实例存放在栈上，指向对象的指针存放在堆上

```c++
while (index--)
{
    cur = cur->next;
}
```
输入index，查询对应序号的节点。常将index--作为while循环的条件，循环次数是index次。

注意，``cur = cur->next;``不要写成``cur->next=cur->next->next``了，看似差不多，其实后者相当于删除了``cur->next``。

```c++
private:
    int _size; // 这里先不初始化
    ListNode *_DummyNode;
```

由于各成员函数都需要访问和修改链表大小和虚拟头节点这两个变量，将它们设为私有，是为了确保只有这些被授权的成员函数才能安全地修改它们。

### 206. 翻转链表

```c++
ListNode* cur = head;
ListNode* pre = NULL;
ListNode* tmp;
```

这里注意不要直接把pre赋值为cur了，不然后续会出现死循环。

### 24. 两两交换链表中的节点

[原题链接](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)

没什么好说的，注意在对节点操作的时候仔细一点。画个图一步一步走一下逻辑。

### 19.删除链表的倒数第N个结点

[原题链接](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)

双指针法，因为要倒数第N个节点，正常想法是先遍历一遍找一共M个点，再遍历M-N次找到倒数第N个。这样的流程都可以简化到一个循环中，快指针先走N次，再同步前进。

```c++
while(Fastptr->next != nullptr){
    Fastptr = Fastptr->next;
    if (n == 0)
    {
        Slowptr = Slowptr->next;
    }
    else
    {
        n--;
    }
}
```

### 面试题02.07 链表相交

[原题链接](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/submissions/662678653/)

提一个我到现在都写错了的地方。
```c++
while (curA ->next != NULL){
    curA = curA ->next;
    sizeA ++;
}
```

这里``while``的条件应该是``curA != NULL``。我之前担心如果不检查``cur->next``是否为空，会导致循环内``curA = curA ->next``报错。但其实**指针被赋值为NULL并不会报错**，这样当前指针就是空指针。**真正会报错的是对空指针进行解指针的过程**，即在``cur=nullptr``的情况下索引``cur->next``。此外，由于我们的``curA``指针是从``DummyHead``开始的，如果这里直接改成``while (curA != NULL)``会导致``curA``最后停留在最后一个节点之后，算出来的``sizeA``比正确值大一。可行做法是在初始化的时候``curA = DummyHead->next``

### 142. 环形链表

[原题链接](https://leetcode.cn/problems/linked-list-cycle-ii/description/)

快慢指针法，快指针每次走两步，慢指针每次走一步。当慢指针追上快指针则说明有环。由于快慢指针相对速度总是一，所以如果有环则一定可以追上，且快指针总比慢指针多走**环剩下长度+n*环总长度**。此时在起点和快慢指针交汇处分别设置一个指针，每次走一步，则新设指针交汇点一定是环入口。证明如下：

> 设起点到环入口为 $l$,快慢指针交汇于距离环入口$x$处，记为点A，环剩下的长度为 $y$，环总长 $z=x+y$。由于快慢指针速度关系，有
> 
> $$
> 
>     2(x+l) - (x+l) = n(x+y)\\
> 
>     l=n(x+y)-x\\
> 
>     l=(n-1)(x+y)+y
> 
> $$
> 
> 我们要求的就是这个 $l$，最后一个式子说明 $l$ 的距离相当于从A走到环入口，再绕 $(n-1)$ 圈。证明了新设的两个指针一定会在环入口交汇。

![总结](https://cdn.jsdelivr.net/gh/HRbenY/blog-assets@master//img/20260117145443366.png)
