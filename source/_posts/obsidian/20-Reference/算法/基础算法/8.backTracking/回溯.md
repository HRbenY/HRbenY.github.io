---
title: 回溯法
author: Spa-Master
date: '2026-01-17 00:00:00'
updated: '2026-01-17 00:00:00'
tags:
- lang/cpp
---

# 回溯法

回溯法，一般可以解决如下几种问题：

* 组合问题：N个数里面按一定规则找出k个数的集合
* 切割问题：一个字符串按一定规则有几种切割方式
* 子集问题：一个N个数的集合里有多少符合条件的子集
* 排列问题：N个数按一定规则全排列，有几种排列方式
* 棋盘问题：N皇后，解数独等等

**回溯法解决的问题都可以抽象为树形结构**，是的，所有回溯法的问题都可以抽象为树形结构！

因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度就构成了树的深度。(见[77](image.png))

回溯跟递归是不分家的，回溯也有传入参数和返回值、终止条件、每层逻辑三要素。通用模版如下：

```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```
通常回溯法需要遍历所有可能性，因此返回参数一般为void。

### 77.组合

[原题链接](https://leetcode.cn/problems/combinations/description/)

![77](https://cdn.jsdelivr.net/gh/HRbenY/blog-assets@master//img/20260117145556494.png)

for循环是在每层内横向遍历，递归调用则是纵向遍历。第一层可以从所有的数字中选取一个，用for循环选取。在for循环中调用自身进行递归，在选取了一个数字的条件下进行深入遍历，这样在递归中的另外一层for循环就选好了第二个数字。  
由于组合是没有顺序的，第一层选过某一个数字之后不再取，所以还需要传入startIndex参数来控制for循环的起始位置。   
这样基本的逻辑就完成了。进一步进行剪枝，当当前循环剩下数字的个数小于需要的个数的时候，可以立马判断没有符合条件的组合，直接退出for循环。如下：
* 当前已选：`path.size()` 
* 还需选:`k - path.size()`
* 剩下的数字个数:`n - i + 1`  
所以有`n - i + 1 >=  k - path.size()`  
代码如下：

```c++
vector<vector<int>> result;
vector<int> path;
private:
    void backtracking(int n, int k, int startIndex){
        if(path.size() == k){
            result.push_back(path);
            return;
        }
        for(int i = startIndex; i <= n + path.size() - k + 1; i ++){
            path.push_back(i);
            backtracking(n, k, i + 1);
            path.pop_back();
        }
    }
```

### 17.电话号码的字母组合

[原题链接](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/)

本题for循环的用途是遍历一个数字所对应的所有字母，递归则是在遍历所有数字。回溯的是数字的编号。关键代码如下：
```c++
const unordered_map<int, string> digitsMap = {
    {0, ""},    {1, ""},    {2, "abc"},  {3, "def"}, {4, "ghi"},
    {5, "jkl"}, {6, "mno"}, {7, "pqrs"}, {8, "tuv"}, {9, "wxyz"},
};
vector<string> result;
string str;

private:
    void backTracking(int Index, const string &digits) {
        if (Index == digits.size()) {
            result.push_back(str);
            return;
        }
        string tmp = digitsMap.at(int(digits.at(Index) - '0'));
        for (int i = 0; i < tmp.size(); i++) {
            str.push_back(tmp[i]);
            backTracking(Index + 1, digits);
            str.pop_back();
        }
    }
```
由于要存储每个数字对应的字母，这里使用哈希表存储键值对。回溯函数接受Index表示当前是第Index个数字，和digits表示接受的用户输入。

### 40.组合总和II

[原题链接](https://leetcode.cn/problems/combination-sum-ii/description/)

这题的难点在于要做去重操作。由于candidate中可能有重复的元素，因此在每个for循环中都需要去除重复的情况。为了方便判断，首先要对candidate进行排序。再判断相邻元素的相等情况。具体代码如下：

```c++
void backTracking(const vector<int>& candidates, int target, int startIndex){
        if(target == 0){
            result.push_back(path);
            return;
        }
        if(target < 0)return;
        for (int i = startIndex; i < candidates.size(); i++){
            if (i > startIndex && candidates[i] == candidates[i - 1])continue;
            path.push_back(candidates.at(i));
            backTracking(candidates, target - candidates.at(i), i + 1);
            path.pop_back();
        }
    }
```

首先，由于元素不能重复选取，递归调用中`backTracking(candidates, target - candidates.at(i), i + 1);`中startIndex要+1。  

然后进行每层的去重。注意这里的逻辑是`if (i > startIndex && candidates[i] == candidates[i - 1])continue;`除了判断当前的编号`candidate[i]`和前一个遍历的编号`candidate[i-1]`相等以外，还要**确保前一个`candidate`是本层遍历过的**。比如1 1 2，取两个元素，第一层1，第二层1。第二层的1跟上个数字`candidate[i-1]`相等，但是上一个1是上一层遍历的，本层根本不会遍历到他。使用`i > startIndex`确保从本层第二个元素开始判断去重。

### 131.分割回文串

[原题链接](https://leetcode.cn/problems/palindrome-partitioning/description/)

还需要写一个判断是否回文的函数。这个函数最好能接受字符串和起止点输入。方便循环中切割子字符串后判断。具体代码如下：

```c++
private:
    bool isPalindrome(const string &s, int start, int end){
        for(int i = start, j = end; i < j; i ++, j --){
            if(s[i] != s[j])return false;
        }
        return true;
    }
    vector<vector<string>> result;
    vector<string> vec;
    void backTracking(string &s, int startIndex){
        if (startIndex == s.size()){
            result.push_back(vec);
            return;
        }
        for(int i = startIndex; i < s.size(); i ++){
            if(isPalindrome(s, startIndex, i)){
                vec.push_back(s.substr(startIndex, i - startIndex + 1));//注意细节
                backTracking(s, i + 1);
                vec.pop_back();
            }
            else continue;
        }
    }
```
与之前不同的是，只有当当前层切出一个回文串才能进入递归，判断下一层。否则接着continue，继续延长。

### 93.复原ip地址

[原题链接](https://leetcode.cn/problems/restore-ip-addresses/description/)

```c++
vector<string> result;
    vector<string> path;
    bool isValid(const string &s, int start, int end){
        if (end - start > 2) return false;
        if (stoi(s.substr(start, end - start + 1)) > 255)return false;//注意要先验证子串长度，以免溢出INT_MAX
        if (end > start && s[start] == '0')return false;//注意是'0'
        return true;
    }
    void backTracking(const string &s, int startIndex){
        if(path.size() == 4){
            if(startIndex == s.size()){
                string ip = path[0] + '.' + path[1] + '.' + path[2] + '.' + path[3];
                result.push_back(ip);
            }
            return;
        }
        for (int i = startIndex; i < s.size(); i ++){
            if(isValid(s, startIndex, i)){
                path.push_back(s.substr(startIndex, i - startIndex + 1));
                backTracking(s, i + 1);
                path.pop_back();
            }
        }
    }
```

这题我犯了很多小错误，总结列举出来。

* 在 `backTracking` 函数的递归调用中，使用了 `backTracking(s, startIndex + 1)`。`startIndex` 代表当前选择的起点，而 `i` 代表当前选择的终点。当一段 `[startIndex, i]` 被选定后，下一段的选择应该从 `i + 1` 开始，而不是 `startIndex + 1` 
* 最初我定义了一个nums来存储当前分出了几个数字。其实用path.size()就可以了。
* 在 isValid 函数中，写了 `s[start] == 0` 来判断前导零。这里`s[start]`是char类型，所以要判断 `s[start] == ‘0’ `这是一个非常容易搞错的点，一定要注意，**字符类型的数字判断大小也要和字符类型比较。**
* 在`stoi`调用中,`if (stoi(s.substr(start, end - start + 1)) > 255)`可能会出现转换之后的大小超过int存储范围。所以这里要先判断转换后的位数是不是在三位以内。

### 78.子集

[原题链接](https://leetcode.cn/problems/subsets/description/)

```c++
private:
    vector<vector<int>> result;
    vector<int> path;

    void backTracking(vector<int>& nums, int startIndex) {
        result.push_back(path);
        if (startIndex == nums.size()) {
            return;
        }
        for (int i = startIndex; i < nums.size(); i++) {
            path.push_back(nums[i]);
            backTracking(nums, i + 1);
            path.pop_back();
        }
    }
```

非常经典的子集问题，可以与组合问题[77.组合](#77组合)相比较。

* 收集时机，子集在每个节点都收集结果，因为每次遍历都能得到新的合法子集。而组合只在叶子节点收集结果，因为组合问题必须要把所有元素全部分好才能输出一个结果。



### 491.非递减子序列

[原题链接](https://leetcode.cn/problems/non-decreasing-subsequences/description/)

这题坑很多，主要是三个问题。首先不能排序，其次要判断path是否递增，最后去重逻辑与之前的都不一样。代码图下：

```c++
private:
    vector<vector<int>> result;
    vector<int> path;
    void backTracking(vector<int> &nums, int startIndex){
        if(startIndex > nums.size())return;
        if(path.size() >= 2){
                result.push_back(path);
        }
        unordered_set<int> usedNums;
        for(int i = startIndex; i < nums.size(); i ++){
            if(!path.empty() && nums[i] < path.back())continue;
            if(usedNums.count(nums[i]))continue;
            path.push_back(nums[i]);
            usedNums.insert(nums[i]);
            backTracking(nums, i + 1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        result.clear();
        path.clear();
        backTracking(nums, 0);
        return result;
    }
};
```

* 为什么不能排序？题目要求的是整数数组的所有不同递增子序列，可能原数组是递减的，排序会破坏元素关系。
* 既然不能排序，那就要在函数里手动判断path是否是递增的。只有当下一个元素比path的末尾元素更大才加入到path中，并再次基础上进行递归。否则直接continue。
* 也是由于不能排序，去重逻辑跟之前的也不一样。像上面的[40.组合总和II](#40组合总和ii)或[90.子集II](https://leetcode.cn/problems/subsets-ii/description/)是可以先排序再通过相邻元素的大小关系去重的。这里只能通过哈希表去重。
  
### 46.全排列

[原题链接](https://leetcode.cn/problems/permutations/description/)

全排列问题，跟子集、子序列等的不同点在于全排列每层的for循环都要遍历剩下的所有元素，所以需要一个used数组来存储每个元素的选用状态。而子集和子序列由于其无序性，为了避免重复只允许向后选择。

简单来说，**used 数组是为了解决“元素可重用但不可复选”的问题，而 startIndex 是为了解决“元素不可重用且不可复选”的去重问题。**

了解了这点不同全排列的代码也比较好写了。如下

```c++
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backTracking(vector<int> &nums, vector<bool> used){
        if(path.size() == nums.size()){
            result.push_back(path);
            return;
        }
        for(int i = 0; i < nums.size(); i ++){
            if(used[i])continue;
            path.push_back(nums[i]);
            used[i] = true;
            backTracking(nums, used);
            path.pop_back();
            used[i] = false;
        }
    }
public:
    vector<vector<int>> permute(vector<int>& nums) {
        result.clear();
        path.clear();
        vector<bool> used(nums.size(), false);
        backTracking(nums, used);
        return result;
    }
};
```

### 47.全排列II

[原题链接](https://leetcode.cn/problems/permutations-ii/description/)

在[上一题](#46全排列)的基础上要求排列不能重复。所以在used标记的基础上加上去重逻辑，用unordered_set记录一层内已经选用过的值。

```c++
private:
    vector<vector<int>> result;
    vector<int> path;
    void backTracking(vector<int> &nums, vector<bool>used){
        if(path.size() == nums.size()){
            result.push_back(path);
            return;
        }
        unordered_set<int> uset;
        for(int i = 0; i < nums.size(); i ++){
            if(used[i])continue;
            if(uset.count(nums[i]))continue;
            path.push_back(nums[i]);
            used[i] = true;
            uset.insert(nums[i]);
            backTracking(nums, used);
            path.pop_back();
            used[i] = false;
        }
    }
```

### 332.重新安排行程

[原题链接](https://leetcode.cn/problems/reconstruct-itinerary/description/)

下面是我写的，效率太低了。整体思想是到达一个机场后，遍历所有机票找能用的。

```c++
class Solution {
private:
    vector<string> result;
    bool backTracking(vector<vector<string>>& tickets, vector<bool> &used){
        if(result.size() == tickets.size() + 1)return true;
        
        for (int i = 0; i < tickets.size(); i ++){
            if(used[i] || tickets[i][0] != result.back())continue;
            result.push_back(tickets[i][1]);
            used[i] = true;
            if(backTracking(tickets, used))return true;
            result.pop_back();
            used[i] = false;
        }

        return false;
    }
public:
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        result.clear();
        result.push_back("JFK");
        vector<bool> used(tickets.size(), false);
        sort(tickets.begin(), tickets.end());
        backTracking(tickets, used);
        return result;
    }
};
```

实际上应该在最开始建立机场之间的映射表。如下：

```c++
class Solution {
private:
    unordered_map<string, multiset<string>> map;
    vector<string> result;
    void backTracking(const string &cur){
        while(!map[cur].empty()){
            string next = *map[cur].begin();
            map[cur].erase(map[cur].begin());
            backTracking(next);
        }
        result.push_back(cur);
    }
public:
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        result.clear();
        map.clear();
        for(auto &i : tickets){
            map[i[0]].insert(i[1]);
        }
        backTracking("JFK");
        reverse(result.begin(), result.end());
        return(result);
    }
};
```

有些细节：
* 在销毁使用过的机票`map[cur].erase(map[cur].begin());`时，必须像这样销毁指定的**一张**机票。我错写成了`map[cur].erase(next);`,导致删除了所有跟next相等的机票，可能不止一张。
* 在传入常量时，即`backTracking("JFK");`必须保证函数接受的传入擦树也为常量，即要用`const`修饰。
* 在构建初始临接图时，用`map[i[0]].insert(i[1]);`而不是`map.insert({i[0],i[1]});`后者只适合`unordered_map<string, string>`的形式。

这题用到的算法涉及图论，使用Hierholzer算法计算欧拉路径。这种算法的回溯方式跟之前的都不一样。无论是集合还是排列，这些问题的回溯都是要撤销之前的处理。但是Hierholzer算法不需要。因为此算法是从后往前得到结果。当遍历到死胡同，把死胡同输出后，并不需要撤销删除上一节点到死胡同的路径。而且正因为这条路径的删除，将上一节点变成了新的死胡同。即使还有其他路径可以遍历，最终还是会回到这个节点，然后被作为新死胡同加入结果集中。重复这个过程。所以Hierholzer的回溯实际上体现在递归调用回溯函数时的return操作上，说明此层已遍历完所有机票，回到了上一节点。Hierholzer算法如下

> #### **Hierholzer 算法核心笔记** 
> ##### **1. 算法定义与目标** * **目标**: 寻找图中的**欧拉路径**（遍历每条边一次）或**欧拉回路**（起点和终点相同的欧拉路径）。  
> * **核心思想**: **逐步合并回路**。通过深度优先搜索（DFS），找到并消耗路径，直到终点，然后回溯拼接所有子回路。  
>
> ##### **2. 前提条件**  **无向图**:  
>    * **回路**: 图连通，所有顶点度数为偶数。  
>    * **路径**: 图连通，恰好有两个顶点度数为奇数。  
>* **有向图**:  
>    * **回路**: 图强连通，所有顶点的入度=出度。  
>    * **路径**: 图连通，一个顶点出度-入度=1（起点），一个顶点入度-出度=1（终点），其余顶点入度=出度。  
>
>##### **3. 算法流程 (DFS 实现)** 1.  **选择起点**：从指定的起点开始（路径）或任意节点（回路）。  
>2.  **循环探索**：在当前节点的函数中，使用 `while` 循环，条件为当前节点仍有未访问的出边。  
>3.  **前进与消耗**：  
>    * 在循环中，选择下一条边通往 `next` 节点。  
>    * **永久删除**这条边，表示已访问。  
>    * 对 `next` 节点进行递归调用 `dfs(next)`。  
>4.  **记录节点 (核心)**：当 `while` 循环结束（表示当前节点的所有出边都已被探索完毕），将**当前节点**添加到结果列表的末尾。  
>5.  **输出**：初始 `dfs` 调用结束后，将结果列表**反转**，即为最终的欧拉路径。  
>
>##### **4. 核心思想：“新死胡同”** * 算法的回溯是一种**任务完成**机制，而非状态恢复。  
>* 一个节点（例如 `P`）只有在**所有**从它出发的子路径都被完整探索后，它自身才成为一个“**新死胡同**”。  
>* 由于欧拉图的性质，任何从 `P` 出发的子路径都必然是一个闭合的回路，最终会返回到 `P`。  
>* `while` 循环确保了所有这些子回路都被消耗完毕。循环结束时，`P` 成为“新死胡同”，此时才可被记录到结果中。  
>
>##### **5. 力扣 332 题 (重新安排行程) 应用要点** * **问题映射**: 寻找从 "JFK" 出发的、按字典序最小的欧拉路径。  
>* **数据结构**: `unordered_map<string, multiset<string>>`  
>    * `unordered_map`: 按机场名快速索引。  
>    * `multiset`: 自动满足**字典序最小**的要求，并能处理**重复机票**。  
>* **边的消耗**: 必须使用基于**迭代器**的 `erase` 来精确删除**一张**机票。  
>    * **正确**: `map[cur].erase(map[cur].begin());`  
>    * **错误**: `map[cur].erase(next);` (这会删除所有目的地为 `next` 的机票)  
>* **最终代码结构**: `dfs` 函数实现上述算法流程，主函数调用 `dfs("JFK")` 后，对结果进行 `reverse`。


### 51.N皇后

[原题链接](https://leetcode.cn/problems/n-queens/description/)
细节很多，最需要考虑的是怎么表示两条斜线。右斜线上的坐标之差相等，左斜线上的坐标之和相等。比如一行二列放下一个皇后，坐标(1,2)，其右对角线为所有列-行=1的格子(比如2行3列，3行4列),右对角线为所有列+行=3的格子(比如2行1列)。这样可以再定义两个bool数组，分别表示两条斜线。当当前格子和差与其中一条相等时说明处于斜线上。有个细节，因为右对角线的值范围为[1-n, n-1]，代码中要加一个n-1的偏置来保证索引为正。代码如下：

```c++
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;

    void backTracking(int n, vector<bool> &used, vector<bool> &rban, vector<bool> &lban){
        if(path.size() == n){
            result.push_back(path);
            return;
        }
        for (int i = 0; i < n; i ++){
            if(used[i] || rban[path.size() - i + n - 1] || lban[path.size() + i])continue;

            used[i] = true;
            rban[path.size() - i + n - 1] = true;
            lban[path.size() + i] = true;
            path.push_back(i);//注意由于行数计算要用到path，这里在push之前的才是当前的行数。
            backTracking(n, used, rban, lban);
            path.pop_back();//同样的，pop之后才是正确的行数
            used[i] = false;
            rban[path.size() - i + n - 1] = false;
            lban[path.size() + i] = false;

        }
    }
public:
    vector<vector<string>> solveNQueens(int n) {
        result.clear();
        path.clear();
        vector<bool> used(n, false);
        vector<bool> rban(2 * n - 1, false);
        vector<bool> lban(2 * n - 1, false);
        backTracking(n, used, rban, lban);
        vector<vector<string>> res(result.size(), vector<string>(n));
        for(int i = 0; i < result.size(); i ++){
            for(int j = 0; j < n; j ++){
                for(int k = 0; k < n; k ++){
                    if(result[i][j] == k)res[i][j].push_back('Q');
                    else res[i][j].push_back('.');
                }

            }
        }
        return res;
    }
};
```

注意代码中的注释部分的细节。

### 37.解数独

[原题链接](https://leetcode.cn/problems/sudoku-solver/description/)

一开始用的三个哈希表分别存储行、列、九宫格使用的数字，可以AC但是耗时耗空间。Gemini教我一种bitmask方法，用一个数组九位数上的bit来表示这个格子有没有被选取。代码如下

```c++
class Solution {
private:
    short xbit[9];
    short ybit[9];
    short bbit[3][3];

    bool backTracking(vector<vector<char>>& board, int x, int y){
        int xNext, yNext;
        if (y == 9)return true;
        xNext = x + 1;
        yNext = y;
        if (x == 9){
            xNext = 0;
            yNext = y + 1;
        } 
        if(board[y][x] != '.')return backTracking(board, xNext, yNext);
        for (int i = 1; i <= 9; i ++){
            int mask = 1 << (i - 1);
            if(xbit[x] & mask || ybit[y] & mask || bbit[y/3][x/3] & mask)continue;//用&而非&&
            xbit[x] |= mask;
            ybit[y] |= mask;
            bbit[y/3][x/3] |= mask;
            board[y][x] = i + '0';
            if(backTracking(board, xNext, yNext))return true;
            xbit[x] ^= mask;
            ybit[y] ^= mask;
            bbit[y/3][x/3] ^= mask;
            board[y][x] = '.';
            
        }
        return false;
    }

public:
    void solveSudoku(vector<vector<char>>& board) {
        for (int i = 0; i < 9; i ++){
            xbit[i] = 0;
            ybit[i] = 0;
        }
        for (int i = 0; i < 3; i ++){
            for (int j = 0; j < 3; j ++){
                bbit[i][j] = 0;
            }
        }

        for (int y = 0; y < 9; y ++){
            for (int x = 0; x < 9; x ++){
                if(board[y][x] == '.')continue;
                int num = board[y][x] - '0';
                int mask = 1 << (num - 1);
                ybit[y] |= mask;
                xbit[x] |= mask;
                bbit[y/3][x/3] |= mask; 
            }
        }

        backTracking(board, 0, 0);

    }
};
```
首先是数组的预处理。`mask = 1 << (num - 1)`计算出了当前格子数字对应的掩码。比如当前数字为3，则mask=100。然后用位与操作将这个对应3的bit存入数组中。

在回溯函数中，注意注释的地方。这里用位操作判断数字是否重复，一定要用位与&，不要用&&。  
此外在数组的回溯过程中，注意代码用的异或。可以用一个例子感受一下。假设mask为100对应写入一个3。写完后数组变成101,那么要回溯的话直接找到mask和bit数组都为1的位就好了，把这位置零，就不难得出真值表了，正是异或的真值表。

我这里回溯函数接受的是格子的坐标，后序还可以优化成新建一个空格数组存放所有空格的坐标。
