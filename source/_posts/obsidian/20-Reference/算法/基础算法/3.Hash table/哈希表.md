---
Author: Spa-Master
日期: 2026年1月17日
tags:
- lang/cpp
title: 哈希表
---

# 哈希表

**什么时候使用哈希法？** 当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。

概述和初始化

  - std::unordered_map (哈希映射): 存储唯一的**键值对**（key-value pairs）。**键用于快速查找和访问**，值可以重复。适合需要通过键来获取关联值的场景。
    
      - 初始化：`std::unordered_map<KeyType, ValueType> myMap = {{key1, val1}, {key2, val2}}`;
      - 示例：`std::unordered_map<std::string, int> ages = {{"Alice", 25}, {"Bob", 30}}`;

  - std::unordered_set (哈希集合): 存储唯一的元素（unique keys）。它只关心元素本身，不存储额外的值。适合需要快速判断一个元素是否存在的场景。
    
      - 初始化：`std::unordered_set<ElementType> mySet = {elem1, elem2, elem3}`;
      - 示例：`std::unordered_set<std::string> names = {"Alice", "Bob", "Charlie"}`;

常用成员函数对比

| 函数 | std::unordered_map (哈希映射) | std::unordered_set (哈希集合) |
| :--- | :--- | :--- |
| 插入 | mymap.insert({key, value})<br>myMap.[key] = value; | insert(element)（如果元素已存在，操作无效） |
| 查找 | find(key)：返回指向键值对的迭代器，未找到则返回 end() | find(element)：返回指向元素的迭代器，未找到则返回 end() |
| 访问 | myMap.at(key) <br> myMap[key] | 不支持通过索引访问，需使用迭代器或遍历 |
| 删除 | erase(key)<br>erase(iterator) | erase(element)<br>erase(iterator) |
| 清空 | clear() | clear() |
| 大小 | size() | size() |
| 判断空 | empty() | empty() |
| 计数 | count(key)：键是唯一的，返回 0 或 1 | count(element)：元素是唯一的，返回 0 或 1 |

区别总结

  - 存储结构：map 存储键和值，而 set 只存储键（即元素本身）。
  - 访问方式：map 可以通过 at(key) 或 [] 运算符快速访问值，而 set 只能通过遍历或查找获得元素本身。
  - 应用场景：当你需要一个**“查找表”（通过键找值）时，使用 map；当你需要一个“去重集合”**（快速判断元素是否存在）时，使用 set。

### 242. 有效的字母异位词

[原题链接](https://leetcode.cn/problems/valid-anagram/description/)

```c++
int record[26] = {0};
        for(int i = 0; i < s.size(); i++ ){
            record[s[i] - 'a'] += 1;
        }

        for(int i = 0; i < t.size(); i++ ){
            record[t[i] - 'a'] -= 1;
        }
```

在C++中，``std::string``类型可以被看作是一个字符数组。可以用之前学到的.size()计算长度，用索引访问内部元素等。

这两个for循环体现了哈希表的思想：``record``是哈希表，``s[i] - 'a'``是哈希函数，字符串中的每个字符是索引，``record``数组中对应索引位置的数是值。这个过程可以总结为

>遍历字符串 s 时，取出一个字符（键），用哈希函数 ``s[i] - 'a'`` 算出它在 ``record`` 数组中的位置，然后在这个位置上将值加1。

这里可以用数组做哈希的题目的原因是，题目限定了索引数（26个字母）

### 349. 两个数组的交集

[原题链接](https://leetcode.cn/problems/intersection-of-two-arrays/description/)

```c++
unordered_set<int> result_set;
unordered_set<int> nums1_set(nums1.begin(), nums1.end());
```

unordered_set的初始化方式。注意要声明元素格式。

> 初始化unorderes_set的方式有四种。  
> * 默认初始化不赋值
> * 范围初始化。使用begin和end进行范围赋值
> * 列表初始化，例如``unordered_set<string> fruits = {"apple", "banana", "cherry", "apple"};``
> * 拷贝和移动初始化。例如
> ```c++
> std::unordered_set<double> s1 = {1.1, 2.2, 3.3};
> 
> // 拷贝构造函数：s2 是 s1 的一个完整副本
> std::unordered_set<double> s2(s1); 
> 
> // 移动构造函数：s3 “接管”了 s1 的资源，效率更高
> std::unordered_set<double> s3(std::move(s1)); 
> // s1 现在处于一个不确定的状态，通常不应再使用
> ```

```c++
for(int num : nums2){
    if (nums1_set.find(num) != nums1_set.end()){
    result_set.insert(num);
    }
}
```

注意这里的for条件，``int num : nums2``的意思是``num``遍历``nums2``中的所有值。所以num的格式与nums中元素的格式要保持一致。int可以换成auto，就不用考虑格式的事情了。或者，``const auto& num : nums2``  ,这是最正确的写法。

``if (nums1_set.find(num) != nums1_set.end())``中，if条件的意思是，如果nums1_set中没找到num。``.find(num)``可以在nums1_set中遍历寻找num。找到则返回指向num的迭代器。没找到则返回的迭代器指向末尾虚位，即nums1_set.end()。

### 202. 快乐数

[原题链接](https://leetcode.cn/problems/happy-number/description/)

```c++
while(1){
    if(n == 1){
        return true;
    }
    else if(hash_n.count(n) == 0){
        hash_n.insert(n);
        n = sum(n);
    }
    else{
        return false;
    }
}
```

哈希表法，利用哈希表快速判断元素是否存在于集合中。这里当陷入死循环或确定是快乐数都会陷入循环，通过检查元素是否重复可以判断出来。

```c++
while(slow != fast){
    slow = sum(slow);
    fast = sum(sum(fast));
}
```

快慢指针，陷入循环快慢指针就会碰面。

### 15. 三数之和

[原题链接](https://leetcode.cn/problems/3sum/description/)

这题用双指针简单一点。之后再补一下哈希表的做法？做的时候把各指针去重逻辑想清楚。尤其是left和right，使用``(nums[left + 1] == nums[left])``判断去重后，实际上left是指向的最后一个重复元素，此时还需要在最后补上一句``left++``

```c++
sort(nums.begin(), nums.end());
```

sort的用法，要引用algorithm头文件。

```c++
result.push_back(vector<int>{nums[i], nums[left], nums[right]});
```

``.push_back()``在``result``最后添加一个元素。要注意这里添加的元素类型要和``result``定义的保持一致。对于一个向量，所有元素要用花括号括起来。

### 1. 两数之和

[原题链接](https://leetcode.cn/problems/two-sum/)

这题的思路就是逐个取给定数组中的元素x，计算要与target的差值y，然后查找这个差值y存不存在。

```c++
unordered_map<int, int> num_map;
```

哈希map的定义，这里定义成``<int, int>`` 键值对。

```c++
return {i, (num_map.find(target - nums[i])->second)};
```
iterator->second表示迭代器指向键值对的第二项，即键值对的值。

### 454. 四数相加 II

[原题链接](https://leetcode.cn/problems/4sum-ii/description/)

```c++
for (int a : nums1){
    for (int b : nums2){
        A[a+b]++;
    }
}
```

先注意这里循环的写法，直接用元素值遍历数组，更简洁。也可以写成用索引遍历的，如下：
```c++
for (int a = 0; a < nums1.size(); a++){
    for (int b = 0; b < nums2.size(); b++){
        A[nums1[a]+nums2[b]]++;
    }
}
```

然后在对unordered_map添加键值对的时候，可以直接使用``A[a+b]++``。或者用insert函数插入。

```c++
for (int c : nums3){
    for (int d : nums4){
        // if(A.count(0 - c - d)){
            // result += A.find(0 - c - d)->second;
            result += A[0 - c - d];
            // }
    }
}
```

这里要注意，如果用.find的话，在更新result值的时候不能直接``result += A.find(0 - c - d)->second``，必须要先if判断一下该键是否存在，不然find如果找不到键值对会返回末尾虚节点，导致报错。使用A[0 - c - d]就不用if判断了

### 18. 四数之和

[原题链接](https://leetcode.cn/problems/4sum/description/)

这题是15.三数之和再套一层循环。还是一对left right，再由i 和j 两层循环来查找剩下两个元素。

```c++
for (int i = 0; i < (nums.size() - 3); i++){
    if (i != 0 && nums[i] == nums[i - 1]){
        continue;
    }
```

一开始写成
```c++
while (i != 0 && nums[i] == nums[i - 1]){
        i++;
```
这样i有越界的风险。要写成上面正确的形式，用``continue``跳过循环。此外，使用``continue``的时候，要记得把``while``循环改成``if``。

```c++
if((long(nums[i]) + nums[j] + nums[left] + nums[right]) < target){
    left ++;
}
```

小心数值溢出！这里四个int加一起，先强制转换一个为long就可以了。
