---
title: 贪心算法
author: Spa-Master
date: '2026-01-17 00:00:00'
updated: '2026-01-17 00:00:00'
tags:
- lang/cpp
cover: /img/covers/auto/obsidian-20-reference-9-greedy-algorithm-md-bb46e2860b.png
---

# 贪心算法

### 445.分发饼干

[原题链接](https://leetcode.cn/problems/assign-cookies/description/)

主要思想就是拿着饼干从大到小找小孩。注意饼干和小孩都要先排序。

```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        int index = s.size() - 1;
        int nums = 0;
        if(s.size() == 0)return nums;
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        for (int i = g.size() - 1; i >= 0; i-- ){
            if(s[index] >= g[i]){
                nums ++;
                if(index == 0)break;
                index --;

            }
        }
        return nums;
    }
};
```

### 376.摆动序列

[原题链接](https://leetcode.cn/problems/wiggle-subsequence/description/)

一些小错误。

```c++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        int result = 1;
        if(nums.size() < 2){
            return nums.size();
        }
        int curr_diff = 0;
        int prev_diff = 0;
        for (int i = 1; i < nums.size(); i ++){
            curr_diff = nums[i] - nums[i - 1];
            if((curr_diff > 0 && prev_diff <= 0) || (curr_diff < 0 && prev_diff >= 0)){//注意prev_diff可以等于0
                result ++;
            prev_diff = curr_diff;
            }//要等到找到非平坡才更新
        }
        return result;
    }
};
```

注意注释的地方。prev_diff可以等于零，这样才可以将第一次变化计入。更新prev_diff时也要在找到正负交替时进行，否则会丢失上一个差值。

由于只要nums非空，就必会有一个长度为1的摆动序列，所以result初始化为1.

### 53.最大子子数和

[原题链接](https://leetcode.cn/problems/maximum-subarray/description/)

kadane算法。

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int globalMax = INT_MIN;
        int preMax = 0;

        for (auto i : nums){
            preMax = max(i, preMax + i);
            globalMax = max(globalMax, preMax);
        }

        return globalMax;
        
    }
};
```

> #### kadane算法
> kadane算法的思想是从左往右遍历整个数组，判断当前和（左边所有数的和）加上当前值会不会比当前值更大。如果变小了说明当前和是负数，直接抛弃，在当前位置另起炉灶计算当前和。如果变大了则正常循环。
>
> 所以kadane算法需要维护两个参数，即上面代码中的全局最大值`globalMax`和当前最大值`preMax`

### 45.跳跃游戏II

[原题链接](https://leetcode.cn/problems/jump-game-ii/description/)

整体思想还是从左往右遍历，在遍历中更新step。step的更新逻辑是当前遍历到当前步数能到达的最远距离后+1.代码如下

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        int farest = 0;
        int loopFar = 0;
        int step = 0;

        for (int i = 0; i < nums.size() - 1; i++) {
            loopFar = max(loopFar, i + nums[i]);
            if (i == farest) {
                step++;
                farest = loopFar;
            }
            // if (loopFar >= nums.size() - 1)
            //     break;因为这个loopfar是下一步能够到的范围，但是当前这步还没到。
        }
        return step;
    }
};
```

注意注释部分。

### 1005.k次取反后最大的数组和

[原题链接](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/)

要用到比较器。刚好复习一下。

```c++
class Solution {
public:
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        class absCmp {
        public:
            bool operator()(int x, int y) const {
                return abs(x)> abs(y);

            }
        };
        absCmp cmp;
        int curIndex = 0;
        int result = 0;
        sort(nums.begin(), nums.end(), cmp);
        while (k > 0 && curIndex < nums.size()) {
            if (nums[curIndex] < 0) {
                nums[curIndex] = -nums[curIndex];
                k--;
            }
            curIndex++;
        }
        for (auto i : nums) {
            result += i;
        }
        if (k % 2 == 1)
            result -= 2 * (nums.back());
        return result;
    }
};
```
注意，`std::sort` 的比较器必须实现“**严格弱序**”（Strict Weak Ordering）。不能出现>=或<=。

注意代码中比较器的定义方式。可以使用普通函数，也可以用函数对象。前者是一个重载了operator()的类，可以有自己的成员变量，功能更强大。一个使用成员变量的函数对象例子：

>```cpp
>        class ThresholdComparator {
>    private:
>        int threshold; // 成员变量，用于存储阈值
>
>    public:
>        ThresholdComparator(int t) : threshold(t) {}
>        bool operator()(int a, int b) const {
>            if (a < threshold && b >= threshold) {
>                return true;
>            }
>            if (a >= threshold && b < threshold) {
>                return false;
>            }
>            return a < b;
>        }
>    };
>```

上面的例子还同时定义了构造函数，使用时这样`ThresholdComparator cmp(8)`就可以定义一个8为阈值的比较器。

### 134.加油站

[原题链接](https://leetcode.cn/problems/gas-station/description/)

解题思路是将站点遍历一遍，用一个变量gasSum记录从start开始gas-cost的累加值。当gasSum小于零时说明从start到当前位置没有符合条件的出发点，随后把start重新设为i+1

### 452.用最少的箭射爆气球

[原题链接](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/)

区间重合判断，首先排序。这里按左区间排序，判断与下一区间是否重合。重合则更新判断边界，不重合则说明左侧必定需要一支箭。代码如下

```c++
class Solution {
public:
    int findMinArrowShots(vector<vector<int>>& points) {
        sort(points.begin(), points.end(),
            [](const vector<int>& a, const vector<int>& b) {
                if (a[0] == b[0])
                    return a[1] < b[1];
                return a[0] < b[0];
            });
        int pos = points[0][1];
        int ArrowNums = 0;
        for (int i = 0; i < points.size(); i++) {
            if (points[i][0] <= pos) {
                pos = min(pos, points[i][1]);
            } else {
                ArrowNums++;
                pos = points[i][1];
            }
        }
        return ArrowNums + 1;
    }
};
```

用pos判断是否重合。如果下一节点的左边界小于pos说明有一段是重合的，用`pos = min(pos, points[i][1]);`更新pos。

### 435.无重叠区间

[原题链接](https://leetcode.cn/problems/non-overlapping-intervals/description/)

跟[452](#452用最少的箭射爆气球)类似，如果用452的算法判断出必须射一根箭，也正好说明范围内有一个无重叠区间。需要注意的是边界条件。本体区间都是开区间，端点重合也是无重叠。代码如下

```c++
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(),
             [](const vector<int>& a, const vector<int>& b) {
                 if (a[0] == b[0])
                     return a[1] < b[1];
                 return a[0] < b[0];
             });
        int nums = 1;
        int end = intervals[0][1];
        for (int i = 1; i < intervals.size(); i++){
            if(end > intervals[i][0]){
                end = min(end, intervals[i][1]);
            }
            else
            {
                nums ++;
                end = intervals[i][1];
            }
        }
        return intervals.size() - nums;
    }
};
```

### 763.划分字母区间

[原题链接](https://leetcode.cn/problems/partition-labels/description/)

先遍历一遍字符串得到每个字母的最后出现位置，再遍历一遍进行分割。分割边界取边界和当前字母最后出现位置的较大值。代码如下

```c++
class Solution {
public:
    vector<int> partitionLabels(string s) {
        vector<int> lastLables(26, 0);
        vector<int> result;
        for(int i = 0; i < s.size(); i ++){
            lastLables[s[i] - 'a'] = i;
        }
        int index = 0;
        int last = 0;
        for (int i = 0; i < s.size(); i ++){
            index = max(lastLables[s[i] - 'a'], index);
            if (i == index){
                result.push_back(i - last + 1);
                last = i + 1;
            }
        }
        return result;
    }
};
```

注意边界条件。在第一次分割时`last`表示的是字符串的第一个字符，所以后续更新`last`的时候要更新成`last = i + 1`。

### 968.监控二叉树

[原题链接](https://leetcode.cn/problems/binary-tree-cameras/description/)

贪心在于给每个叶子节点的父节点安装摄像头。另外，要注意一个摄像头可以监控左右孩子和父节点，因此下一个摄像头最远可以间距两层。具体代码如下
```c++

class Solution {
private:
    int nums = 0;
    int traversal(TreeNode* root) { // 0表示已安装，1表示被覆盖，2表示未被覆盖
        if (root == nullptr) {
            return 1;
        }
        int left = traversal(root->left);
        int right = traversal(root->right);
        if (left == 2 || right == 2) {
            nums++;
            return 0;
        } else if (left == 0 || right == 0) {
            return 1;
        } else{
            return 2;
        }
    }
public:
    int minCameraCover(TreeNode* root) {
        if (traversal(root) == 2)nums ++;
        return nums;
    }
};
```

根据之前分析的，两个摄像头之间最多可以间隔两层。所以这里的遍历函数要用返回值来表示节点状态（已安装摄像头、被摄像头覆盖、未安装摄像头）。在确定返回值时，要明确状态转移过程。函数中分了三种情况，第一种`left == 2 || right == 2`左右节点至少有一个未被覆盖，说明当前节点必须安装摄像头。第二种`left == 0 || right == 0`至少有一个安装了摄像头，那当前节点就是被覆盖的状态。其余所有状况归于第三种。

### 738.单调递增的数字

[原题链接](https://leetcode.cn/problems/monotone-increasing-digits/description/)

核心在于原数字中，如果高一位数字大于第一位数字，那么为了让结果最大，高位数字-1，低位数字置9。从右往左遍历。代码如下

```c++
class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        string stN = to_string(n);
        int set9flag = stN.size();
        for(int i = stN.size() - 1; i > 0; i --){
            if(stN[i] < stN[i - 1]){
                stN[i-1] = stN[i-1] - 1;
                set9flag = i;
            }
        }
        for(int i = stN.size() - 1; i >= set9flag; i --){
            stN[i] = '9';
        }
        return stoi(stN);
    }
};
```
