---
title: 栈和队列
author: Spa-Master
date: '2026-01-17 00:00:00'
updated: '2026-01-17 00:00:00'
tags:
- lang/cpp
---

# 栈和队列

![栈和队列](https://cdn.jsdelivr.net/gh/HRbenY/blog-assets@master//img/20260117145538050.png)

## STL概念

STL (Standard Template Library, 标准模板库) 是 C++ 标准库的核心部分，它提供了一套功能强大的通用数据结构和算法。STL 基于泛型编程 (Generic Programming) 的思想，通过模板实现了代码的高度可重用性。

### STL 四大核心组件

1.  **容器 (Containers)**
    * **作用**：用于存储和管理数据的类模板，即各种数据结构。
    * **分类**：
        * **序列容器** (`vector`, `deque`, `list`)：按线性顺序存储元素。
        * **关联容器** (`set`, `map`)：根据键值自动排序元素，查找速度快。
        * **无序关联容器** (`unordered_set`, `unordered_map`)：基于哈希表，提供更快的平均查找速度。
        * **容器适配器** (`stack`, `queue`, `priority_queue`)：在现有容器基础上提供特定接口。

2.  **算法 (Algorithms)**
    * **作用**：一系列用于处理容器中元素的函数模板，如排序、搜索、复制等。
    * **特点**：算法独立于任何特定容器，通过迭代器与数据进行交互。例如 `sort()`, `find()`, `copy()`。

3.  **迭代器 (Iterators)**
    * **作用**：扮演容器和算法之间的“胶水”或桥梁。它是一种行为类似指针的对象，用于遍历容器中的元素。
    * **特点**：使得任何算法都可以与任何容器协同工作。

4.  **函数对象 (Functors)**
    * **作用**：行为类似函数的对象，可以通过重载 `operator()` 来实现。
    * **用途**：常用于自定义算法的行为，例如为 `sort()` 提供自定义的排序规则。

---

## 2. STL 容器适配器：`stack` 与 `queue`

它们是通过封装其他容器（默认为 `deque`）来实现的，仅提供符合其数据结构特性的有限接口。

### 栈 (std::stack)

**后进先出 (LIFO - Last-In, First-Out)** 的数据结构。需要包含头文件 `<stack>`。

| 函数 (Function) | 功能描述 | 用法示例 |
| :--- | :--- | :--- |
| `push(element)` | 在栈顶压入一个新元素。 | `s.push(10);` |
| `pop()` | **移除**栈顶的元素（无返回值）。 | `s.pop();` |
| `top()` | **返回**对栈顶元素的引用（不移除）。 | `int val = s.top();` |
| `empty()` | 检查栈是否为空，空则返回 `true`。 | `if (s.empty()) { ... }` |
| `size()` | 返回栈中元素的数量。 | `int count = s.size();` |

### 队列 (std::queue)

**先进先出 (FIFO - First-In, First-Out)** 的数据结构。需要包含头文件 `<queue>`。

| 函数 (Function) | 功能描述 | 用法示例 |
| :--- | :--- | :--- |
| `push(element)` | 在队尾推入一个新元素（入队）。 | `q.push(10);` |
| `pop()` | **移除**队头的元素（无返回值）。 | `q.pop();` |
| `front()` | **返回**对**队头**元素的引用。 | `int val = q.front();` |
| `back()` | **返回**对**队尾**元素的引用。 | `int val = q.back();` |
| `empty()` | 检查队列是否为空，空则返回 `true`。 | `if (q.empty()) { ... }` |
| `size()` | 返回队列中元素的数量。 | `int count = q.size();` |

---

## 力扣

### 150. 逆波兰表达式求值

[原题链接](https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/)

思路很简单，这里记一下一些类型转换函数。

> #### C++ `sto*` 系列函数用法详解
> 
> `sto*` 系列函数是 C++11 引入的，定义在 `<string>` 头文件中。它们是将字符串转换为数值类型的现代、安全的首选方法，主要优点是通过抛出异常来处理错误，避免了 C 风格函数（如 `atoi`）的 ambiguity。
> 
> ##### 主要函数列表
> 
> | 函数 (Function) | 功能 (Description) | 返回类型 (Return Type) | 示例代码 (Example) |
> | :--- | :--- | :--- | :--- |
> | `std::stoi` | 转换为有符号整型 | `int` | `int i = stoi(" -123 ");` |
> | `std::stol` | 转换为有符号长整型 | `long` | `long l = stol(" 12345 ");` |
> | `std::stoll` | 转换为有符号长长整型 | `long long` | `long long ll = stoll("1234567890");`|
> | `std::stoul` | 转换为无符号长整型 | `unsigned long` | `unsigned long ul = stoul("98765");` |
> | `std::stoull`| 转换为无符号长长整型 | `unsigned long long` | `unsigned long long ull = stoull("9876543210");`|
> | `std::stof` | 转换为单精度浮点数 | `float` | `float f = stof("3.14f");` |
> | `std::stod` | 转换为双精度浮点数 | `double` | `double d = stod("2.71828");` |
> | `std::stold`| 转换为长双精度浮点数 | `long double` | `long double ld = stold(" -1.23e+4 ");` |
> 
> ##### 通用特性
> 
> * **错误处理**:
>     * `std::invalid_argument`: 如果字符串无法进行任何转换（例如 `stoi("hello")`），则抛出此异常。
>     * `std::out_of_range`: 如果转换后的值超出了返回类型的表示范围（例如 `stoi("3000000000")`），则抛出此异常。
> * **参数**:
>     * 这些函数通常接受可选的第二个参数（`size_t* idx`）来获取已处理的字符数，以及第三个参数（`int base`）来指定进制（仅适用于整型函数）。

### 239. 滑动窗口最大值

[原题链接](https://leetcode.cn/problems/sliding-window-maximum/description/)

要注意在滑动窗口的前提下，当前的窗口最大值的生命周期是有限的。每次滑动都有新入列和新出列的元素。可以重新定义pop和push方法，使push入列之后内部是顺序排列的，当pop的值是列内最大值就把最大值排出。

```c++
private:
    class myQue {
    public:
        deque<int> myq;
        myQue() {}
        void pop(int val) {
            if (!myq.empty() && val == myq.front()) {
                myq.pop_front();
            }
        }
        void push(int val) {
            if (myq.empty()) {
                myq.push_back(val);
            } else {
                while (!myq.empty() && val > myq.back()) {
                    myq.pop_back();
                }
                myq.push_back(val);
            }
        }
        int front() { return myq.front(); }
    };
```

由于我们要重新定义pop和push方法，这里在题目给定的类内部新建私有类myQue。由于需要同时对头尾进行操作，这里使用deque数据结构。用法如下：

> #### 构造函数 (Constructors)
> 
> 用于创建 `deque` 对象。
> 
> | 函数 | 说明 |
> | :--- | :--- |
> | `deque()` | 默认构造函数，创建一个空的 `deque`。 |
> | `explicit deque(size_type n)` | 创建一个包含 `n` 个默认初始化元素的 `deque`。 |
> | `deque(size_type n, const T& value)` | 创建一个包含 `n` 个值为 `value` 的元素的 `deque`。 |
> | `deque(InputIt first, InputIt last)` | 用迭代器 `first` 和 `last` 之间的元素创建 `deque`。 |
> | `deque(const deque& other)` | 拷贝构造函数，创建 `other` 的一个副本。 |
> | `deque(deque&& other)` | 移动构造函数，接管 `other` 的资源。 |
> | `deque(std::initializer_list<T> ilist)` | 用初始化列表创建 `deque` (例如 `std::deque<int> d = {1, 2, 3};`)。 |
> 
> ---
> 
> #### 元素访问 (Element access)
> 
> 用于访问 `deque` 中的数据。
> 
> | 函数 | 说明 |
> | :--- | :--- |
> | `at(size_type pos)` | 返回在指定位置 `pos` 的元素的引用。会进行边界检查，如果越界会抛出 `std::out_of_range` 异常。 |
> | `operator[](size_type pos)` | 返回在指定位置 `pos` 的元素的引用。**不进行**边界检查，如果越界是未定义行为。 |
> | `front()` | 返回第一个元素的引用。在一个空 `deque` 上调用是未定义行为。 |
> | `back()` | 返回最后一个元素的引用。在一个空 `deque` 上调用是未定义行为。 |
> 
> ---
> 
> #### 修改器 (Modifiers)
> 
> 用于修改 `deque` 的内容。
> 
> | 函数 | 说明 |
> | :--- | :--- |
> | `push_front(const T& value)` | 在 `deque` 的开头插入一个元素。 |
> | `push_back(const T& value)` | 在 `deque` 的末尾添加一个元素。 |
> | `pop_front()` | 移除 `deque` 的第一个元素。 |
> | `pop_back()` | 移除 `deque` 的最后一个元素。 |
> | `insert(iterator pos, const T& value)` | 在迭代器 `pos` 指向的位置之前插入元素 `value`。 |
> | `insert(iterator pos, size_type n, const T& value)`| 在 `pos` 之前插入 `n` 个值为 `value` 的元素。 |
> | `insert(iterator pos, InputIt first, InputIt last)`| 在 `pos` 之前插入由迭代器 `[first, last)` 范围指定的元素。 |
> | `erase(iterator pos)` | 移除迭代器 `pos` 指向的元素。 |
> | `erase(iterator first, iterator last)` | 移除迭代器 `[first, last)` 范围内的所有元素。 |
> | `swap(deque& other)` | 与另一个 `deque` 交换内容。 |
> | `clear()` | 清空 `deque` 中的所有元素，使其大小变为 0。 |
> | `emplace_front(Args&&... args)` | 在 `deque` 的开头就地构造一个元素，比 `push_front` 更高效（避免额外拷贝）。 |
> | `emplace_back(Args&&... args)` | 在 `deque` 的末尾就地构造一个元素，比 `push_back` 更高效。 |
> | `emplace(iterator pos, Args&&... args)` | 在迭代器 `pos` 指向的位置之前就地构造一个元素。 |
> | `assign(size_type n, const T& value)` | 赋予 `deque` 新内容，替换掉原有内容（`n` 个 `value`）。 |
> | `assign(InputIt first, InputIt last)` | 赋予 `deque` 新内容，替换掉原有内容（来自迭代器范围）。 |
> 
> ---
> 
> #### 容量 (Capacity)
> 
> 用于查询 `deque` 的大小和容量状态。
> 
> | 函数 | 说明 |
> | :--- | :--- |
> | `empty()` | 检查 `deque` 是否为空。如果是，返回 `true`。 |
> | `size()` | 返回 `deque` 中元素的数量。 |
> | `max_size()` | 返回 `deque` 能够容纳的最大元素数量。 |
> | `resize(size_type n)` | 改变 `deque` 的大小为 `n`。如果 `n` 小于当前大小，则丢弃末尾元素；如果 `n` 大于当前大小，则在末尾添加默认初始化的元素。 |
> | `resize(size_type n, const T& value)` | 功能同上，但在扩容时添加值为 `value` 的元素。 |
> | `shrink_to_fit()` | 请求 `deque` 减少其内存使用以适应其大小（这只是一个请求，不保证一定实现）。 |
> 
> ---
> 
> #### 迭代器 (Iterators)
> 
> 用于遍历 `deque`。`deque` 的迭代器是随机访问迭代器。
> 
> | 函数 | 说明 |
> | :--- | :--- |
> | `begin()` | 返回指向第一个元素的迭代器。 |
> | `end()` | 返回指向末尾元素之后位置的迭代器。 |
> | `rbegin()` | 返回指向最后一个元素的反向迭代器。 |
> | `rend()` | 返回指向第一个元素之前位置的反向迭代器。 |
> | `cbegin()`, `cend()` | 返回 `const` 迭代器，用于只读访问。 |
> | `crbegin()`, `crend()` | 返回 `const` 反向迭代器，用于只读访问。 |




### 232. 用栈实现队列

[原题链接](https://leetcode.cn/problems/implement-queue-using-stacks/description/)

用两个栈可以实现队列。

```c++
MyQueue():inStack(), outStack() {}
```
这是之前在链表中讲过的构造函数，使用的成员初始化列表进行初始化。这里没有给初始值，如果需要给初始值的话，除了用成员初始化列表，也可以在函数内部（花括号内部）进行赋值操作。两者有一些重要区别：


> #### 成员初始化列表 vs. 赋值初始化
> 
> 
> 
> 为了方便对比，我们使用一个简单的 `Student` 类作为例子。
> 
> 
> 
> **方式一：成员初始化列表 (Member Initializer List)**
> 
> ```cpp
> 
> class Student {
> 
> public:
> 
>     std::string name;
> 
>     const int studentID;
> 
> 
> 
>     // 使用成员初始化列表
> 
>     Student(std::string n, int id) : name(n), studentID(id) {
> 
>         // 构造函数体可以是空的
> 
>     }
> 
> };
> 
> ```
> 
> 
> 
> **方式二：赋值初始化 (In-body Assignment)**
> 
> ```cpp
> 
> class Student {
> 
> public:
> 
>     std::string name;
> 
>     // const int studentID; // 错误！const 成员不能在此处使用赋值初始化
> 
> 
> 
>     // 在构造函数体内赋值
> 
>     Student(std::string n) {
> 
>         name = n;
> 
>     }
> 
> };
> 
> ```
> 
> #### 核心对比
> 
>| 对比项 | 成员初始化列表 (Member Initializer List) | 赋值初始化 (In-body Assignment) |
>| :--- |:--- |:--- |
> | **本质** | **初始化 (Initialization)** | **赋值 (Assignment)** |
> | **详细说明** | 在对象创建时，成员变量被“直接构建”出来，一步到位。就像婴儿出生时直接取好名字。 | 成员变量会先被**默认初始化**，然后在构造函数体内被赋予新值。就像婴儿出生时先有个临时编号，之后再改名。 |
> | **执行时机** | 在进入构造函数体 `{}` **之前**执行。 | 在构造函数体 `{}` **之内**执行。 |
> | **效率** | **更高**。尤其对于类类型的成员（如 `string` 或其他自定义类），它避免了“默认构造 + 赋值”的两次开销。 | **较低**。对于复杂类型，会产生额外的函数调用开销，影响性能。 |
> | **适用性** | **通用性强**。是唯一可以初始化以下三种成员的方式：<br>1. `const` 常量成员<br>2. 引用 (`&`) 成员<br>3. 没有默认构造函数的类成员 | **通用性差**。无法用于初始化 `const` 成员、引用成员或没有默认构造函数的类成员，会导致编译错误。 |
> | **代码风格** | **推荐**。被认为是现代 C++ 的最佳实践，代码更高效、更清晰。 | **不推荐**。只应在初始化逻辑非常复杂（如需要 `if/else` 或循环）时，在函数体内进行后续的赋值操作。 |
> 
> 
> 
> #### 黄金法则
> 
> 
> 
> > **能用初始化列表的，就都用初始化列表。**
> 
> >
> 
> > 这是一个简单且高效的准则。它不仅能带来性能上的好处，还能避免因 `const` 或引用成员无法被赋值而导致的编译错误，是更健壮、更专业的写法。

```c++
int peek() {
    int res = this->pop();
    //this->push(res);//这样会把元素push到队列尾部
    outStack.push(res);
    return res;
}
```

``this``表示当前对象，这里强调调用当前对象自己的pop()函数，避免歧义。  

### 225. 用队列实现栈

题目要求用两个队列，其实一个就可以了。主要是pop()这一步。  
**用两个队列**的话把除了尾部元素以外的所有元素全部push到另一个队列中，取出尾部元素后将其余元素再push回去。  
**用一个队列**则是把头部的push到队列尾部，如此循环直到取出最开始的尾部元素。

### 347


> #### **C++ 知识点笔记：基于小顶堆解决 Top K 问题**
> 
> 
> 
> ##### **1. 核心数据结构：`std::priority_queue`**
> 
> 
> 
> `std::priority_queue` 是 C++ 标准库中的一个容器适配器，通常基于堆（Heap）数据结构实现。默认行为是**大顶堆**，即顶部元素始终是优先级最高（最大）的。
> 
> 
> 
> **1.1. 模板参数**
> 
> 
> 
> 其定义包含三个模板参数：
> 
> 
> 
> ```cpp
> 
> template <class T, class Container = vector<T>, class Compare = less<T>>
> 
> class priority_queue;
> 
> ```
> 
> 
> 
> * **`T` (Type)**: 存储的元素类型。
> 
>     * *示例代码应用*: `std::pair<int, int>`，用于存储键值对 `(数值, 频率)`。
> 
> 
> 
> * **`Container`**: 实现堆所需的底层容器。
> 
>     * **要求**: 必须是支持随机访问迭代器的序列容器，例如 `std::vector` (默认) 或 `std::deque`。
> 
>     * *示例代码应用*: `std::vector<std::pair<int, int>>`。
> 
> 
> 
> * **`Compare`**: 比较器，用于定义元素间的优先级顺序。
> 
>     * **默认值**: `std::less<T>`，它通过 `a < b` 进行比较，建立大顶堆。
> 
>     * **自定义**: 通过提供自定义的比较器类型，可以改变其行为，例如实现小顶堆。
> 
> 
> 
> ---
> 
> 
> 
> ##### **2. 关键技术：自定义比较器**
> 
> 
> 
> 当默认的排序行为不满足需求时，必须提供自定义比较器。在本例中，需求是：1) 根据 `pair` 的第二个元素（频率）排序；2) 实现小顶堆。
> 
> 
> 
> **2.1. 比较器 (Comparator)**
> 
> 
> 
> 比较器是一个可调用实体，它接受两个同类型参数并返回一个布尔值，用于确定它们的相对顺序。
> 
> 
> 
> **2.2. 实现方式：函数对象 (Functor)**
> 
> 
> 
> 函数对象是一个重载了函数调用运算符 `operator()` 的类的对象。这是向 STL 模板传递自定义逻辑的标准方法。
> 
> 
> 
> * **定义**:
> 
>     ```cpp
> 
>     class mycomparison {
> 
>     public:
> 
>         // 重载 operator()
> 
>         bool operator()(const std::pair<int, int>& lhs, const std::pair<int, int>& rhs) const {
> 
>             return lhs.second > rhs.second;
> 
>         }
> 
>     };
> 
>     ```
> 
> * **工作原理**:
> 
>     * `priority_queue` 的第三个模板参数接收一个**类型** (`mycomparison`)。
> 
>     * 在内部，`priority_queue` 会创建该类型的一个实例（一个函数对象）。
> 
>     * 当需要比较两个元素 `a` 和 `b` 的优先级时，它会调用 `comp_obj(a, b)`，其中 `comp_obj` 就是创建的函数对象。
> 
> 
> 
> **2.3. 比较逻辑与小顶堆的实现**
> 
> 
> 
> `priority_queue` 的比较器逻辑遵循“严格弱序”。其核心规则是：
> 
> * `Compare(a, b)` 若返回 `true`，则认为 `b` 的优先级高于 `a`。
> 
> * 在 `return lhs.second > rhs.second;` 的逻辑下：
> 
>     * 如果 `lhs` 的频率大于 `rhs` 的频率，表达式为 `true`。
> 
>     * 这意味着 `rhs` (频率较小者) 的优先级被视为更高，会被放置在堆的更上层。
> 
>     * 最终，频率最小的元素会成为堆顶。这就构成了一个基于频率的**小顶堆**。
> 
> 
> 
> ---
> 
> 
> 
> ##### **3. C++ 基础概念**
> 
> 
> 
> **3.1. 作用域解析运算符 `::`**
> 
> 
> 
> `::` 用于指定一个名称（类型、函数、变量等）所属的作用域。
> 
> * **访问命名空间成员**: `std::cout`，表示 `cout` 属于 `std` 命名空间。
> 
> * **访问嵌套类型**: `std::unordered_map<int, int>::iterator`，表示 `iterator` 类型是在 `std::unordered_map` 类内部定义的。
> 
> 
> 
> **3.2. 头文件 (`#include`) 与命名空间 (`namespace`)**
> 
> 
> 
> 这两个概念协同工作但功能不同。
> 
> * `#include <header>`: 预处理指令，它将指定头文件的内容包含进来，使其中声明的类、函数等对编译器**可见**。
> 
> * `namespace`: 避免命名冲突的机制。标准库的所有组件都定义在 `std` 命名空间中。要使用它们，必须通过 `std::` 前缀显式指定其作用域，或者使用 `using` 指令。
> 
> 
> 
> **3.3. 迭代器 (`iterator`)**
> 
> 
> 
> 迭代器是一种对象，其行为类似于指针，用于遍历容器中的元素。
> 
> * **`container::iterator`**: 迭代器的类型，由容器类嵌套定义。
> 
> * **`container.begin()`**: 返回一个指向容器第一个元素的迭代器。
> 
> * **`container.end()`**: 返回一个指向容器“尾后”（past-the-end）位置的迭代器，它不指向任何有效元素。
> 
> * **`*it`**: 解引用，获取迭代器当前指向的元素。
> 
> * **`it++`**: 移动迭代器到下一个元素。

比较器
return true --> 左边优先级低

return false --> 左边优先级高
