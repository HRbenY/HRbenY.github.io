<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Spa-Master 的博客 - 记录与分享</title><meta name="author" content="HRbenY"><meta name="copyright" content="HRbenY"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="个人技术博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Spa-Master 的博客">
<meta property="og:url" content="https://hrbeny.github.io/page/6/index.html">
<meta property="og:site_name" content="Spa-Master 的博客">
<meta property="og:description" content="个人技术博客">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hrbeny.github.io/img/mai.png">
<meta property="article:author" content="HRbenY">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hrbeny.github.io/img/mai.png"><script type="application/ld+json"></script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://hrbeny.github.io/page/6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4-b1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spa-Master 的博客',
  isHighlightShrink: false,
  isToc: false,
  pageType: 'home'
}</script><link rel="stylesheet" href="/css/callout_blocks.css"><meta name="generator" content="Hexo 8.1.1"></head><body><div class="page" id="body-wrap"><header class="full_page" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Spa-Master 的博客</span></a></span><div id="menus"></div></nav><div id="site-info"><h1 id="site-title">Spa-Master 的博客</h1><div id="site_social_icons"><a class="social-icon" href="https://github.com/hrbeny" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:hrcharck@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts nc" id="recent-posts"><div class="recent-post-items"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2026/01/11/obsidian/90-Archived/%E8%AF%BE%E7%A8%8B/%E5%BA%94%E7%94%A8%E9%AB%98%E7%AD%89%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6/Newton-Cotes%E5%85%AC%E5%BC%8F/" title="Newton-Cotes公式">Newton-Cotes公式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2026-01-11T16:14:38.000Z" title="发表于 2026-01-12 00:14:38">2026-01-12</time></span></div><div class="content">∫abf(x)dx≈(b−a)∑k=0nCk(n)f(xk)\int_a^b f(x) dx \approx (b-a) \sum_{k=0}^n C_k^{(n)} f(x_k) ∫ab​f(x)dx≈(b−a)k=0∑n​Ck(n)​f(xk​) 根据Cotes系数的不同有不同的公式。常用的是n=1梯形公式和n=2辛普森公式。  梯形公式 I≈b−a2[f(a)+f(b)]=h2[f(a)+f(b)]I \approx \frac{b-a}{2} [f(a) + f(b)]=\frac{h}{2} [f(a) + f(b)] I≈2b−a​[f(a)+f(b)]=2h​[f(a)+f(b)] 这里因为梯形公式将整个区间视为一步，所以h=b−ah=b-ah=b−a  复化 把曲边梯形切成首位相接的 nnn 个小条，每个小条都用直边梯形来近似，然后面积求和。   步长：h=b−anh = \frac{b-a}{n}h=nb−a​   节点：xk=a+k⋅h(k=0,1,…,n)x_k = a + k \cdot h \quad (k=0, 1, \dots, n)xk​=a+k⋅...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2026/01/11/obsidian/90-Archived/%E8%AF%BE%E7%A8%8B/%E5%BA%94%E7%94%A8%E9%AB%98%E7%AD%89%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6/%E6%9C%80%E4%BD%B3%E5%B9%B3%E6%96%B9%E9%80%BC%E8%BF%91/" title="最佳平方逼近">最佳平方逼近</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2026-01-11T15:33:58.000Z" title="发表于 2026-01-11 23:33:58">2026-01-11</time></span></div><div class="content"> 离散情况将积分换成求和。  最佳平方逼近，本质上就是高维空间里的“垂直投影”。最佳平方逼近的过程就是要让误差垂直于{1,x,x2}\{1, x, x^2\}{1,x,x2}张成的空间的每一个基方向。  内积 在几何里，判断两个向量是否垂直，我们用点积（Dot Product）是否为 0。 在函数的世界里，内积就是点积的连续版本： ⟨f,g⟩=∫abf(x)g(x)dx\langle f, g \rangle = \int_a^b f(x)g(x) dx ⟨f,g⟩=∫ab​f(x)g(x)dx 如果这个积分为 0，我们就说这两个函数“垂直”（正交）。  法方程（正规方程） 我们要找系数 c0,c1,c2c_0, c_1, c_2c0​,c1​,c2​，让误差 R=f−(c0⋅1+c1⋅x+c2⋅x2)R = f - (c_0 \cdot 1 + c_1 \cdot x + c_2 \cdot x^2)R=f−(c0​⋅1+c1​⋅x+c2​⋅x2) 垂直于所有的基 {1,x,x2}\{1, x, x^2\}{1,x,x2}。 这意味着我们要列出三个垂直方程：   误差 垂直于 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2026/01/11/obsidian/90-Archived/%E8%AF%BE%E7%A8%8B/%E5%BA%94%E7%94%A8%E9%AB%98%E7%AD%89%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6/%E6%8F%92%E5%80%BC%E6%B3%95/" title="插值法">插值法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2026-01-11T15:33:15.000Z" title="发表于 2026-01-11 23:33:15">2026-01-11</time></span></div><div class="content"> Lagrange  基函数 这个基函数 li(x)l_i(x)li​(x) 只有两个核心任务（**也就是它的“0-1性质”）：   在自己的节点（xix_ixi​）必须是 1：当 xxx 等于这个节点 xix_ixi​ 时，函数值为 1。   在其他节点（xj,j≠ix_j, j \neq ixj​,j=i）必须是 0：当 xxx 等于其他任何节点时，函数值统统为 0。   公式为 li(x)=∏j=0,j≠inx−xjxi−xjl_i(x) = \prod_{j=0, j \neq i}^{n} \frac{x - x_j}{x_i - x_j} li​(x)=j=0,j=i∏n​xi​−xj​x−xj​​  假设有三个点 x0,x1,x2x_0, x_1, x_2x0​,x1​,x2​。我们要写出 l1(x)l_1(x)l1​(x)（中间那个点的基函数）： l1(x)=(x−x0)(x1−x0)⋅(x−x2)(x1−x2)l_1(x) = \frac{(x - x_0)}{(x_1 - x_0)} \cdot \frac{(x - x_2)}{(x_1 - x_2)} ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2026/01/11/obsidian/90-Archived/%E8%AF%BE%E7%A8%8B/%E5%BA%94%E7%94%A8%E9%AB%98%E7%AD%89%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/" title="矩阵分解">矩阵分解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2026-01-11T12:33:36.000Z" title="发表于 2026-01-11 20:33:36">2026-01-11</time></span></div><div class="content"> 满秩分解 将原矩阵做行初等变换，化成行最简型。比如 A=(1230021−11021)→行变换G=(10210112−120000)A = \begin{pmatrix} 1 &amp; 2 &amp; 3 &amp; 0 \\ 0 &amp; 2 &amp; 1 &amp; -1 \\ 1 &amp; 0 &amp; 2 &amp; 1 \end{pmatrix} \xrightarrow{\text{行变换}} G = \begin{pmatrix} 1 &amp; 0 &amp; 2 &amp; 1 \\ 0 &amp; 1 &amp; \frac{1}{2} &amp; -\frac{1}{2} \\0 &amp; 0 &amp; 0 &amp; 0 \end{pmatrix} A=⎝⎛​101​220​312​0−11​⎠⎞​行变换​G=⎝⎛​100​010​221​0​1−21​0​⎠⎞​ 化成行最简后，列之间的关系依旧保留，比如这里第三列可以由前两列表示为: (20.5)=2×(10)+0.5×(01)\begin{pmatrix} 2 \\ 0.5 \end{p...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2026/01/11/obsidian/90-Archived/%E8%AF%BE%E7%A8%8B/%E5%BA%94%E7%94%A8%E9%AB%98%E7%AD%89%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6/Jordan/" title="Jordan">Jordan</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2026-01-11T08:11:02.000Z" title="发表于 2026-01-11 16:11:02">2026-01-11</time></span></div><div class="content"> Jordan块的数量 考虑特征值λ\lambdaλ的  代数重数：λ\lambdaλ的幂数，决定了Jordan矩阵中特征值的数量，也是Jordan矩阵的大小。 几何重数：等于λ\lambdaλ的线性独立特征向量的数量。决定了Jordan矩阵中Jordan块的数量 注意重数都是针对某一个特征值的，一个矩阵中可能有多个特征值，由多个小Jordan矩阵组成。  紧盯着最小多项式看最大块，盯着代数重数看总和，盯着几何重数看块数。  求𝑃−1𝐴𝑃=𝐽𝐴𝑃^{−1}𝐴𝑃=𝐽_𝐴P−1AP=JA​. 正常算A的特征值和对应的特征向量。既然要Jordan化，那肯定是有重根的，而且几何重数小于代数重数。比如λ1\lambda_1λ1​的特征向量是a1a_1a1​ ，那么我们再解一次特征方程，这次令Aλ=a1A\lambda=a_1Aλ=a1​ ,解出来得到广义特征向量λ2\lambda2λ2。也可以可以通过该方程验证是否正确。 A=(2010021000210002)A = \begin{pmatrix} 2 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2026/01/10/obsidian/90-Archived/%E8%AF%BE%E7%A8%8B/%E5%BA%94%E7%94%A8%E9%AB%98%E7%AD%89%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/" title="假设检验">假设检验</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2026-01-10T14:43:13.000Z" title="发表于 2026-01-10 22:43:13">2026-01-10</time></span></div><div class="content"> 均值 思路是构造服从t分布的统计量T，计算拒绝域，然后将题目给定的统计量带入T的公式计算出T，看是否落到拒绝域。  构造t分布  T⏟统计量=xˉ−μ⏟距离S/n⏟标准误\underbrace{T}_{\text{统计量}} = \frac{\underbrace{\bar{x} - \mu}_{\text{距离}}}{\underbrace{S/\sqrt{n}}_{\text{标准误}}} 统计量T​​=标准误S/n​​​距离xˉ−μ​​​ 跟置信区间一样，用抽样的方差代替总体标准差就构造T分布，已知总体标准差σ\sigmaσ就构造Z分布：$$Z = \frac{\bar{x} - \mu_0}{\sigma/\sqrt{n}}$$  计算拒绝域  根据给定的alpha查表，得出拒绝域 W={T≤−tα(n−1)}W = \{T \le -t_{\alpha}(n-1)\}W={T≤−tα​(n−1)}  代入题目给定的参数计算统计量T在哪里  T=xˉ−μ0S/nT = \frac{\bar{x} - \mu_0}{S/\sqrt{n}} T=S/n​xˉ−μ0​​  如...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2026/01/10/obsidian/90-Archived/%E8%AF%BE%E7%A8%8B/%E5%BA%94%E7%94%A8%E9%AB%98%E7%AD%89%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6/%E7%BD%AE%E4%BF%A1%E5%8C%BA%E9%97%B4/" title="置信区间">置信区间</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2026-01-10T14:36:22.000Z" title="发表于 2026-01-10 22:36:22">2026-01-10</time></span></div><div class="content"> 估计均值μ\muμ 所有的置信区间公式长得都一样： 区间=样本均值(Xˉ)±容错半径\text{区间} = \text{样本均值}(\bar{X}) \pm \text{容错半径} 区间=样本均值(Xˉ)±容错半径 容错半径由三个因素决定：   数据的波动大小：方差越大，网得张得越大（SSS）。   样本量：测得越多，越精准，网可以收得越窄（n\sqrt{n}n​）。   胆量（置信水平）：你要求 95% 的把握，网就要大一点；如果只要求 80% 的把握，网就可以小一点（这就涉及到 ttt 分布的系数）。    分布类型 这是做这类题的第一道坎。我们要在 Z 分布（标准正态）和 t 分布之间做选择。 判据：    已知 σ\sigmaσ →\rightarrow→ 用 Z 分布。   未知 σ\sigmaσ（只给了样本方差 SSS） →\rightarrow→ 用 t 分布。     Z分布 Xˉ±zα/2σn\bar{X} \pm z_{\alpha/2} \frac{\sigma}{\sqrt{n}} Xˉ±zα/2​n​σ​   Xˉ\bar{X}Xˉ（基准点）：我就站在...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2026/01/10/obsidian/90-Archived/%E8%AF%BE%E7%A8%8B/%E5%BA%94%E7%94%A8%E9%AB%98%E7%AD%89%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6/%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/" title="参数估计">参数估计</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2026-01-10T12:46:16.000Z" title="发表于 2026-01-10 20:46:16">2026-01-10</time></span></div><div class="content"> 矩估计 核心思想：让“理论上的平均值”等于“样本实际算出来的平均值”。 E(X)=XˉE(X) = \bar{X}E(X)=Xˉ  最大似然估计 核心思想：既然这些样本 (x1,x2,…,xn)(x_1, x_2, \dots, x_n)(x1​,x2​,…,xn​) 已经发生了，那么参数 ppp 应该是多少，才使得这一组数据出现的概率最大？ 在数学上，我们不想一个个猜，而是用求导来直接算极值点。 假设样本为 x1,x2,…,xnx_1, x_2, \dots, x_nx1​,x2​,…,xn​，待求参数为 θ\thetaθ。  Step 1: 写出似然函数 L(θ)L(\theta)L(θ) 似然函数 L(θ)L(\theta)L(θ) 就是“所有样本同时发生”的联合概率。因为样本独立，所以直接连乘： L(θ)=∏i=1nP(xi;θ)L(\theta) = \prod_{i=1}^n P(x_i; \theta) L(θ)=i=1∏n​P(xi​;θ) 注意，如果是连续型分布，这里的P直接换成概率密度函数f就可以了   Step 2: 取对数 ln⁡L(θ)\ln L(\t...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2026/01/10/obsidian/90-Archived/%E8%AF%BE%E7%A8%8B/%E5%BA%94%E7%94%A8%E9%AB%98%E7%AD%89%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6/%E6%AD%A3%E6%80%81%E6%80%BB%E4%BD%93%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83%E5%AE%9A%E7%90%86/" title="正态总体抽样分布定理">正态总体抽样分布定理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2026-01-10T11:52:10.000Z" title="发表于 2026-01-10 19:52:10">2026-01-10</time></span></div><div class="content"> 1. 定理一：样本均值的分布（最基础） 内容： 如果总体 X∼N(μ,σ2)X \sim N(\mu, \sigma^2)X∼N(μ,σ2)，那么样本均值 Xˉ\bar{X}Xˉ 也服从正态分布。 不管样本量 nnn 是大是小，这个结论都成立。 公式： Xˉ∼N(μ,σ2n)\bar{X} \sim N\left(\mu, \frac{\sigma^2}{n}\right) Xˉ∼N(μ,nσ2​) 标准化后： Z=Xˉ−μσ/n∼N(0,1)Z = \frac{\bar{X} - \mu}{\sigma/\sqrt{n}} \sim N(0, 1) Z=σ/n​Xˉ−μ​∼N(0,1)  考点：题目里如果给了 σ\sigmaσ（已知方差），让你求 Xˉ\bar{X}Xˉ 的概率，直接用这个。    2. 定理二：Cochran定理推论（样本方差的分布） 内容： 样本方差 S2S^2S2 经过“标准化”处理后，服从自由度为 n−1n-1n−1 的卡方分布。 公式（必背）： (n−1)S2σ2=∑i=1n(Xi−Xˉ)2σ2∼χ2(n−1)\frac{(n-1)S^2}{\sig...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2026/01/09/obsidian/90-Archived/%E8%AF%BE%E7%A8%8B/%E5%BA%94%E7%94%A8%E9%AB%98%E7%AD%89%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6/%E6%AC%A7%E6%8B%89%E6%B3%95/" title="欧拉法">欧拉法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2026-01-09T14:07:32.000Z" title="发表于 2026-01-09 22:07:32">2026-01-09</time></span></div><div class="content"> 1. 欧拉法 (Euler Method) 欧拉法通过当前点的切线斜率来预测下一点，是一阶数值方法。 详细步骤：   计算斜率：计算微分方程在当前点 (xn,yn)(x_n, y_n)(xn​,yn​) 处的斜率 k1=f(xn,yn)k_1 = f(x_n, y_n)k1​=f(xn​,yn​)。   向前预测：沿着斜率方向向前走步长 hhh，直接估算下一点的 yyy 值。 yn+1=yn+h⋅k1y_{n+1} = y_n + h \cdot k_1 yn+1​=yn​+h⋅k1​   更新坐标：xn+1=xn+hx_{n+1} = x_n + hxn+1​=xn​+h。     2. 改进欧拉法 (Improved Euler Method) 改进欧拉法（又称 Heun 方法）采用预测-校正策略，利用“出发点”和“预测点”两处的斜率平均值来推算下一点，精度更高。 详细步骤：   预测 (Predictor)：   首先计算当前点 (xn,yn)(x_n, y_n)(xn​,yn​) 的斜率 k1=f(xn,yn)k_1 = f(x_n, y_n)k1​=f(xn​,yn​...</div></div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/5/#content-inner"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/#content-inner">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/#content-inner">7</a><a class="extend next" rel="next" href="/page/7/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/mai.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">HRbenY</div><div class="author-info-description">个人技术博客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hrbeny"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/hrbeny" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:hrcharck@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/27/obsidian/90-Archived/%E8%AF%BE%E7%A8%8B/%E5%BA%94%E7%94%A8%E9%AB%98%E7%AD%89%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6/%E7%9B%B4%E5%92%8C/" title="直和">直和</a><time datetime="2026-01-27T02:05:20.000Z" title="发表于 2026-01-27 10:05:20">2026-01-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/27/obsidian/90-Archived/%E8%AF%BE%E7%A8%8B/%E5%BA%94%E7%94%A8%E9%AB%98%E7%AD%89%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6/%E7%BB%8F%E9%AA%8C%E5%88%86%E5%B8%83/" title="经验分布">经验分布</a><time datetime="2026-01-27T02:05:20.000Z" title="发表于 2026-01-27 10:05:20">2026-01-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/27/obsidian/90-Archived/%E8%AF%BE%E7%A8%8B/%E5%BA%94%E7%94%A8%E9%AB%98%E7%AD%89%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6/%E8%80%83%E8%AF%95%E8%8C%83%E5%9B%B4/" title="考试范围">考试范围</a><time datetime="2026-01-27T02:05:20.000Z" title="发表于 2026-01-27 10:05:20">2026-01-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/27/obsidian/90-Archived/%E8%AF%BE%E7%A8%8B/%E5%BA%94%E7%94%A8%E9%AB%98%E7%AD%89%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6/%E9%9B%B6%E5%8C%96%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%A4%9A%E9%A1%B9%E5%BC%8F/" title="零化多项式与最小多项式">零化多项式与最小多项式</a><time datetime="2026-01-27T02:05:20.000Z" title="发表于 2026-01-27 10:05:20">2026-01-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/27/obsidian/90-Archived/%E8%AF%BE%E7%A8%8B/%E5%BA%94%E7%94%A8%E9%AB%98%E7%AD%89%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6/%E9%A2%98%E5%9E%8B/" title="题型">题型</a><time datetime="2026-01-27T02:05:20.000Z" title="发表于 2026-01-27 10:05:20">2026-01-27</time></div></div></div></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/lang-python/" style="font-size: 1.18em; color: #999ca1">lang/python</a> <a href="/tags/topic-gpu/" style="font-size: 1.1em; color: #999">topic/gpu</a> <a href="/tags/lang-shell/" style="font-size: 1.1em; color: #999">lang/shell</a> <a href="/tags/tools-hexo/" style="font-size: 1.1em; color: #999">tools/hexo</a> <a href="/tags/type-note/" style="font-size: 1.42em; color: #99a6b7">type/note</a> <a href="/tags/tools-obsidian/" style="font-size: 1.1em; color: #999">tools/obsidian</a> <a href="/tags/topic-algo/" style="font-size: 1.26em; color: #999fa8">topic/algo</a> <a href="/tags/type-snippet/" style="font-size: 1.18em; color: #999ca1">type/snippet</a> <a href="/tags/lang-cpp/" style="font-size: 1.5em; color: #99a9bf">lang/cpp</a> <a href="/tags/type-note/" style="font-size: 1.18em; color: #999ca1">#type/note</a> <a href="/tags/lang-cpp/" style="font-size: 1.18em; color: #999ca1">#lang/cpp</a> <a href="/tags/topic-algo/" style="font-size: 1.1em; color: #999">#topic/algo</a> <a href="/tags/topic-transformer/" style="font-size: 1.34em; color: #99a3b0">topic/transformer</a> <a href="/tags/lang-cuda/" style="font-size: 1.1em; color: #999">lang/cuda</a></div></div><div class="card-widget card-archives">
    <div class="item-headline">
      <i class="fas fa-archive"></i>
      <span>归档</span>
      
    </div>
  
    <ul class="card-archive-list">
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2026/01/">
            <span class="card-archive-list-date">
              一月 2026
            </span>
            <span class="card-archive-list-count">68</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/12/">
            <span class="card-archive-list-date">
              十二月 2025
            </span>
            <span class="card-archive-list-count">1</span>
          </a>
        </li>
      
    </ul>
  </div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站信息</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">69</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总浏览量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2026-01-27T08:17:37.099Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By HRbenY</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4-b1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4-b1"></script><script src="/js/main.js?v=5.5.4-b1"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>